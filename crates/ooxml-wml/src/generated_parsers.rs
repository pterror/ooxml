// Event-based parsers for generated types.
// ~3x faster than serde-based deserialization.

#![allow(unused_variables)]
#![allow(clippy::single_match)]
#![allow(clippy::match_single_binding)]
#![allow(clippy::manual_is_multiple_of)]

use super::generated::*;
#[cfg(feature = "extra-children")]
use ooxml_xml::{PositionedNode, RawXmlElement, RawXmlNode};
use quick_xml::Reader;
use quick_xml::events::{BytesStart, Event};
use std::io::BufRead;

/// Error type for XML parsing.
#[derive(Debug)]
pub enum ParseError {
    Xml(quick_xml::Error),
    #[cfg(feature = "extra-children")]
    RawXml(ooxml_xml::Error),
    UnexpectedElement(String),
    MissingAttribute(String),
    InvalidValue(String),
}

impl From<quick_xml::Error> for ParseError {
    fn from(e: quick_xml::Error) -> Self {
        ParseError::Xml(e)
    }
}

#[cfg(feature = "extra-children")]
impl From<ooxml_xml::Error> for ParseError {
    fn from(e: ooxml_xml::Error) -> Self {
        ParseError::RawXml(e)
    }
}

/// Trait for types that can be parsed from XML events.
pub trait FromXml: Sized {
    /// Parse from a reader, given the opening tag.
    /// If `is_empty` is true, the element was self-closing (no children to read).
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError>;
}

#[allow(dead_code)]
/// Skip an element and all its children.
fn skip_element<R: BufRead>(reader: &mut Reader<R>) -> Result<(), ParseError> {
    let mut depth = 1u32;
    let mut buf = Vec::new();
    loop {
        match reader.read_event_into(&mut buf)? {
            Event::Start(_) => depth += 1,
            Event::End(_) => {
                depth -= 1;
                if depth == 0 {
                    break;
                }
            }
            Event::Eof => break,
            _ => {}
        }
        buf.clear();
    }
    Ok(())
}

#[allow(dead_code)]
/// Read the text content of an element until its end tag.
fn read_text_content<R: BufRead>(reader: &mut Reader<R>) -> Result<String, ParseError> {
    let mut text = String::new();
    let mut buf = Vec::new();
    loop {
        match reader.read_event_into(&mut buf)? {
            Event::Text(e) => text.push_str(&e.decode().unwrap_or_default()),
            Event::CData(e) => text.push_str(&e.decode().unwrap_or_default()),
            Event::End(_) => break,
            Event::Eof => break,
            _ => {}
        }
        buf.clear();
    }
    Ok(text)
}

#[allow(dead_code)]
/// Decode a hex string to bytes.
fn decode_hex(s: &str) -> Option<Vec<u8>> {
    let s = s.trim();
    if s.len() % 2 != 0 {
        return None;
    }
    (0..s.len())
        .step_by(2)
        .map(|i| u8::from_str_radix(&s[i..i + 2], 16).ok())
        .collect()
}

impl FromXml for CTEmpty {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        _start: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        if !is_empty {
            let mut buf = Vec::new();
            let mut depth = 1u32;
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(_) => depth += 1,
                    Event::End(_) => {
                        depth -= 1;
                        if depth == 0 {
                            break;
                        }
                    }
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }
        Ok(Self {})
    }
}

impl FromXml for CTOnOff {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTLongHexNumber {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STLongHexNumber> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = decode_hex(&val);
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTCharset {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value = None;
        let mut f_character_set = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = decode_hex(&val);
                }
                b"characterSet" => {
                    f_character_set = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value,
            character_set: f_character_set,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTDecimalNumber {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STDecimalNumber> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTUnsignedDecimalNumber {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STUnsignedDecimalNumber> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTDecimalNumberOrPrecent {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STDecimalNumberOrPercent> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTTwipsMeasure {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STTwipsMeasure> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTSignedTwipsMeasure {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STSignedTwipsMeasure> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTPixelsMeasure {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STPixelsMeasure> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTHpsMeasure {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STHpsMeasure> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTSignedHpsMeasure {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STSignedHpsMeasure> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTMacroName {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STMacroName> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTString {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STString> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTTextScale {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTHighlight {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STHighlightColor> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTColor {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STHexColor> = None;
        let mut f_theme_color = None;
        let mut f_theme_tint = None;
        let mut f_theme_shade = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                b"themeColor" => {
                    f_theme_color = val.parse().ok();
                }
                b"themeTint" => {
                    f_theme_tint = decode_hex(&val);
                }
                b"themeShade" => {
                    f_theme_shade = decode_hex(&val);
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            theme_color: f_theme_color,
            theme_tint: f_theme_tint,
            theme_shade: f_theme_shade,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTLang {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<Language> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTGuid {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTUnderline {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value = None;
        let mut f_color = None;
        let mut f_theme_color = None;
        let mut f_theme_tint = None;
        let mut f_theme_shade = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                b"color" => {
                    f_color = Some(val.into_owned());
                }
                b"themeColor" => {
                    f_theme_color = val.parse().ok();
                }
                b"themeTint" => {
                    f_theme_tint = decode_hex(&val);
                }
                b"themeShade" => {
                    f_theme_shade = decode_hex(&val);
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value,
            color: f_color,
            theme_color: f_theme_color,
            theme_tint: f_theme_tint,
            theme_shade: f_theme_shade,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTTextEffect {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STTextEffect> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTBorder {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STBorder> = None;
        let mut f_color = None;
        let mut f_theme_color = None;
        let mut f_theme_tint = None;
        let mut f_theme_shade = None;
        let mut f_size = None;
        let mut f_space = None;
        let mut f_shadow = None;
        let mut f_frame = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                b"color" => {
                    f_color = Some(val.into_owned());
                }
                b"themeColor" => {
                    f_theme_color = val.parse().ok();
                }
                b"themeTint" => {
                    f_theme_tint = decode_hex(&val);
                }
                b"themeShade" => {
                    f_theme_shade = decode_hex(&val);
                }
                b"sz" => {
                    f_size = val.parse().ok();
                }
                b"space" => {
                    f_space = val.parse().ok();
                }
                b"shadow" => {
                    f_shadow = Some(val.into_owned());
                }
                b"frame" => {
                    f_frame = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            color: f_color,
            theme_color: f_theme_color,
            theme_tint: f_theme_tint,
            theme_shade: f_theme_shade,
            size: f_size,
            space: f_space,
            shadow: f_shadow,
            frame: f_frame,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTShd {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STShd> = None;
        let mut f_color = None;
        let mut f_theme_color = None;
        let mut f_theme_tint = None;
        let mut f_theme_shade = None;
        let mut f_fill = None;
        let mut f_theme_fill = None;
        let mut f_theme_fill_tint = None;
        let mut f_theme_fill_shade = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                b"color" => {
                    f_color = Some(val.into_owned());
                }
                b"themeColor" => {
                    f_theme_color = val.parse().ok();
                }
                b"themeTint" => {
                    f_theme_tint = decode_hex(&val);
                }
                b"themeShade" => {
                    f_theme_shade = decode_hex(&val);
                }
                b"fill" => {
                    f_fill = Some(val.into_owned());
                }
                b"themeFill" => {
                    f_theme_fill = val.parse().ok();
                }
                b"themeFillTint" => {
                    f_theme_fill_tint = decode_hex(&val);
                }
                b"themeFillShade" => {
                    f_theme_fill_shade = decode_hex(&val);
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            color: f_color,
            theme_color: f_theme_color,
            theme_tint: f_theme_tint,
            theme_shade: f_theme_shade,
            fill: f_fill,
            theme_fill: f_theme_fill,
            theme_fill_tint: f_theme_fill_tint,
            theme_fill_shade: f_theme_fill_shade,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTVerticalAlignRun {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STVerticalAlignRun> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTFitText {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STTwipsMeasure> = None;
        let mut f_id = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                b"id" => {
                    f_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            id: f_id,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTEm {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STEm> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTLanguage {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value = None;
        let mut f_east_asia = None;
        let mut f_bidi = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                b"eastAsia" => {
                    f_east_asia = Some(val.into_owned());
                }
                b"bidi" => {
                    f_bidi = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value,
            east_asia: f_east_asia,
            bidi: f_bidi,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTEastAsianLayout {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id = None;
        let mut f_combine = None;
        let mut f_combine_brackets = None;
        let mut f_vert = None;
        let mut f_vert_compress = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"combine" => {
                    f_combine = Some(val.into_owned());
                }
                b"combineBrackets" => {
                    f_combine_brackets = val.parse().ok();
                }
                b"vert" => {
                    f_vert = Some(val.into_owned());
                }
                b"vertCompress" => {
                    f_vert_compress = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id,
            combine: f_combine,
            combine_brackets: f_combine_brackets,
            vert: f_vert,
            vert_compress: f_vert_compress,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTFramePr {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_drop_cap = None;
        let mut f_lines = None;
        let mut f_width = None;
        let mut f_height = None;
        let mut f_v_space = None;
        let mut f_h_space = None;
        let mut f_wrap = None;
        let mut f_h_anchor = None;
        let mut f_v_anchor = None;
        let mut f_x = None;
        let mut f_x_align = None;
        let mut f_y = None;
        let mut f_y_align = None;
        let mut f_h_rule = None;
        let mut f_anchor_lock = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"dropCap" => {
                    f_drop_cap = val.parse().ok();
                }
                b"lines" => {
                    f_lines = val.parse().ok();
                }
                b"w" => {
                    f_width = Some(val.into_owned());
                }
                b"h" => {
                    f_height = Some(val.into_owned());
                }
                b"vSpace" => {
                    f_v_space = Some(val.into_owned());
                }
                b"hSpace" => {
                    f_h_space = Some(val.into_owned());
                }
                b"wrap" => {
                    f_wrap = val.parse().ok();
                }
                b"hAnchor" => {
                    f_h_anchor = val.parse().ok();
                }
                b"vAnchor" => {
                    f_v_anchor = val.parse().ok();
                }
                b"x" => {
                    f_x = Some(val.into_owned());
                }
                b"xAlign" => {
                    f_x_align = val.parse().ok();
                }
                b"y" => {
                    f_y = Some(val.into_owned());
                }
                b"yAlign" => {
                    f_y_align = val.parse().ok();
                }
                b"hRule" => {
                    f_h_rule = val.parse().ok();
                }
                b"anchorLock" => {
                    f_anchor_lock = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            drop_cap: f_drop_cap,
            lines: f_lines,
            width: f_width,
            height: f_height,
            v_space: f_v_space,
            h_space: f_h_space,
            wrap: f_wrap,
            h_anchor: f_h_anchor,
            v_anchor: f_v_anchor,
            x: f_x,
            x_align: f_x_align,
            y: f_y,
            y_align: f_y_align,
            h_rule: f_h_rule,
            anchor_lock: f_anchor_lock,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTTabStop {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STTabJc> = None;
        let mut f_leader = None;
        let mut f_pos: Option<STSignedTwipsMeasure> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                b"leader" => {
                    f_leader = val.parse().ok();
                }
                b"pos" => {
                    f_pos = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            leader: f_leader,
            pos: f_pos.ok_or_else(|| ParseError::MissingAttribute("pos".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTSpacing {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_before = None;
        let mut f_before_lines = None;
        let mut f_before_autospacing = None;
        let mut f_after = None;
        let mut f_after_lines = None;
        let mut f_after_autospacing = None;
        let mut f_line = None;
        let mut f_line_rule = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"before" => {
                    f_before = Some(val.into_owned());
                }
                b"beforeLines" => {
                    f_before_lines = val.parse().ok();
                }
                b"beforeAutospacing" => {
                    f_before_autospacing = Some(val.into_owned());
                }
                b"after" => {
                    f_after = Some(val.into_owned());
                }
                b"afterLines" => {
                    f_after_lines = val.parse().ok();
                }
                b"afterAutospacing" => {
                    f_after_autospacing = Some(val.into_owned());
                }
                b"line" => {
                    f_line = Some(val.into_owned());
                }
                b"lineRule" => {
                    f_line_rule = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            before: f_before,
            before_lines: f_before_lines,
            before_autospacing: f_before_autospacing,
            after: f_after,
            after_lines: f_after_lines,
            after_autospacing: f_after_autospacing,
            line: f_line,
            line_rule: f_line_rule,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTInd {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_start = None;
        let mut f_start_chars = None;
        let mut f_end = None;
        let mut f_end_chars = None;
        let mut f_left = None;
        let mut f_left_chars = None;
        let mut f_right = None;
        let mut f_right_chars = None;
        let mut f_hanging = None;
        let mut f_hanging_chars = None;
        let mut f_first_line = None;
        let mut f_first_line_chars = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"start" => {
                    f_start = Some(val.into_owned());
                }
                b"startChars" => {
                    f_start_chars = val.parse().ok();
                }
                b"end" => {
                    f_end = Some(val.into_owned());
                }
                b"endChars" => {
                    f_end_chars = val.parse().ok();
                }
                b"left" => {
                    f_left = Some(val.into_owned());
                }
                b"leftChars" => {
                    f_left_chars = val.parse().ok();
                }
                b"right" => {
                    f_right = Some(val.into_owned());
                }
                b"rightChars" => {
                    f_right_chars = val.parse().ok();
                }
                b"hanging" => {
                    f_hanging = Some(val.into_owned());
                }
                b"hangingChars" => {
                    f_hanging_chars = val.parse().ok();
                }
                b"firstLine" => {
                    f_first_line = Some(val.into_owned());
                }
                b"firstLineChars" => {
                    f_first_line_chars = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            start: f_start,
            start_chars: f_start_chars,
            end: f_end,
            end_chars: f_end_chars,
            left: f_left,
            left_chars: f_left_chars,
            right: f_right,
            right_chars: f_right_chars,
            hanging: f_hanging,
            hanging_chars: f_hanging_chars,
            first_line: f_first_line,
            first_line_chars: f_first_line_chars,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTJc {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STJc> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTJcTable {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STJcTable> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTView {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STView> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTZoom {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value = None;
        let mut f_percent: Option<STDecimalNumberOrPercent> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                b"percent" => {
                    f_percent = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value,
            percent: f_percent
                .ok_or_else(|| ParseError::MissingAttribute("percent".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTWritingStyle {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_lang: Option<Language> = None;
        let mut f_vendor_i_d: Option<STString> = None;
        let mut f_dll_version: Option<STString> = None;
        let mut f_nl_check = None;
        let mut f_check_style: Option<OnOff> = None;
        let mut f_app_name: Option<STString> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"lang" => {
                    f_lang = Some(val.into_owned());
                }
                b"vendorID" => {
                    f_vendor_i_d = Some(val.into_owned());
                }
                b"dllVersion" => {
                    f_dll_version = Some(val.into_owned());
                }
                b"nlCheck" => {
                    f_nl_check = Some(val.into_owned());
                }
                b"checkStyle" => {
                    f_check_style = Some(val.into_owned());
                }
                b"appName" => {
                    f_app_name = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            lang: f_lang.ok_or_else(|| ParseError::MissingAttribute("lang".to_string()))?,
            vendor_i_d: f_vendor_i_d
                .ok_or_else(|| ParseError::MissingAttribute("vendorID".to_string()))?,
            dll_version: f_dll_version
                .ok_or_else(|| ParseError::MissingAttribute("dllVersion".to_string()))?,
            nl_check: f_nl_check,
            check_style: f_check_style
                .ok_or_else(|| ParseError::MissingAttribute("checkStyle".to_string()))?,
            app_name: f_app_name
                .ok_or_else(|| ParseError::MissingAttribute("appName".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTProof {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_spelling = None;
        let mut f_grammar = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"spelling" => {
                    f_spelling = val.parse().ok();
                }
                b"grammar" => {
                    f_grammar = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            spelling: f_spelling,
            grammar: f_grammar,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTDocType {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STDocType> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for WAGPassword {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_algorithm_name = None;
        let mut f_hash_value = None;
        let mut f_salt_value = None;
        let mut f_spin_count = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"algorithmName" => {
                    f_algorithm_name = Some(val.into_owned());
                }
                b"hashValue" => {
                    f_hash_value = decode_hex(&val);
                }
                b"saltValue" => {
                    f_salt_value = decode_hex(&val);
                }
                b"spinCount" => {
                    f_spin_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            algorithm_name: f_algorithm_name,
            hash_value: f_hash_value,
            salt_value: f_salt_value,
            spin_count: f_spin_count,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for WAGTransitionalPassword {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_crypt_provider_type = None;
        let mut f_crypt_algorithm_class = None;
        let mut f_crypt_algorithm_type = None;
        let mut f_crypt_algorithm_sid = None;
        let mut f_crypt_spin_count = None;
        let mut f_crypt_provider = None;
        let mut f_alg_id_ext = None;
        let mut f_alg_id_ext_source = None;
        let mut f_crypt_provider_type_ext = None;
        let mut f_crypt_provider_type_ext_source = None;
        let mut f_hash = None;
        let mut f_salt = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"cryptProviderType" => {
                    f_crypt_provider_type = val.parse().ok();
                }
                b"cryptAlgorithmClass" => {
                    f_crypt_algorithm_class = val.parse().ok();
                }
                b"cryptAlgorithmType" => {
                    f_crypt_algorithm_type = val.parse().ok();
                }
                b"cryptAlgorithmSid" => {
                    f_crypt_algorithm_sid = val.parse().ok();
                }
                b"cryptSpinCount" => {
                    f_crypt_spin_count = val.parse().ok();
                }
                b"cryptProvider" => {
                    f_crypt_provider = Some(val.into_owned());
                }
                b"algIdExt" => {
                    f_alg_id_ext = decode_hex(&val);
                }
                b"algIdExtSource" => {
                    f_alg_id_ext_source = Some(val.into_owned());
                }
                b"cryptProviderTypeExt" => {
                    f_crypt_provider_type_ext = decode_hex(&val);
                }
                b"cryptProviderTypeExtSource" => {
                    f_crypt_provider_type_ext_source = Some(val.into_owned());
                }
                b"hash" => {
                    f_hash = decode_hex(&val);
                }
                b"salt" => {
                    f_salt = decode_hex(&val);
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            crypt_provider_type: f_crypt_provider_type,
            crypt_algorithm_class: f_crypt_algorithm_class,
            crypt_algorithm_type: f_crypt_algorithm_type,
            crypt_algorithm_sid: f_crypt_algorithm_sid,
            crypt_spin_count: f_crypt_spin_count,
            crypt_provider: f_crypt_provider,
            alg_id_ext: f_alg_id_ext,
            alg_id_ext_source: f_alg_id_ext_source,
            crypt_provider_type_ext: f_crypt_provider_type_ext,
            crypt_provider_type_ext_source: f_crypt_provider_type_ext_source,
            hash: f_hash,
            salt: f_salt,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTDocProtect {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_edit = None;
        let mut f_formatting = None;
        let mut f_enforcement = None;
        let mut f_algorithm_name = None;
        let mut f_hash_value = None;
        let mut f_salt_value = None;
        let mut f_spin_count = None;
        let mut f_crypt_provider_type = None;
        let mut f_crypt_algorithm_class = None;
        let mut f_crypt_algorithm_type = None;
        let mut f_crypt_algorithm_sid = None;
        let mut f_crypt_spin_count = None;
        let mut f_crypt_provider = None;
        let mut f_alg_id_ext = None;
        let mut f_alg_id_ext_source = None;
        let mut f_crypt_provider_type_ext = None;
        let mut f_crypt_provider_type_ext_source = None;
        let mut f_hash = None;
        let mut f_salt = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"edit" => {
                    f_edit = val.parse().ok();
                }
                b"formatting" => {
                    f_formatting = Some(val.into_owned());
                }
                b"enforcement" => {
                    f_enforcement = Some(val.into_owned());
                }
                b"algorithmName" => {
                    f_algorithm_name = Some(val.into_owned());
                }
                b"hashValue" => {
                    f_hash_value = decode_hex(&val);
                }
                b"saltValue" => {
                    f_salt_value = decode_hex(&val);
                }
                b"spinCount" => {
                    f_spin_count = val.parse().ok();
                }
                b"cryptProviderType" => {
                    f_crypt_provider_type = val.parse().ok();
                }
                b"cryptAlgorithmClass" => {
                    f_crypt_algorithm_class = val.parse().ok();
                }
                b"cryptAlgorithmType" => {
                    f_crypt_algorithm_type = val.parse().ok();
                }
                b"cryptAlgorithmSid" => {
                    f_crypt_algorithm_sid = val.parse().ok();
                }
                b"cryptSpinCount" => {
                    f_crypt_spin_count = val.parse().ok();
                }
                b"cryptProvider" => {
                    f_crypt_provider = Some(val.into_owned());
                }
                b"algIdExt" => {
                    f_alg_id_ext = decode_hex(&val);
                }
                b"algIdExtSource" => {
                    f_alg_id_ext_source = Some(val.into_owned());
                }
                b"cryptProviderTypeExt" => {
                    f_crypt_provider_type_ext = decode_hex(&val);
                }
                b"cryptProviderTypeExtSource" => {
                    f_crypt_provider_type_ext_source = Some(val.into_owned());
                }
                b"hash" => {
                    f_hash = decode_hex(&val);
                }
                b"salt" => {
                    f_salt = decode_hex(&val);
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            edit: f_edit,
            formatting: f_formatting,
            enforcement: f_enforcement,
            algorithm_name: f_algorithm_name,
            hash_value: f_hash_value,
            salt_value: f_salt_value,
            spin_count: f_spin_count,
            crypt_provider_type: f_crypt_provider_type,
            crypt_algorithm_class: f_crypt_algorithm_class,
            crypt_algorithm_type: f_crypt_algorithm_type,
            crypt_algorithm_sid: f_crypt_algorithm_sid,
            crypt_spin_count: f_crypt_spin_count,
            crypt_provider: f_crypt_provider,
            alg_id_ext: f_alg_id_ext,
            alg_id_ext_source: f_alg_id_ext_source,
            crypt_provider_type_ext: f_crypt_provider_type_ext,
            crypt_provider_type_ext_source: f_crypt_provider_type_ext_source,
            hash: f_hash,
            salt: f_salt,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTMailMergeDocType {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STMailMergeDocType> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTMailMergeDataType {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STMailMergeDataType> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTMailMergeDest {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STMailMergeDest> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTMailMergeOdsoFMDFieldType {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STMailMergeOdsoFMDFieldType> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTTrackChangesView {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_markup = None;
        let mut f_comments = None;
        let mut f_ins_del = None;
        let mut f_formatting = None;
        let mut f_ink_annotations = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"markup" => {
                    f_markup = Some(val.into_owned());
                }
                b"comments" => {
                    f_comments = Some(val.into_owned());
                }
                b"insDel" => {
                    f_ins_del = Some(val.into_owned());
                }
                b"formatting" => {
                    f_formatting = Some(val.into_owned());
                }
                b"inkAnnotations" => {
                    f_ink_annotations = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            markup: f_markup,
            comments: f_comments,
            ins_del: f_ins_del,
            formatting: f_formatting,
            ink_annotations: f_ink_annotations,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTKinsoku {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_lang: Option<Language> = None;
        let mut f_value: Option<STString> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"lang" => {
                    f_lang = Some(val.into_owned());
                }
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            lang: f_lang.ok_or_else(|| ParseError::MissingAttribute("lang".to_string()))?,
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTTextDirection {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STTextDirection> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTTextAlignment {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STTextAlignment> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTMarkup {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STDecimalNumber> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTTrackChange {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STDecimalNumber> = None;
        let mut f_author: Option<STString> = None;
        let mut f_date = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"author" => {
                    f_author = Some(val.into_owned());
                }
                b"date" => {
                    f_date = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            author: f_author.ok_or_else(|| ParseError::MissingAttribute("author".to_string()))?,
            date: f_date,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTCellMergeTrackChange {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STDecimalNumber> = None;
        let mut f_author: Option<STString> = None;
        let mut f_date = None;
        let mut f_vertical_merge = None;
        let mut f_v_merge_orig = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"author" => {
                    f_author = Some(val.into_owned());
                }
                b"date" => {
                    f_date = Some(val.into_owned());
                }
                b"vMerge" => {
                    f_vertical_merge = val.parse().ok();
                }
                b"vMergeOrig" => {
                    f_v_merge_orig = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            author: f_author.ok_or_else(|| ParseError::MissingAttribute("author".to_string()))?,
            date: f_date,
            vertical_merge: f_vertical_merge,
            v_merge_orig: f_v_merge_orig,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTTrackChangeRange {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STDecimalNumber> = None;
        let mut f_author: Option<STString> = None;
        let mut f_date = None;
        let mut f_displaced_by_custom_xml = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"author" => {
                    f_author = Some(val.into_owned());
                }
                b"date" => {
                    f_date = Some(val.into_owned());
                }
                b"displacedByCustomXml" => {
                    f_displaced_by_custom_xml = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            author: f_author.ok_or_else(|| ParseError::MissingAttribute("author".to_string()))?,
            date: f_date,
            displaced_by_custom_xml: f_displaced_by_custom_xml,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTMarkupRange {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STDecimalNumber> = None;
        let mut f_displaced_by_custom_xml = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"displacedByCustomXml" => {
                    f_displaced_by_custom_xml = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            displaced_by_custom_xml: f_displaced_by_custom_xml,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTBookmarkRange {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STDecimalNumber> = None;
        let mut f_displaced_by_custom_xml = None;
        let mut f_col_first = None;
        let mut f_col_last = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"displacedByCustomXml" => {
                    f_displaced_by_custom_xml = val.parse().ok();
                }
                b"colFirst" => {
                    f_col_first = val.parse().ok();
                }
                b"colLast" => {
                    f_col_last = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            displaced_by_custom_xml: f_displaced_by_custom_xml,
            col_first: f_col_first,
            col_last: f_col_last,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for Bookmark {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STDecimalNumber> = None;
        let mut f_displaced_by_custom_xml = None;
        let mut f_col_first = None;
        let mut f_col_last = None;
        let mut f_name: Option<STString> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"displacedByCustomXml" => {
                    f_displaced_by_custom_xml = val.parse().ok();
                }
                b"colFirst" => {
                    f_col_first = val.parse().ok();
                }
                b"colLast" => {
                    f_col_last = val.parse().ok();
                }
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            displaced_by_custom_xml: f_displaced_by_custom_xml,
            col_first: f_col_first,
            col_last: f_col_last,
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTMoveBookmark {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STDecimalNumber> = None;
        let mut f_displaced_by_custom_xml = None;
        let mut f_col_first = None;
        let mut f_col_last = None;
        let mut f_name: Option<STString> = None;
        let mut f_author: Option<STString> = None;
        let mut f_date: Option<STDateTime> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"displacedByCustomXml" => {
                    f_displaced_by_custom_xml = val.parse().ok();
                }
                b"colFirst" => {
                    f_col_first = val.parse().ok();
                }
                b"colLast" => {
                    f_col_last = val.parse().ok();
                }
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"author" => {
                    f_author = Some(val.into_owned());
                }
                b"date" => {
                    f_date = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            displaced_by_custom_xml: f_displaced_by_custom_xml,
            col_first: f_col_first,
            col_last: f_col_last,
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            author: f_author.ok_or_else(|| ParseError::MissingAttribute("author".to_string()))?,
            date: f_date.ok_or_else(|| ParseError::MissingAttribute("date".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for Comment {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STDecimalNumber> = None;
        let mut f_author: Option<STString> = None;
        let mut f_date = None;
        let mut f_block_content = Vec::new();
        let mut f_initials = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"author" => {
                    f_author = Some(val.into_owned());
                }
                b"date" => {
                    f_date = Some(val.into_owned());
                }
                b"initials" => {
                    f_initials = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"customXml"
                            | b"sdt"
                            | b"p"
                            | b"tbl"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo"
                            | b"altChunk" => {
                                f_block_content
                                    .push(Box::new(BlockContent::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"customXml"
                            | b"sdt"
                            | b"p"
                            | b"tbl"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo"
                            | b"altChunk" => {
                                f_block_content
                                    .push(Box::new(BlockContent::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            author: f_author.ok_or_else(|| ParseError::MissingAttribute("author".to_string()))?,
            date: f_date,
            block_content: f_block_content,
            initials: f_initials,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTTrackChangeNumbering {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STDecimalNumber> = None;
        let mut f_author: Option<STString> = None;
        let mut f_date = None;
        let mut f_original = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"author" => {
                    f_author = Some(val.into_owned());
                }
                b"date" => {
                    f_date = Some(val.into_owned());
                }
                b"original" => {
                    f_original = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            author: f_author.ok_or_else(|| ParseError::MissingAttribute("author".to_string()))?,
            date: f_date,
            original: f_original,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTTblPrExChange {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STDecimalNumber> = None;
        let mut f_author: Option<STString> = None;
        let mut f_date = None;
        let mut f_tbl_pr_ex: Option<Box<CTTblPrExBase>> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"author" => {
                    f_author = Some(val.into_owned());
                }
                b"date" => {
                    f_date = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"tblPrEx" => {
                                f_tbl_pr_ex =
                                    Some(Box::new(CTTblPrExBase::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"tblPrEx" => {
                                f_tbl_pr_ex =
                                    Some(Box::new(CTTblPrExBase::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            author: f_author.ok_or_else(|| ParseError::MissingAttribute("author".to_string()))?,
            date: f_date,
            tbl_pr_ex: f_tbl_pr_ex
                .ok_or_else(|| ParseError::MissingAttribute("tblPrEx".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTTcPrChange {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STDecimalNumber> = None;
        let mut f_author: Option<STString> = None;
        let mut f_date = None;
        let mut f_cell_properties: Option<Box<CTTcPrInner>> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"author" => {
                    f_author = Some(val.into_owned());
                }
                b"date" => {
                    f_date = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"tcPr" => {
                                f_cell_properties =
                                    Some(Box::new(CTTcPrInner::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"tcPr" => {
                                f_cell_properties =
                                    Some(Box::new(CTTcPrInner::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            author: f_author.ok_or_else(|| ParseError::MissingAttribute("author".to_string()))?,
            date: f_date,
            cell_properties: f_cell_properties
                .ok_or_else(|| ParseError::MissingAttribute("tcPr".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTTrPrChange {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STDecimalNumber> = None;
        let mut f_author: Option<STString> = None;
        let mut f_date = None;
        let mut f_row_properties: Option<Box<CTTrPrBase>> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"author" => {
                    f_author = Some(val.into_owned());
                }
                b"date" => {
                    f_date = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"trPr" => {
                                f_row_properties =
                                    Some(Box::new(CTTrPrBase::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"trPr" => {
                                f_row_properties =
                                    Some(Box::new(CTTrPrBase::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            author: f_author.ok_or_else(|| ParseError::MissingAttribute("author".to_string()))?,
            date: f_date,
            row_properties: f_row_properties
                .ok_or_else(|| ParseError::MissingAttribute("trPr".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTTblGridChange {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STDecimalNumber> = None;
        let mut f_tbl_grid: Option<Box<CTTblGridBase>> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"tblGrid" => {
                                f_tbl_grid =
                                    Some(Box::new(CTTblGridBase::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"tblGrid" => {
                                f_tbl_grid =
                                    Some(Box::new(CTTblGridBase::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            tbl_grid: f_tbl_grid
                .ok_or_else(|| ParseError::MissingAttribute("tblGrid".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTTblPrChange {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STDecimalNumber> = None;
        let mut f_author: Option<STString> = None;
        let mut f_date = None;
        let mut f_table_properties: Option<Box<CTTblPrBase>> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"author" => {
                    f_author = Some(val.into_owned());
                }
                b"date" => {
                    f_date = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"tblPr" => {
                                f_table_properties =
                                    Some(Box::new(CTTblPrBase::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"tblPr" => {
                                f_table_properties =
                                    Some(Box::new(CTTblPrBase::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            author: f_author.ok_or_else(|| ParseError::MissingAttribute("author".to_string()))?,
            date: f_date,
            table_properties: f_table_properties
                .ok_or_else(|| ParseError::MissingAttribute("tblPr".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTSectPrChange {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STDecimalNumber> = None;
        let mut f_author: Option<STString> = None;
        let mut f_date = None;
        let mut f_sect_pr = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"author" => {
                    f_author = Some(val.into_owned());
                }
                b"date" => {
                    f_date = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"sectPr" => {
                                f_sect_pr =
                                    Some(Box::new(CTSectPrBase::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"sectPr" => {
                                f_sect_pr =
                                    Some(Box::new(CTSectPrBase::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            author: f_author.ok_or_else(|| ParseError::MissingAttribute("author".to_string()))?,
            date: f_date,
            sect_pr: f_sect_pr,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTPPrChange {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STDecimalNumber> = None;
        let mut f_author: Option<STString> = None;
        let mut f_date = None;
        let mut f_p_pr: Option<Box<CTPPrBase>> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"author" => {
                    f_author = Some(val.into_owned());
                }
                b"date" => {
                    f_date = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"pPr" => {
                                f_p_pr = Some(Box::new(CTPPrBase::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"pPr" => {
                                f_p_pr = Some(Box::new(CTPPrBase::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            author: f_author.ok_or_else(|| ParseError::MissingAttribute("author".to_string()))?,
            date: f_date,
            p_pr: f_p_pr.ok_or_else(|| ParseError::MissingAttribute("pPr".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTRPrChange {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STDecimalNumber> = None;
        let mut f_author: Option<STString> = None;
        let mut f_date = None;
        let mut f_r_pr: Option<Box<CTRPrOriginal>> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"author" => {
                    f_author = Some(val.into_owned());
                }
                b"date" => {
                    f_date = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"rPr" => {
                                f_r_pr =
                                    Some(Box::new(CTRPrOriginal::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"rPr" => {
                                f_r_pr = Some(Box::new(CTRPrOriginal::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            author: f_author.ok_or_else(|| ParseError::MissingAttribute("author".to_string()))?,
            date: f_date,
            r_pr: f_r_pr.ok_or_else(|| ParseError::MissingAttribute("rPr".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTParaRPrChange {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STDecimalNumber> = None;
        let mut f_author: Option<STString> = None;
        let mut f_date = None;
        let mut f_r_pr: Option<Box<CTParaRPrOriginal>> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"author" => {
                    f_author = Some(val.into_owned());
                }
                b"date" => {
                    f_date = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"rPr" => {
                                f_r_pr =
                                    Some(Box::new(CTParaRPrOriginal::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"rPr" => {
                                f_r_pr =
                                    Some(Box::new(CTParaRPrOriginal::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            author: f_author.ok_or_else(|| ParseError::MissingAttribute("author".to_string()))?,
            date: f_date,
            r_pr: f_r_pr.ok_or_else(|| ParseError::MissingAttribute("rPr".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTRunTrackChange {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STDecimalNumber> = None;
        let mut f_author: Option<STString> = None;
        let mut f_date = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"author" => {
                    f_author = Some(val.into_owned());
                }
                b"date" => {
                    f_date = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            author: f_author.ok_or_else(|| ParseError::MissingAttribute("author".to_string()))?,
            date: f_date,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for MathContent {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    #[cfg(feature = "extra-children")]
                    Event::Start(e) => {
                        let elem = RawXmlElement::from_reader(reader, &e)?;
                        extra_children
                            .push(PositionedNode::new(child_idx, RawXmlNode::Element(elem)));
                        child_idx += 1;
                    }
                    #[cfg(not(feature = "extra-children"))]
                    Event::Start(_) => {
                        skip_element(reader)?;
                    }
                    #[cfg(feature = "extra-children")]
                    Event::Empty(e) => {
                        let elem = RawXmlElement::from_empty(&e);
                        extra_children
                            .push(PositionedNode::new(child_idx, RawXmlNode::Element(elem)));
                        child_idx += 1;
                    }
                    #[cfg(not(feature = "extra-children"))]
                    Event::Empty(_) => {}
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }
        Ok(Self {
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for ParagraphContentBase {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let tag = start_tag.local_name();
        match tag.as_ref() {
            b"customXml" => {
                let inner = CTCustomXmlRun::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXml(Box::new(inner)))
            }
            b"fldSimple" => {
                let inner = CTSimpleField::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::FldSimple(Box::new(inner)))
            }
            b"hyperlink" => {
                let inner = Hyperlink::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Hyperlink(Box::new(inner)))
            }
            _ => Err(ParseError::UnexpectedElement(
                String::from_utf8_lossy(start_tag.name().as_ref()).into_owned(),
            )),
        }
    }
}

impl FromXml for RunContentBase {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let tag = start_tag.local_name();
        match tag.as_ref() {
            b"smartTag" => {
                let inner = CTSmartTagRun::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::SmartTag(Box::new(inner)))
            }
            b"sdt" => {
                let inner = CTSdtRun::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Sdt(Box::new(inner)))
            }
            b"proofErr" => {
                let inner = CTProofErr::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::ProofErr(Box::new(inner)))
            }
            b"permStart" => {
                let inner = CTPermStart::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::PermStart(Box::new(inner)))
            }
            b"permEnd" => {
                let inner = CTPerm::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::PermEnd(Box::new(inner)))
            }
            b"bookmarkStart" => {
                let inner = Bookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::BookmarkStart(Box::new(inner)))
            }
            b"bookmarkEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::BookmarkEnd(Box::new(inner)))
            }
            b"moveFromRangeStart" => {
                let inner = CTMoveBookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveFromRangeStart(Box::new(inner)))
            }
            b"moveFromRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveFromRangeEnd(Box::new(inner)))
            }
            b"moveToRangeStart" => {
                let inner = CTMoveBookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveToRangeStart(Box::new(inner)))
            }
            b"moveToRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveToRangeEnd(Box::new(inner)))
            }
            b"commentRangeStart" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CommentRangeStart(Box::new(inner)))
            }
            b"commentRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CommentRangeEnd(Box::new(inner)))
            }
            b"customXmlInsRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlInsRangeStart(Box::new(inner)))
            }
            b"customXmlInsRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlInsRangeEnd(Box::new(inner)))
            }
            b"customXmlDelRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlDelRangeStart(Box::new(inner)))
            }
            b"customXmlDelRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlDelRangeEnd(Box::new(inner)))
            }
            b"customXmlMoveFromRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveFromRangeStart(Box::new(inner)))
            }
            b"customXmlMoveFromRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveFromRangeEnd(Box::new(inner)))
            }
            b"customXmlMoveToRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveToRangeStart(Box::new(inner)))
            }
            b"customXmlMoveToRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveToRangeEnd(Box::new(inner)))
            }
            b"ins" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Ins(Box::new(inner)))
            }
            b"del" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Del(Box::new(inner)))
            }
            b"moveFrom" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveFrom(Box::new(inner)))
            }
            b"moveTo" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveTo(Box::new(inner)))
            }
            _ => Err(ParseError::UnexpectedElement(
                String::from_utf8_lossy(start_tag.name().as_ref()).into_owned(),
            )),
        }
    }
}

impl FromXml for CellMarkup {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let tag = start_tag.local_name();
        match tag.as_ref() {
            b"cellIns" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CellIns(Box::new(inner)))
            }
            b"cellDel" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CellDel(Box::new(inner)))
            }
            b"cellMerge" => {
                let inner = CTCellMergeTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CellMerge(Box::new(inner)))
            }
            _ => Err(ParseError::UnexpectedElement(
                String::from_utf8_lossy(start_tag.name().as_ref()).into_owned(),
            )),
        }
    }
}

impl FromXml for RangeMarkup {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let tag = start_tag.local_name();
        match tag.as_ref() {
            b"bookmarkStart" => {
                let inner = Bookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::BookmarkStart(Box::new(inner)))
            }
            b"bookmarkEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::BookmarkEnd(Box::new(inner)))
            }
            b"moveFromRangeStart" => {
                let inner = CTMoveBookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveFromRangeStart(Box::new(inner)))
            }
            b"moveFromRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveFromRangeEnd(Box::new(inner)))
            }
            b"moveToRangeStart" => {
                let inner = CTMoveBookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveToRangeStart(Box::new(inner)))
            }
            b"moveToRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveToRangeEnd(Box::new(inner)))
            }
            b"commentRangeStart" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CommentRangeStart(Box::new(inner)))
            }
            b"commentRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CommentRangeEnd(Box::new(inner)))
            }
            b"customXmlInsRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlInsRangeStart(Box::new(inner)))
            }
            b"customXmlInsRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlInsRangeEnd(Box::new(inner)))
            }
            b"customXmlDelRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlDelRangeStart(Box::new(inner)))
            }
            b"customXmlDelRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlDelRangeEnd(Box::new(inner)))
            }
            b"customXmlMoveFromRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveFromRangeStart(Box::new(inner)))
            }
            b"customXmlMoveFromRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveFromRangeEnd(Box::new(inner)))
            }
            b"customXmlMoveToRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveToRangeStart(Box::new(inner)))
            }
            b"customXmlMoveToRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveToRangeEnd(Box::new(inner)))
            }
            _ => Err(ParseError::UnexpectedElement(
                String::from_utf8_lossy(start_tag.name().as_ref()).into_owned(),
            )),
        }
    }
}

impl FromXml for CTNumPr {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_ilvl = None;
        let mut f_num_id = None;
        let mut f_numbering_change = None;
        let mut f_ins = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"ilvl" => {
                                f_ilvl =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numId" => {
                                f_num_id =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numberingChange" => {
                                f_numbering_change = Some(Box::new(
                                    CTTrackChangeNumbering::from_xml(reader, &e, false)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"ins" => {
                                f_ins = Some(Box::new(CTTrackChange::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"ilvl" => {
                                f_ilvl =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numId" => {
                                f_num_id =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numberingChange" => {
                                f_numbering_change = Some(Box::new(
                                    CTTrackChangeNumbering::from_xml(reader, &e, true)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"ins" => {
                                f_ins = Some(Box::new(CTTrackChange::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            ilvl: f_ilvl,
            num_id: f_num_id,
            numbering_change: f_numbering_change,
            ins: f_ins,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTPBdr {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_top = None;
        let mut f_left = None;
        let mut f_bottom = None;
        let mut f_right = None;
        let mut f_between = None;
        let mut f_bar = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"top" => {
                                f_top = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"left" => {
                                f_left = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bottom" => {
                                f_bottom = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"right" => {
                                f_right = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"between" => {
                                f_between = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bar" => {
                                f_bar = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"top" => {
                                f_top = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"left" => {
                                f_left = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bottom" => {
                                f_bottom = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"right" => {
                                f_right = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"between" => {
                                f_between = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bar" => {
                                f_bar = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            top: f_top,
            left: f_left,
            bottom: f_bottom,
            right: f_right,
            between: f_between,
            bar: f_bar,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTTabs {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_tab = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"tab" => {
                                f_tab.push(Box::new(CTTabStop::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"tab" => {
                                f_tab.push(Box::new(CTTabStop::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            tab: f_tab,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTTextboxTightWrap {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STTextboxTightWrap> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for ParagraphProperties {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_paragraph_style = None;
        #[cfg(feature = "wml-layout")]
        let mut f_keep_next = None;
        #[cfg(feature = "wml-layout")]
        let mut f_keep_lines = None;
        #[cfg(feature = "wml-layout")]
        let mut f_page_break_before = None;
        #[cfg(feature = "wml-layout")]
        let mut f_frame_pr = None;
        #[cfg(feature = "wml-layout")]
        let mut f_widow_control = None;
        #[cfg(feature = "wml-numbering")]
        let mut f_num_pr = None;
        #[cfg(feature = "wml-layout")]
        let mut f_suppress_line_numbers = None;
        #[cfg(feature = "wml-styling")]
        let mut f_paragraph_border = None;
        #[cfg(feature = "wml-styling")]
        let mut f_shading = None;
        #[cfg(feature = "wml-styling")]
        let mut f_tabs = None;
        #[cfg(feature = "wml-styling")]
        let mut f_suppress_auto_hyphens = None;
        #[cfg(feature = "wml-styling")]
        let mut f_kinsoku = None;
        #[cfg(feature = "wml-styling")]
        let mut f_word_wrap = None;
        #[cfg(feature = "wml-styling")]
        let mut f_overflow_punct = None;
        #[cfg(feature = "wml-styling")]
        let mut f_top_line_punct = None;
        #[cfg(feature = "wml-styling")]
        let mut f_auto_space_d_e = None;
        #[cfg(feature = "wml-styling")]
        let mut f_auto_space_d_n = None;
        #[cfg(feature = "wml-styling")]
        let mut f_bidi = None;
        #[cfg(feature = "wml-styling")]
        let mut f_adjust_right_ind = None;
        #[cfg(feature = "wml-layout")]
        let mut f_snap_to_grid = None;
        #[cfg(feature = "wml-styling")]
        let mut f_spacing = None;
        #[cfg(feature = "wml-styling")]
        let mut f_indentation = None;
        #[cfg(feature = "wml-styling")]
        let mut f_contextual_spacing = None;
        #[cfg(feature = "wml-styling")]
        let mut f_mirror_indents = None;
        #[cfg(feature = "wml-layout")]
        let mut f_suppress_overlap = None;
        #[cfg(feature = "wml-styling")]
        let mut f_justification = None;
        #[cfg(feature = "wml-styling")]
        let mut f_text_direction = None;
        #[cfg(feature = "wml-styling")]
        let mut f_text_alignment = None;
        #[cfg(feature = "wml-styling")]
        let mut f_textbox_tight_wrap = None;
        #[cfg(feature = "wml-styling")]
        let mut f_outline_lvl = None;
        #[cfg(feature = "wml-styling")]
        let mut f_div_id = None;
        #[cfg(feature = "wml-styling")]
        let mut f_cnf_style = None;
        #[cfg(feature = "wml-styling")]
        let mut f_r_pr = None;
        #[cfg(feature = "wml-layout")]
        let mut f_sect_pr = None;
        #[cfg(feature = "wml-track-changes")]
        let mut f_p_pr_change = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"pStyle" => {
                                f_paragraph_style =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"keepNext" => {
                                f_keep_next = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"keepLines" => {
                                f_keep_lines =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"pageBreakBefore" => {
                                f_page_break_before =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"framePr" => {
                                f_frame_pr =
                                    Some(Box::new(CTFramePr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"widowControl" => {
                                f_widow_control =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-numbering")]
                            b"numPr" => {
                                f_num_pr = Some(Box::new(CTNumPr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"suppressLineNumbers" => {
                                f_suppress_line_numbers =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"pBdr" => {
                                f_paragraph_border =
                                    Some(Box::new(CTPBdr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"tabs" => {
                                f_tabs = Some(Box::new(CTTabs::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"suppressAutoHyphens" => {
                                f_suppress_auto_hyphens =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"kinsoku" => {
                                f_kinsoku = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"wordWrap" => {
                                f_word_wrap = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"overflowPunct" => {
                                f_overflow_punct =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"topLinePunct" => {
                                f_top_line_punct =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"autoSpaceDE" => {
                                f_auto_space_d_e =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"autoSpaceDN" => {
                                f_auto_space_d_n =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"bidi" => {
                                f_bidi = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"adjustRightInd" => {
                                f_adjust_right_ind =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"snapToGrid" => {
                                f_snap_to_grid =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"spacing" => {
                                f_spacing = Some(Box::new(CTSpacing::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"ind" => {
                                f_indentation = Some(Box::new(CTInd::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"contextualSpacing" => {
                                f_contextual_spacing =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"mirrorIndents" => {
                                f_mirror_indents =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"suppressOverlap" => {
                                f_suppress_overlap =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"jc" => {
                                f_justification =
                                    Some(Box::new(CTJc::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"textDirection" => {
                                f_text_direction =
                                    Some(Box::new(CTTextDirection::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"textAlignment" => {
                                f_text_alignment =
                                    Some(Box::new(CTTextAlignment::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"textboxTightWrap" => {
                                f_textbox_tight_wrap = Some(Box::new(
                                    CTTextboxTightWrap::from_xml(reader, &e, false)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"outlineLvl" => {
                                f_outline_lvl =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"divId" => {
                                f_div_id =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"cnfStyle" => {
                                f_cnf_style = Some(Box::new(CTCnf::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"rPr" => {
                                f_r_pr = Some(Box::new(CTParaRPr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"sectPr" => {
                                f_sect_pr =
                                    Some(Box::new(SectionProperties::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-track-changes")]
                            b"pPrChange" => {
                                f_p_pr_change =
                                    Some(Box::new(CTPPrChange::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"pStyle" => {
                                f_paragraph_style =
                                    Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"keepNext" => {
                                f_keep_next = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"keepLines" => {
                                f_keep_lines = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"pageBreakBefore" => {
                                f_page_break_before =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"framePr" => {
                                f_frame_pr = Some(Box::new(CTFramePr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"widowControl" => {
                                f_widow_control =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-numbering")]
                            b"numPr" => {
                                f_num_pr = Some(Box::new(CTNumPr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"suppressLineNumbers" => {
                                f_suppress_line_numbers =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"pBdr" => {
                                f_paragraph_border =
                                    Some(Box::new(CTPBdr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"tabs" => {
                                f_tabs = Some(Box::new(CTTabs::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"suppressAutoHyphens" => {
                                f_suppress_auto_hyphens =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"kinsoku" => {
                                f_kinsoku = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"wordWrap" => {
                                f_word_wrap = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"overflowPunct" => {
                                f_overflow_punct =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"topLinePunct" => {
                                f_top_line_punct =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"autoSpaceDE" => {
                                f_auto_space_d_e =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"autoSpaceDN" => {
                                f_auto_space_d_n =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"bidi" => {
                                f_bidi = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"adjustRightInd" => {
                                f_adjust_right_ind =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"snapToGrid" => {
                                f_snap_to_grid =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"spacing" => {
                                f_spacing = Some(Box::new(CTSpacing::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"ind" => {
                                f_indentation = Some(Box::new(CTInd::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"contextualSpacing" => {
                                f_contextual_spacing =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"mirrorIndents" => {
                                f_mirror_indents =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"suppressOverlap" => {
                                f_suppress_overlap =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"jc" => {
                                f_justification = Some(Box::new(CTJc::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"textDirection" => {
                                f_text_direction =
                                    Some(Box::new(CTTextDirection::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"textAlignment" => {
                                f_text_alignment =
                                    Some(Box::new(CTTextAlignment::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"textboxTightWrap" => {
                                f_textbox_tight_wrap =
                                    Some(Box::new(CTTextboxTightWrap::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"outlineLvl" => {
                                f_outline_lvl =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"divId" => {
                                f_div_id =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"cnfStyle" => {
                                f_cnf_style = Some(Box::new(CTCnf::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"rPr" => {
                                f_r_pr = Some(Box::new(CTParaRPr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"sectPr" => {
                                f_sect_pr =
                                    Some(Box::new(SectionProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-track-changes")]
                            b"pPrChange" => {
                                f_p_pr_change =
                                    Some(Box::new(CTPPrChange::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            paragraph_style: f_paragraph_style,
            #[cfg(feature = "wml-layout")]
            keep_next: f_keep_next,
            #[cfg(feature = "wml-layout")]
            keep_lines: f_keep_lines,
            #[cfg(feature = "wml-layout")]
            page_break_before: f_page_break_before,
            #[cfg(feature = "wml-layout")]
            frame_pr: f_frame_pr,
            #[cfg(feature = "wml-layout")]
            widow_control: f_widow_control,
            #[cfg(feature = "wml-numbering")]
            num_pr: f_num_pr,
            #[cfg(feature = "wml-layout")]
            suppress_line_numbers: f_suppress_line_numbers,
            #[cfg(feature = "wml-styling")]
            paragraph_border: f_paragraph_border,
            #[cfg(feature = "wml-styling")]
            shading: f_shading,
            #[cfg(feature = "wml-styling")]
            tabs: f_tabs,
            #[cfg(feature = "wml-styling")]
            suppress_auto_hyphens: f_suppress_auto_hyphens,
            #[cfg(feature = "wml-styling")]
            kinsoku: f_kinsoku,
            #[cfg(feature = "wml-styling")]
            word_wrap: f_word_wrap,
            #[cfg(feature = "wml-styling")]
            overflow_punct: f_overflow_punct,
            #[cfg(feature = "wml-styling")]
            top_line_punct: f_top_line_punct,
            #[cfg(feature = "wml-styling")]
            auto_space_d_e: f_auto_space_d_e,
            #[cfg(feature = "wml-styling")]
            auto_space_d_n: f_auto_space_d_n,
            #[cfg(feature = "wml-styling")]
            bidi: f_bidi,
            #[cfg(feature = "wml-styling")]
            adjust_right_ind: f_adjust_right_ind,
            #[cfg(feature = "wml-layout")]
            snap_to_grid: f_snap_to_grid,
            #[cfg(feature = "wml-styling")]
            spacing: f_spacing,
            #[cfg(feature = "wml-styling")]
            indentation: f_indentation,
            #[cfg(feature = "wml-styling")]
            contextual_spacing: f_contextual_spacing,
            #[cfg(feature = "wml-styling")]
            mirror_indents: f_mirror_indents,
            #[cfg(feature = "wml-layout")]
            suppress_overlap: f_suppress_overlap,
            #[cfg(feature = "wml-styling")]
            justification: f_justification,
            #[cfg(feature = "wml-styling")]
            text_direction: f_text_direction,
            #[cfg(feature = "wml-styling")]
            text_alignment: f_text_alignment,
            #[cfg(feature = "wml-styling")]
            textbox_tight_wrap: f_textbox_tight_wrap,
            #[cfg(feature = "wml-styling")]
            outline_lvl: f_outline_lvl,
            #[cfg(feature = "wml-styling")]
            div_id: f_div_id,
            #[cfg(feature = "wml-styling")]
            cnf_style: f_cnf_style,
            #[cfg(feature = "wml-styling")]
            r_pr: f_r_pr,
            #[cfg(feature = "wml-layout")]
            sect_pr: f_sect_pr,
            #[cfg(feature = "wml-track-changes")]
            p_pr_change: f_p_pr_change,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTPPrBase {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_paragraph_style = None;
        let mut f_keep_next = None;
        let mut f_keep_lines = None;
        let mut f_page_break_before = None;
        let mut f_frame_pr = None;
        let mut f_widow_control = None;
        let mut f_num_pr = None;
        let mut f_suppress_line_numbers = None;
        let mut f_paragraph_border = None;
        let mut f_shading = None;
        let mut f_tabs = None;
        let mut f_suppress_auto_hyphens = None;
        let mut f_kinsoku = None;
        let mut f_word_wrap = None;
        let mut f_overflow_punct = None;
        let mut f_top_line_punct = None;
        let mut f_auto_space_d_e = None;
        let mut f_auto_space_d_n = None;
        let mut f_bidi = None;
        let mut f_adjust_right_ind = None;
        let mut f_snap_to_grid = None;
        let mut f_spacing = None;
        let mut f_indentation = None;
        let mut f_contextual_spacing = None;
        let mut f_mirror_indents = None;
        let mut f_suppress_overlap = None;
        let mut f_justification = None;
        let mut f_text_direction = None;
        let mut f_text_alignment = None;
        let mut f_textbox_tight_wrap = None;
        let mut f_outline_lvl = None;
        let mut f_div_id = None;
        let mut f_cnf_style = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"pStyle" => {
                                f_paragraph_style =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"keepNext" => {
                                f_keep_next = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"keepLines" => {
                                f_keep_lines =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pageBreakBefore" => {
                                f_page_break_before =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"framePr" => {
                                f_frame_pr =
                                    Some(Box::new(CTFramePr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"widowControl" => {
                                f_widow_control =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numPr" => {
                                f_num_pr = Some(Box::new(CTNumPr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"suppressLineNumbers" => {
                                f_suppress_line_numbers =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pBdr" => {
                                f_paragraph_border =
                                    Some(Box::new(CTPBdr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tabs" => {
                                f_tabs = Some(Box::new(CTTabs::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"suppressAutoHyphens" => {
                                f_suppress_auto_hyphens =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"kinsoku" => {
                                f_kinsoku = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"wordWrap" => {
                                f_word_wrap = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"overflowPunct" => {
                                f_overflow_punct =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"topLinePunct" => {
                                f_top_line_punct =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"autoSpaceDE" => {
                                f_auto_space_d_e =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"autoSpaceDN" => {
                                f_auto_space_d_n =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bidi" => {
                                f_bidi = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"adjustRightInd" => {
                                f_adjust_right_ind =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"snapToGrid" => {
                                f_snap_to_grid =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"spacing" => {
                                f_spacing = Some(Box::new(CTSpacing::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"ind" => {
                                f_indentation = Some(Box::new(CTInd::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"contextualSpacing" => {
                                f_contextual_spacing =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"mirrorIndents" => {
                                f_mirror_indents =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"suppressOverlap" => {
                                f_suppress_overlap =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"jc" => {
                                f_justification =
                                    Some(Box::new(CTJc::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"textDirection" => {
                                f_text_direction =
                                    Some(Box::new(CTTextDirection::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"textAlignment" => {
                                f_text_alignment =
                                    Some(Box::new(CTTextAlignment::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"textboxTightWrap" => {
                                f_textbox_tight_wrap = Some(Box::new(
                                    CTTextboxTightWrap::from_xml(reader, &e, false)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"outlineLvl" => {
                                f_outline_lvl =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"divId" => {
                                f_div_id =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cnfStyle" => {
                                f_cnf_style = Some(Box::new(CTCnf::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"pStyle" => {
                                f_paragraph_style =
                                    Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"keepNext" => {
                                f_keep_next = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"keepLines" => {
                                f_keep_lines = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pageBreakBefore" => {
                                f_page_break_before =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"framePr" => {
                                f_frame_pr = Some(Box::new(CTFramePr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"widowControl" => {
                                f_widow_control =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numPr" => {
                                f_num_pr = Some(Box::new(CTNumPr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"suppressLineNumbers" => {
                                f_suppress_line_numbers =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pBdr" => {
                                f_paragraph_border =
                                    Some(Box::new(CTPBdr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tabs" => {
                                f_tabs = Some(Box::new(CTTabs::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"suppressAutoHyphens" => {
                                f_suppress_auto_hyphens =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"kinsoku" => {
                                f_kinsoku = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"wordWrap" => {
                                f_word_wrap = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"overflowPunct" => {
                                f_overflow_punct =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"topLinePunct" => {
                                f_top_line_punct =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"autoSpaceDE" => {
                                f_auto_space_d_e =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"autoSpaceDN" => {
                                f_auto_space_d_n =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bidi" => {
                                f_bidi = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"adjustRightInd" => {
                                f_adjust_right_ind =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"snapToGrid" => {
                                f_snap_to_grid =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"spacing" => {
                                f_spacing = Some(Box::new(CTSpacing::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"ind" => {
                                f_indentation = Some(Box::new(CTInd::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"contextualSpacing" => {
                                f_contextual_spacing =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"mirrorIndents" => {
                                f_mirror_indents =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"suppressOverlap" => {
                                f_suppress_overlap =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"jc" => {
                                f_justification = Some(Box::new(CTJc::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"textDirection" => {
                                f_text_direction =
                                    Some(Box::new(CTTextDirection::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"textAlignment" => {
                                f_text_alignment =
                                    Some(Box::new(CTTextAlignment::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"textboxTightWrap" => {
                                f_textbox_tight_wrap =
                                    Some(Box::new(CTTextboxTightWrap::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"outlineLvl" => {
                                f_outline_lvl =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"divId" => {
                                f_div_id =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cnfStyle" => {
                                f_cnf_style = Some(Box::new(CTCnf::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            paragraph_style: f_paragraph_style,
            keep_next: f_keep_next,
            keep_lines: f_keep_lines,
            page_break_before: f_page_break_before,
            frame_pr: f_frame_pr,
            widow_control: f_widow_control,
            num_pr: f_num_pr,
            suppress_line_numbers: f_suppress_line_numbers,
            paragraph_border: f_paragraph_border,
            shading: f_shading,
            tabs: f_tabs,
            suppress_auto_hyphens: f_suppress_auto_hyphens,
            kinsoku: f_kinsoku,
            word_wrap: f_word_wrap,
            overflow_punct: f_overflow_punct,
            top_line_punct: f_top_line_punct,
            auto_space_d_e: f_auto_space_d_e,
            auto_space_d_n: f_auto_space_d_n,
            bidi: f_bidi,
            adjust_right_ind: f_adjust_right_ind,
            snap_to_grid: f_snap_to_grid,
            spacing: f_spacing,
            indentation: f_indentation,
            contextual_spacing: f_contextual_spacing,
            mirror_indents: f_mirror_indents,
            suppress_overlap: f_suppress_overlap,
            justification: f_justification,
            text_direction: f_text_direction,
            text_alignment: f_text_alignment,
            textbox_tight_wrap: f_textbox_tight_wrap,
            outline_lvl: f_outline_lvl,
            div_id: f_div_id,
            cnf_style: f_cnf_style,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTPPrGeneral {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_paragraph_style = None;
        let mut f_keep_next = None;
        let mut f_keep_lines = None;
        let mut f_page_break_before = None;
        let mut f_frame_pr = None;
        let mut f_widow_control = None;
        let mut f_num_pr = None;
        let mut f_suppress_line_numbers = None;
        let mut f_paragraph_border = None;
        let mut f_shading = None;
        let mut f_tabs = None;
        let mut f_suppress_auto_hyphens = None;
        let mut f_kinsoku = None;
        let mut f_word_wrap = None;
        let mut f_overflow_punct = None;
        let mut f_top_line_punct = None;
        let mut f_auto_space_d_e = None;
        let mut f_auto_space_d_n = None;
        let mut f_bidi = None;
        let mut f_adjust_right_ind = None;
        let mut f_snap_to_grid = None;
        let mut f_spacing = None;
        let mut f_indentation = None;
        let mut f_contextual_spacing = None;
        let mut f_mirror_indents = None;
        let mut f_suppress_overlap = None;
        let mut f_justification = None;
        let mut f_text_direction = None;
        let mut f_text_alignment = None;
        let mut f_textbox_tight_wrap = None;
        let mut f_outline_lvl = None;
        let mut f_div_id = None;
        let mut f_cnf_style = None;
        let mut f_p_pr_change = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"pStyle" => {
                                f_paragraph_style =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"keepNext" => {
                                f_keep_next = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"keepLines" => {
                                f_keep_lines =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pageBreakBefore" => {
                                f_page_break_before =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"framePr" => {
                                f_frame_pr =
                                    Some(Box::new(CTFramePr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"widowControl" => {
                                f_widow_control =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numPr" => {
                                f_num_pr = Some(Box::new(CTNumPr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"suppressLineNumbers" => {
                                f_suppress_line_numbers =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pBdr" => {
                                f_paragraph_border =
                                    Some(Box::new(CTPBdr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tabs" => {
                                f_tabs = Some(Box::new(CTTabs::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"suppressAutoHyphens" => {
                                f_suppress_auto_hyphens =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"kinsoku" => {
                                f_kinsoku = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"wordWrap" => {
                                f_word_wrap = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"overflowPunct" => {
                                f_overflow_punct =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"topLinePunct" => {
                                f_top_line_punct =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"autoSpaceDE" => {
                                f_auto_space_d_e =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"autoSpaceDN" => {
                                f_auto_space_d_n =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bidi" => {
                                f_bidi = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"adjustRightInd" => {
                                f_adjust_right_ind =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"snapToGrid" => {
                                f_snap_to_grid =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"spacing" => {
                                f_spacing = Some(Box::new(CTSpacing::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"ind" => {
                                f_indentation = Some(Box::new(CTInd::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"contextualSpacing" => {
                                f_contextual_spacing =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"mirrorIndents" => {
                                f_mirror_indents =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"suppressOverlap" => {
                                f_suppress_overlap =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"jc" => {
                                f_justification =
                                    Some(Box::new(CTJc::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"textDirection" => {
                                f_text_direction =
                                    Some(Box::new(CTTextDirection::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"textAlignment" => {
                                f_text_alignment =
                                    Some(Box::new(CTTextAlignment::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"textboxTightWrap" => {
                                f_textbox_tight_wrap = Some(Box::new(
                                    CTTextboxTightWrap::from_xml(reader, &e, false)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"outlineLvl" => {
                                f_outline_lvl =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"divId" => {
                                f_div_id =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cnfStyle" => {
                                f_cnf_style = Some(Box::new(CTCnf::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pPrChange" => {
                                f_p_pr_change =
                                    Some(Box::new(CTPPrChange::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"pStyle" => {
                                f_paragraph_style =
                                    Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"keepNext" => {
                                f_keep_next = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"keepLines" => {
                                f_keep_lines = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pageBreakBefore" => {
                                f_page_break_before =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"framePr" => {
                                f_frame_pr = Some(Box::new(CTFramePr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"widowControl" => {
                                f_widow_control =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numPr" => {
                                f_num_pr = Some(Box::new(CTNumPr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"suppressLineNumbers" => {
                                f_suppress_line_numbers =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pBdr" => {
                                f_paragraph_border =
                                    Some(Box::new(CTPBdr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tabs" => {
                                f_tabs = Some(Box::new(CTTabs::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"suppressAutoHyphens" => {
                                f_suppress_auto_hyphens =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"kinsoku" => {
                                f_kinsoku = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"wordWrap" => {
                                f_word_wrap = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"overflowPunct" => {
                                f_overflow_punct =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"topLinePunct" => {
                                f_top_line_punct =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"autoSpaceDE" => {
                                f_auto_space_d_e =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"autoSpaceDN" => {
                                f_auto_space_d_n =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bidi" => {
                                f_bidi = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"adjustRightInd" => {
                                f_adjust_right_ind =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"snapToGrid" => {
                                f_snap_to_grid =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"spacing" => {
                                f_spacing = Some(Box::new(CTSpacing::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"ind" => {
                                f_indentation = Some(Box::new(CTInd::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"contextualSpacing" => {
                                f_contextual_spacing =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"mirrorIndents" => {
                                f_mirror_indents =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"suppressOverlap" => {
                                f_suppress_overlap =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"jc" => {
                                f_justification = Some(Box::new(CTJc::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"textDirection" => {
                                f_text_direction =
                                    Some(Box::new(CTTextDirection::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"textAlignment" => {
                                f_text_alignment =
                                    Some(Box::new(CTTextAlignment::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"textboxTightWrap" => {
                                f_textbox_tight_wrap =
                                    Some(Box::new(CTTextboxTightWrap::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"outlineLvl" => {
                                f_outline_lvl =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"divId" => {
                                f_div_id =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cnfStyle" => {
                                f_cnf_style = Some(Box::new(CTCnf::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pPrChange" => {
                                f_p_pr_change =
                                    Some(Box::new(CTPPrChange::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            paragraph_style: f_paragraph_style,
            keep_next: f_keep_next,
            keep_lines: f_keep_lines,
            page_break_before: f_page_break_before,
            frame_pr: f_frame_pr,
            widow_control: f_widow_control,
            num_pr: f_num_pr,
            suppress_line_numbers: f_suppress_line_numbers,
            paragraph_border: f_paragraph_border,
            shading: f_shading,
            tabs: f_tabs,
            suppress_auto_hyphens: f_suppress_auto_hyphens,
            kinsoku: f_kinsoku,
            word_wrap: f_word_wrap,
            overflow_punct: f_overflow_punct,
            top_line_punct: f_top_line_punct,
            auto_space_d_e: f_auto_space_d_e,
            auto_space_d_n: f_auto_space_d_n,
            bidi: f_bidi,
            adjust_right_ind: f_adjust_right_ind,
            snap_to_grid: f_snap_to_grid,
            spacing: f_spacing,
            indentation: f_indentation,
            contextual_spacing: f_contextual_spacing,
            mirror_indents: f_mirror_indents,
            suppress_overlap: f_suppress_overlap,
            justification: f_justification,
            text_direction: f_text_direction,
            text_alignment: f_text_alignment,
            textbox_tight_wrap: f_textbox_tight_wrap,
            outline_lvl: f_outline_lvl,
            div_id: f_div_id,
            cnf_style: f_cnf_style,
            p_pr_change: f_p_pr_change,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTControl {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name = None;
        let mut f_shapeid = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"shapeid" => {
                    f_shapeid = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name,
            shapeid: f_shapeid,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTBackground {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_color = None;
        let mut f_theme_color = None;
        let mut f_theme_tint = None;
        let mut f_theme_shade = None;
        let mut f_drawing = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"color" => {
                    f_color = Some(val.into_owned());
                }
                b"themeColor" => {
                    f_theme_color = val.parse().ok();
                }
                b"themeTint" => {
                    f_theme_tint = decode_hex(&val);
                }
                b"themeShade" => {
                    f_theme_shade = decode_hex(&val);
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"drawing" => {
                                f_drawing = Some(Box::new(CTDrawing::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"drawing" => {
                                f_drawing = Some(Box::new(CTDrawing::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            color: f_color,
            theme_color: f_theme_color,
            theme_tint: f_theme_tint,
            theme_shade: f_theme_shade,
            drawing: f_drawing,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTRel {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    #[cfg(feature = "extra-children")]
                    Event::Start(e) => {
                        let elem = RawXmlElement::from_reader(reader, &e)?;
                        extra_children
                            .push(PositionedNode::new(child_idx, RawXmlNode::Element(elem)));
                        child_idx += 1;
                    }
                    #[cfg(not(feature = "extra-children"))]
                    Event::Start(_) => {
                        skip_element(reader)?;
                    }
                    #[cfg(feature = "extra-children")]
                    Event::Empty(e) => {
                        let elem = RawXmlElement::from_empty(&e);
                        extra_children
                            .push(PositionedNode::new(child_idx, RawXmlNode::Element(elem)));
                        child_idx += 1;
                    }
                    #[cfg(not(feature = "extra-children"))]
                    Event::Empty(_) => {}
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }
        Ok(Self {
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTObject {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_dxa_orig = None;
        let mut f_dya_orig = None;
        let mut f_drawing = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"dxaOrig" => {
                    f_dxa_orig = Some(val.into_owned());
                }
                b"dyaOrig" => {
                    f_dya_orig = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"drawing" => {
                                f_drawing = Some(Box::new(CTDrawing::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"drawing" => {
                                f_drawing = Some(Box::new(CTDrawing::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            dxa_orig: f_dxa_orig,
            dya_orig: f_dya_orig,
            drawing: f_drawing,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTPicture {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_movie = None;
        let mut f_control = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"movie" => {
                                f_movie = Some(Box::new(CTRel::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"control" => {
                                f_control = Some(Box::new(CTControl::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"movie" => {
                                f_movie = Some(Box::new(CTRel::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"control" => {
                                f_control = Some(Box::new(CTControl::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            movie: f_movie,
            control: f_control,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTObjectEmbed {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_draw_aspect = None;
        let mut f_prog_id = None;
        let mut f_shape_id = None;
        let mut f_field_codes = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"drawAspect" => {
                    f_draw_aspect = val.parse().ok();
                }
                b"progId" => {
                    f_prog_id = Some(val.into_owned());
                }
                b"shapeId" => {
                    f_shape_id = Some(val.into_owned());
                }
                b"fieldCodes" => {
                    f_field_codes = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            draw_aspect: f_draw_aspect,
            prog_id: f_prog_id,
            shape_id: f_shape_id,
            field_codes: f_field_codes,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTObjectLink {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_draw_aspect = None;
        let mut f_prog_id = None;
        let mut f_shape_id = None;
        let mut f_field_codes = None;
        let mut f_update_mode: Option<STObjectUpdateMode> = None;
        let mut f_locked_field = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"drawAspect" => {
                    f_draw_aspect = val.parse().ok();
                }
                b"progId" => {
                    f_prog_id = Some(val.into_owned());
                }
                b"shapeId" => {
                    f_shape_id = Some(val.into_owned());
                }
                b"fieldCodes" => {
                    f_field_codes = Some(val.into_owned());
                }
                b"updateMode" => {
                    f_update_mode = val.parse().ok();
                }
                b"lockedField" => {
                    f_locked_field = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            draw_aspect: f_draw_aspect,
            prog_id: f_prog_id,
            shape_id: f_shape_id,
            field_codes: f_field_codes,
            update_mode: f_update_mode
                .ok_or_else(|| ParseError::MissingAttribute("updateMode".to_string()))?,
            locked_field: f_locked_field,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTDrawing {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    #[cfg(feature = "extra-children")]
                    Event::Start(e) => {
                        let elem = RawXmlElement::from_reader(reader, &e)?;
                        extra_children
                            .push(PositionedNode::new(child_idx, RawXmlNode::Element(elem)));
                        child_idx += 1;
                    }
                    #[cfg(not(feature = "extra-children"))]
                    Event::Start(_) => {
                        skip_element(reader)?;
                    }
                    #[cfg(feature = "extra-children")]
                    Event::Empty(e) => {
                        let elem = RawXmlElement::from_empty(&e);
                        extra_children
                            .push(PositionedNode::new(child_idx, RawXmlNode::Element(elem)));
                        child_idx += 1;
                    }
                    #[cfg(not(feature = "extra-children"))]
                    Event::Empty(_) => {}
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }
        Ok(Self {
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTSimpleField {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_instr: Option<STString> = None;
        let mut f_fld_lock = None;
        let mut f_dirty = None;
        let mut f_fld_data = None;
        let mut f_paragraph_content = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"instr" => {
                    f_instr = Some(val.into_owned());
                }
                b"fldLock" => {
                    f_fld_lock = Some(val.into_owned());
                }
                b"dirty" => {
                    f_dirty = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"fldData" => {
                                f_fld_data = Some(Box::new(Text::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"customXml"
                            | b"smartTag"
                            | b"sdt"
                            | b"dir"
                            | b"bdo"
                            | b"r"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo"
                            | b"fldSimple"
                            | b"hyperlink"
                            | b"subDoc" => {
                                f_paragraph_content
                                    .push(Box::new(ParagraphContent::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"fldData" => {
                                f_fld_data = Some(Box::new(Text::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"customXml"
                            | b"smartTag"
                            | b"sdt"
                            | b"dir"
                            | b"bdo"
                            | b"r"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo"
                            | b"fldSimple"
                            | b"hyperlink"
                            | b"subDoc" => {
                                f_paragraph_content
                                    .push(Box::new(ParagraphContent::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            instr: f_instr.ok_or_else(|| ParseError::MissingAttribute("instr".to_string()))?,
            fld_lock: f_fld_lock,
            dirty: f_dirty,
            fld_data: f_fld_data,
            paragraph_content: f_paragraph_content,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTFFTextType {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STFFTextType> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTFFName {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTFldChar {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_fld_char_type: Option<STFldCharType> = None;
        let mut f_fld_lock = None;
        let mut f_dirty = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"fldCharType" => {
                    f_fld_char_type = val.parse().ok();
                }
                b"fldLock" => {
                    f_fld_lock = Some(val.into_owned());
                }
                b"dirty" => {
                    f_dirty = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            fld_char_type: f_fld_char_type
                .ok_or_else(|| ParseError::MissingAttribute("fldCharType".to_string()))?,
            fld_lock: f_fld_lock,
            dirty: f_dirty,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for Hyperlink {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_tgt_frame = None;
        let mut f_tooltip = None;
        let mut f_doc_location = None;
        let mut f_history = None;
        let mut f_anchor = None;
        let mut f_paragraph_content = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"tgtFrame" => {
                    f_tgt_frame = Some(val.into_owned());
                }
                b"tooltip" => {
                    f_tooltip = Some(val.into_owned());
                }
                b"docLocation" => {
                    f_doc_location = Some(val.into_owned());
                }
                b"history" => {
                    f_history = Some(val.into_owned());
                }
                b"anchor" => {
                    f_anchor = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"customXml"
                            | b"smartTag"
                            | b"sdt"
                            | b"dir"
                            | b"bdo"
                            | b"r"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo"
                            | b"fldSimple"
                            | b"hyperlink"
                            | b"subDoc" => {
                                f_paragraph_content
                                    .push(Box::new(ParagraphContent::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"customXml"
                            | b"smartTag"
                            | b"sdt"
                            | b"dir"
                            | b"bdo"
                            | b"r"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo"
                            | b"fldSimple"
                            | b"hyperlink"
                            | b"subDoc" => {
                                f_paragraph_content
                                    .push(Box::new(ParagraphContent::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            tgt_frame: f_tgt_frame,
            tooltip: f_tooltip,
            doc_location: f_doc_location,
            history: f_history,
            anchor: f_anchor,
            paragraph_content: f_paragraph_content,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTFFData {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    #[cfg(feature = "extra-children")]
                    Event::Start(e) => {
                        let elem = RawXmlElement::from_reader(reader, &e)?;
                        extra_children
                            .push(PositionedNode::new(child_idx, RawXmlNode::Element(elem)));
                        child_idx += 1;
                    }
                    #[cfg(not(feature = "extra-children"))]
                    Event::Start(_) => {
                        skip_element(reader)?;
                    }
                    #[cfg(feature = "extra-children")]
                    Event::Empty(e) => {
                        let elem = RawXmlElement::from_empty(&e);
                        extra_children
                            .push(PositionedNode::new(child_idx, RawXmlNode::Element(elem)));
                        child_idx += 1;
                    }
                    #[cfg(not(feature = "extra-children"))]
                    Event::Empty(_) => {}
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }
        Ok(Self {
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTFFHelpText {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_type = None;
        let mut f_value = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"type" => {
                    f_type = val.parse().ok();
                }
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r#type: f_type,
            value: f_value,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTFFStatusText {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_type = None;
        let mut f_value = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"type" => {
                    f_type = val.parse().ok();
                }
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r#type: f_type,
            value: f_value,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTFFCheckBox {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_default = None;
        let mut f_checked = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"default" => {
                                f_default = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"checked" => {
                                f_checked = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"default" => {
                                f_default = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"checked" => {
                                f_checked = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            default: f_default,
            checked: f_checked,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTFFDDList {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_result = None;
        let mut f_default = None;
        let mut f_list_entry = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"result" => {
                                f_result =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"default" => {
                                f_default =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"listEntry" => {
                                f_list_entry.push(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"result" => {
                                f_result =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"default" => {
                                f_default =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"listEntry" => {
                                f_list_entry.push(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            result: f_result,
            default: f_default,
            list_entry: f_list_entry,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTFFTextInput {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_type = None;
        let mut f_default = None;
        let mut f_max_length = None;
        let mut f_format = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"type" => {
                                f_type = Some(Box::new(CTFFTextType::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"default" => {
                                f_default = Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"maxLength" => {
                                f_max_length =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"format" => {
                                f_format = Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"type" => {
                                f_type = Some(Box::new(CTFFTextType::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"default" => {
                                f_default = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"maxLength" => {
                                f_max_length =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"format" => {
                                f_format = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r#type: f_type,
            default: f_default,
            max_length: f_max_length,
            format: f_format,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTSectType {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTPaperSource {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_first = None;
        let mut f_other = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"first" => {
                    f_first = val.parse().ok();
                }
                b"other" => {
                    f_other = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            first: f_first,
            other: f_other,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for PageSize {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_width = None;
        let mut f_height = None;
        let mut f_orient = None;
        let mut f_code = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"w" => {
                    f_width = Some(val.into_owned());
                }
                b"h" => {
                    f_height = Some(val.into_owned());
                }
                b"orient" => {
                    f_orient = val.parse().ok();
                }
                b"code" => {
                    f_code = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            width: f_width,
            height: f_height,
            orient: f_orient,
            code: f_code,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for PageMargins {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_top: Option<STSignedTwipsMeasure> = None;
        let mut f_right: Option<STTwipsMeasure> = None;
        let mut f_bottom: Option<STSignedTwipsMeasure> = None;
        let mut f_left: Option<STTwipsMeasure> = None;
        let mut f_header: Option<STTwipsMeasure> = None;
        let mut f_footer: Option<STTwipsMeasure> = None;
        let mut f_gutter: Option<STTwipsMeasure> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"top" => {
                    f_top = Some(val.into_owned());
                }
                b"right" => {
                    f_right = Some(val.into_owned());
                }
                b"bottom" => {
                    f_bottom = Some(val.into_owned());
                }
                b"left" => {
                    f_left = Some(val.into_owned());
                }
                b"header" => {
                    f_header = Some(val.into_owned());
                }
                b"footer" => {
                    f_footer = Some(val.into_owned());
                }
                b"gutter" => {
                    f_gutter = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            top: f_top.ok_or_else(|| ParseError::MissingAttribute("top".to_string()))?,
            right: f_right.ok_or_else(|| ParseError::MissingAttribute("right".to_string()))?,
            bottom: f_bottom.ok_or_else(|| ParseError::MissingAttribute("bottom".to_string()))?,
            left: f_left.ok_or_else(|| ParseError::MissingAttribute("left".to_string()))?,
            header: f_header.ok_or_else(|| ParseError::MissingAttribute("header".to_string()))?,
            footer: f_footer.ok_or_else(|| ParseError::MissingAttribute("footer".to_string()))?,
            gutter: f_gutter.ok_or_else(|| ParseError::MissingAttribute("gutter".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTPageBorders {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_z_order = None;
        let mut f_display = None;
        let mut f_offset_from = None;
        let mut f_top = None;
        let mut f_left = None;
        let mut f_bottom = None;
        let mut f_right = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"zOrder" => {
                    f_z_order = val.parse().ok();
                }
                b"display" => {
                    f_display = val.parse().ok();
                }
                b"offsetFrom" => {
                    f_offset_from = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"top" => {
                                f_top =
                                    Some(Box::new(CTTopPageBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"left" => {
                                f_left = Some(Box::new(CTPageBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bottom" => {
                                f_bottom = Some(Box::new(CTBottomPageBorder::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"right" => {
                                f_right =
                                    Some(Box::new(CTPageBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"top" => {
                                f_top =
                                    Some(Box::new(CTTopPageBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"left" => {
                                f_left = Some(Box::new(CTPageBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bottom" => {
                                f_bottom =
                                    Some(Box::new(CTBottomPageBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"right" => {
                                f_right = Some(Box::new(CTPageBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            z_order: f_z_order,
            display: f_display,
            offset_from: f_offset_from,
            top: f_top,
            left: f_left,
            bottom: f_bottom,
            right: f_right,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTPageBorder {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STBorder> = None;
        let mut f_color = None;
        let mut f_theme_color = None;
        let mut f_theme_tint = None;
        let mut f_theme_shade = None;
        let mut f_size = None;
        let mut f_space = None;
        let mut f_shadow = None;
        let mut f_frame = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                b"color" => {
                    f_color = Some(val.into_owned());
                }
                b"themeColor" => {
                    f_theme_color = val.parse().ok();
                }
                b"themeTint" => {
                    f_theme_tint = decode_hex(&val);
                }
                b"themeShade" => {
                    f_theme_shade = decode_hex(&val);
                }
                b"sz" => {
                    f_size = val.parse().ok();
                }
                b"space" => {
                    f_space = val.parse().ok();
                }
                b"shadow" => {
                    f_shadow = Some(val.into_owned());
                }
                b"frame" => {
                    f_frame = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            color: f_color,
            theme_color: f_theme_color,
            theme_tint: f_theme_tint,
            theme_shade: f_theme_shade,
            size: f_size,
            space: f_space,
            shadow: f_shadow,
            frame: f_frame,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTBottomPageBorder {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STBorder> = None;
        let mut f_color = None;
        let mut f_theme_color = None;
        let mut f_theme_tint = None;
        let mut f_theme_shade = None;
        let mut f_size = None;
        let mut f_space = None;
        let mut f_shadow = None;
        let mut f_frame = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                b"color" => {
                    f_color = Some(val.into_owned());
                }
                b"themeColor" => {
                    f_theme_color = val.parse().ok();
                }
                b"themeTint" => {
                    f_theme_tint = decode_hex(&val);
                }
                b"themeShade" => {
                    f_theme_shade = decode_hex(&val);
                }
                b"sz" => {
                    f_size = val.parse().ok();
                }
                b"space" => {
                    f_space = val.parse().ok();
                }
                b"shadow" => {
                    f_shadow = Some(val.into_owned());
                }
                b"frame" => {
                    f_frame = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            color: f_color,
            theme_color: f_theme_color,
            theme_tint: f_theme_tint,
            theme_shade: f_theme_shade,
            size: f_size,
            space: f_space,
            shadow: f_shadow,
            frame: f_frame,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTTopPageBorder {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STBorder> = None;
        let mut f_color = None;
        let mut f_theme_color = None;
        let mut f_theme_tint = None;
        let mut f_theme_shade = None;
        let mut f_size = None;
        let mut f_space = None;
        let mut f_shadow = None;
        let mut f_frame = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                b"color" => {
                    f_color = Some(val.into_owned());
                }
                b"themeColor" => {
                    f_theme_color = val.parse().ok();
                }
                b"themeTint" => {
                    f_theme_tint = decode_hex(&val);
                }
                b"themeShade" => {
                    f_theme_shade = decode_hex(&val);
                }
                b"sz" => {
                    f_size = val.parse().ok();
                }
                b"space" => {
                    f_space = val.parse().ok();
                }
                b"shadow" => {
                    f_shadow = Some(val.into_owned());
                }
                b"frame" => {
                    f_frame = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            color: f_color,
            theme_color: f_theme_color,
            theme_tint: f_theme_tint,
            theme_shade: f_theme_shade,
            size: f_size,
            space: f_space,
            shadow: f_shadow,
            frame: f_frame,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTLineNumber {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count_by = None;
        let mut f_start = None;
        let mut f_distance = None;
        let mut f_restart = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"countBy" => {
                    f_count_by = val.parse().ok();
                }
                b"start" => {
                    f_start = val.parse().ok();
                }
                b"distance" => {
                    f_distance = Some(val.into_owned());
                }
                b"restart" => {
                    f_restart = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count_by: f_count_by,
            start: f_start,
            distance: f_distance,
            restart: f_restart,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTPageNumber {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_fmt = None;
        let mut f_start = None;
        let mut f_chap_style = None;
        let mut f_chap_sep = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"fmt" => {
                    f_fmt = val.parse().ok();
                }
                b"start" => {
                    f_start = val.parse().ok();
                }
                b"chapStyle" => {
                    f_chap_style = val.parse().ok();
                }
                b"chapSep" => {
                    f_chap_sep = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            fmt: f_fmt,
            start: f_start,
            chap_style: f_chap_style,
            chap_sep: f_chap_sep,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTColumn {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_width = None;
        let mut f_space = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"w" => {
                    f_width = Some(val.into_owned());
                }
                b"space" => {
                    f_space = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            width: f_width,
            space: f_space,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for Columns {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_equal_width = None;
        let mut f_space = None;
        let mut f_num = None;
        let mut f_sep = None;
        let mut f_col = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"equalWidth" => {
                    f_equal_width = Some(val.into_owned());
                }
                b"space" => {
                    f_space = Some(val.into_owned());
                }
                b"num" => {
                    f_num = val.parse().ok();
                }
                b"sep" => {
                    f_sep = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"col" => {
                                f_col.push(Box::new(CTColumn::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"col" => {
                                f_col.push(Box::new(CTColumn::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            equal_width: f_equal_width,
            space: f_space,
            num: f_num,
            sep: f_sep,
            col: f_col,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTVerticalJc {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STVerticalJc> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for DocumentGrid {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_type = None;
        let mut f_line_pitch = None;
        let mut f_char_space = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"type" => {
                    f_type = val.parse().ok();
                }
                b"linePitch" => {
                    f_line_pitch = val.parse().ok();
                }
                b"charSpace" => {
                    f_char_space = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r#type: f_type,
            line_pitch: f_line_pitch,
            char_space: f_char_space,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for HeaderFooterReference {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_type: Option<STHdrFtr> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"type" => {
                    f_type = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r#type: f_type.ok_or_else(|| ParseError::MissingAttribute("type".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for HeaderFooterRef {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let tag = start_tag.local_name();
        match tag.as_ref() {
            b"headerReference" => {
                let inner = HeaderFooterReference::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::HeaderReference(Box::new(inner)))
            }
            b"footerReference" => {
                let inner = HeaderFooterReference::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::FooterReference(Box::new(inner)))
            }
            _ => Err(ParseError::UnexpectedElement(
                String::from_utf8_lossy(start_tag.name().as_ref()).into_owned(),
            )),
        }
    }
}

impl FromXml for HeaderFooter {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_block_content = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"customXml"
                            | b"sdt"
                            | b"p"
                            | b"tbl"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo"
                            | b"altChunk" => {
                                f_block_content
                                    .push(Box::new(BlockContent::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"customXml"
                            | b"sdt"
                            | b"p"
                            | b"tbl"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo"
                            | b"altChunk" => {
                                f_block_content
                                    .push(Box::new(BlockContent::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            block_content: f_block_content,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for EGSectPrContents {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_footnote_pr = None;
        let mut f_endnote_pr = None;
        let mut f_type = None;
        let mut f_pg_sz = None;
        let mut f_pg_mar = None;
        let mut f_paper_src = None;
        let mut f_pg_borders = None;
        let mut f_ln_num_type = None;
        let mut f_pg_num_type = None;
        let mut f_cols = None;
        let mut f_form_prot = None;
        let mut f_v_align = None;
        let mut f_no_endnote = None;
        let mut f_title_pg = None;
        let mut f_text_direction = None;
        let mut f_bidi = None;
        let mut f_rtl_gutter = None;
        let mut f_doc_grid = None;
        let mut f_printer_settings = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"footnotePr" => {
                                f_footnote_pr =
                                    Some(Box::new(CTFtnProps::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"endnotePr" => {
                                f_endnote_pr =
                                    Some(Box::new(CTEdnProps::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"type" => {
                                f_type = Some(Box::new(CTSectType::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pgSz" => {
                                f_pg_sz = Some(Box::new(PageSize::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pgMar" => {
                                f_pg_mar =
                                    Some(Box::new(PageMargins::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"paperSrc" => {
                                f_paper_src =
                                    Some(Box::new(CTPaperSource::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pgBorders" => {
                                f_pg_borders =
                                    Some(Box::new(CTPageBorders::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lnNumType" => {
                                f_ln_num_type =
                                    Some(Box::new(CTLineNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pgNumType" => {
                                f_pg_num_type =
                                    Some(Box::new(CTPageNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cols" => {
                                f_cols = Some(Box::new(Columns::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"formProt" => {
                                f_form_prot = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vAlign" => {
                                f_v_align =
                                    Some(Box::new(CTVerticalJc::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noEndnote" => {
                                f_no_endnote =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"titlePg" => {
                                f_title_pg = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"textDirection" => {
                                f_text_direction =
                                    Some(Box::new(CTTextDirection::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bidi" => {
                                f_bidi = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rtlGutter" => {
                                f_rtl_gutter =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"docGrid" => {
                                f_doc_grid =
                                    Some(Box::new(DocumentGrid::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"printerSettings" => {
                                f_printer_settings =
                                    Some(Box::new(CTRel::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"footnotePr" => {
                                f_footnote_pr =
                                    Some(Box::new(CTFtnProps::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"endnotePr" => {
                                f_endnote_pr =
                                    Some(Box::new(CTEdnProps::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"type" => {
                                f_type = Some(Box::new(CTSectType::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pgSz" => {
                                f_pg_sz = Some(Box::new(PageSize::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pgMar" => {
                                f_pg_mar = Some(Box::new(PageMargins::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"paperSrc" => {
                                f_paper_src =
                                    Some(Box::new(CTPaperSource::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pgBorders" => {
                                f_pg_borders =
                                    Some(Box::new(CTPageBorders::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lnNumType" => {
                                f_ln_num_type =
                                    Some(Box::new(CTLineNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pgNumType" => {
                                f_pg_num_type =
                                    Some(Box::new(CTPageNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cols" => {
                                f_cols = Some(Box::new(Columns::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"formProt" => {
                                f_form_prot = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vAlign" => {
                                f_v_align =
                                    Some(Box::new(CTVerticalJc::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noEndnote" => {
                                f_no_endnote = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"titlePg" => {
                                f_title_pg = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"textDirection" => {
                                f_text_direction =
                                    Some(Box::new(CTTextDirection::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bidi" => {
                                f_bidi = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rtlGutter" => {
                                f_rtl_gutter = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"docGrid" => {
                                f_doc_grid =
                                    Some(Box::new(DocumentGrid::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"printerSettings" => {
                                f_printer_settings =
                                    Some(Box::new(CTRel::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            footnote_pr: f_footnote_pr,
            endnote_pr: f_endnote_pr,
            r#type: f_type,
            pg_sz: f_pg_sz,
            pg_mar: f_pg_mar,
            paper_src: f_paper_src,
            pg_borders: f_pg_borders,
            ln_num_type: f_ln_num_type,
            pg_num_type: f_pg_num_type,
            cols: f_cols,
            form_prot: f_form_prot,
            v_align: f_v_align,
            no_endnote: f_no_endnote,
            title_pg: f_title_pg,
            text_direction: f_text_direction,
            bidi: f_bidi,
            rtl_gutter: f_rtl_gutter,
            doc_grid: f_doc_grid,
            printer_settings: f_printer_settings,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for WAGSectPrAttributes {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_rsid_r_pr = None;
        let mut f_rsid_del = None;
        let mut f_rsid_r = None;
        let mut f_rsid_sect = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"rsidRPr" => {
                    f_rsid_r_pr = decode_hex(&val);
                }
                b"rsidDel" => {
                    f_rsid_del = decode_hex(&val);
                }
                b"rsidR" => {
                    f_rsid_r = decode_hex(&val);
                }
                b"rsidSect" => {
                    f_rsid_sect = decode_hex(&val);
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            rsid_r_pr: f_rsid_r_pr,
            rsid_del: f_rsid_del,
            rsid_r: f_rsid_r,
            rsid_sect: f_rsid_sect,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTSectPrBase {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_rsid_r_pr = None;
        let mut f_rsid_del = None;
        let mut f_rsid_r = None;
        let mut f_rsid_sect = None;
        let mut f_footnote_pr = None;
        let mut f_endnote_pr = None;
        let mut f_type = None;
        let mut f_pg_sz = None;
        let mut f_pg_mar = None;
        let mut f_paper_src = None;
        let mut f_pg_borders = None;
        let mut f_ln_num_type = None;
        let mut f_pg_num_type = None;
        let mut f_cols = None;
        let mut f_form_prot = None;
        let mut f_v_align = None;
        let mut f_no_endnote = None;
        let mut f_title_pg = None;
        let mut f_text_direction = None;
        let mut f_bidi = None;
        let mut f_rtl_gutter = None;
        let mut f_doc_grid = None;
        let mut f_printer_settings = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"rsidRPr" => {
                    f_rsid_r_pr = decode_hex(&val);
                }
                b"rsidDel" => {
                    f_rsid_del = decode_hex(&val);
                }
                b"rsidR" => {
                    f_rsid_r = decode_hex(&val);
                }
                b"rsidSect" => {
                    f_rsid_sect = decode_hex(&val);
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"footnotePr" => {
                                f_footnote_pr =
                                    Some(Box::new(CTFtnProps::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"endnotePr" => {
                                f_endnote_pr =
                                    Some(Box::new(CTEdnProps::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"type" => {
                                f_type = Some(Box::new(CTSectType::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pgSz" => {
                                f_pg_sz = Some(Box::new(PageSize::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pgMar" => {
                                f_pg_mar =
                                    Some(Box::new(PageMargins::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"paperSrc" => {
                                f_paper_src =
                                    Some(Box::new(CTPaperSource::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pgBorders" => {
                                f_pg_borders =
                                    Some(Box::new(CTPageBorders::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lnNumType" => {
                                f_ln_num_type =
                                    Some(Box::new(CTLineNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pgNumType" => {
                                f_pg_num_type =
                                    Some(Box::new(CTPageNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cols" => {
                                f_cols = Some(Box::new(Columns::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"formProt" => {
                                f_form_prot = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vAlign" => {
                                f_v_align =
                                    Some(Box::new(CTVerticalJc::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noEndnote" => {
                                f_no_endnote =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"titlePg" => {
                                f_title_pg = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"textDirection" => {
                                f_text_direction =
                                    Some(Box::new(CTTextDirection::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bidi" => {
                                f_bidi = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rtlGutter" => {
                                f_rtl_gutter =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"docGrid" => {
                                f_doc_grid =
                                    Some(Box::new(DocumentGrid::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"printerSettings" => {
                                f_printer_settings =
                                    Some(Box::new(CTRel::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"footnotePr" => {
                                f_footnote_pr =
                                    Some(Box::new(CTFtnProps::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"endnotePr" => {
                                f_endnote_pr =
                                    Some(Box::new(CTEdnProps::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"type" => {
                                f_type = Some(Box::new(CTSectType::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pgSz" => {
                                f_pg_sz = Some(Box::new(PageSize::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pgMar" => {
                                f_pg_mar = Some(Box::new(PageMargins::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"paperSrc" => {
                                f_paper_src =
                                    Some(Box::new(CTPaperSource::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pgBorders" => {
                                f_pg_borders =
                                    Some(Box::new(CTPageBorders::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lnNumType" => {
                                f_ln_num_type =
                                    Some(Box::new(CTLineNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pgNumType" => {
                                f_pg_num_type =
                                    Some(Box::new(CTPageNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cols" => {
                                f_cols = Some(Box::new(Columns::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"formProt" => {
                                f_form_prot = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vAlign" => {
                                f_v_align =
                                    Some(Box::new(CTVerticalJc::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noEndnote" => {
                                f_no_endnote = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"titlePg" => {
                                f_title_pg = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"textDirection" => {
                                f_text_direction =
                                    Some(Box::new(CTTextDirection::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bidi" => {
                                f_bidi = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rtlGutter" => {
                                f_rtl_gutter = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"docGrid" => {
                                f_doc_grid =
                                    Some(Box::new(DocumentGrid::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"printerSettings" => {
                                f_printer_settings =
                                    Some(Box::new(CTRel::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            rsid_r_pr: f_rsid_r_pr,
            rsid_del: f_rsid_del,
            rsid_r: f_rsid_r,
            rsid_sect: f_rsid_sect,
            footnote_pr: f_footnote_pr,
            endnote_pr: f_endnote_pr,
            r#type: f_type,
            pg_sz: f_pg_sz,
            pg_mar: f_pg_mar,
            paper_src: f_paper_src,
            pg_borders: f_pg_borders,
            ln_num_type: f_ln_num_type,
            pg_num_type: f_pg_num_type,
            cols: f_cols,
            form_prot: f_form_prot,
            v_align: f_v_align,
            no_endnote: f_no_endnote,
            title_pg: f_title_pg,
            text_direction: f_text_direction,
            bidi: f_bidi,
            rtl_gutter: f_rtl_gutter,
            doc_grid: f_doc_grid,
            printer_settings: f_printer_settings,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for SectionProperties {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_rsid_r_pr = None;
        let mut f_rsid_del = None;
        let mut f_rsid_r = None;
        let mut f_rsid_sect = None;
        let mut f_header_footer_refs = Vec::new();
        #[cfg(feature = "wml-comments")]
        let mut f_footnote_pr = None;
        #[cfg(feature = "wml-comments")]
        let mut f_endnote_pr = None;
        #[cfg(feature = "wml-layout")]
        let mut f_type = None;
        #[cfg(feature = "wml-layout")]
        let mut f_pg_sz = None;
        #[cfg(feature = "wml-layout")]
        let mut f_pg_mar = None;
        #[cfg(feature = "wml-layout")]
        let mut f_paper_src = None;
        #[cfg(feature = "wml-layout")]
        let mut f_pg_borders = None;
        #[cfg(feature = "wml-layout")]
        let mut f_ln_num_type = None;
        #[cfg(feature = "wml-layout")]
        let mut f_pg_num_type = None;
        #[cfg(feature = "wml-layout")]
        let mut f_cols = None;
        #[cfg(feature = "wml-layout")]
        let mut f_form_prot = None;
        #[cfg(feature = "wml-layout")]
        let mut f_v_align = None;
        #[cfg(feature = "wml-comments")]
        let mut f_no_endnote = None;
        #[cfg(feature = "wml-layout")]
        let mut f_title_pg = None;
        #[cfg(feature = "wml-layout")]
        let mut f_text_direction = None;
        #[cfg(feature = "wml-layout")]
        let mut f_bidi = None;
        #[cfg(feature = "wml-layout")]
        let mut f_rtl_gutter = None;
        #[cfg(feature = "wml-layout")]
        let mut f_doc_grid = None;
        #[cfg(feature = "wml-layout")]
        let mut f_printer_settings = None;
        #[cfg(feature = "wml-track-changes")]
        let mut f_sect_pr_change = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"rsidRPr" => {
                    f_rsid_r_pr = decode_hex(&val);
                }
                b"rsidDel" => {
                    f_rsid_del = decode_hex(&val);
                }
                b"rsidR" => {
                    f_rsid_r = decode_hex(&val);
                }
                b"rsidSect" => {
                    f_rsid_sect = decode_hex(&val);
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"headerReference" | b"footerReference" => {
                                f_header_footer_refs
                                    .push(Box::new(HeaderFooterRef::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-comments")]
                            b"footnotePr" => {
                                f_footnote_pr =
                                    Some(Box::new(CTFtnProps::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-comments")]
                            b"endnotePr" => {
                                f_endnote_pr =
                                    Some(Box::new(CTEdnProps::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"type" => {
                                f_type = Some(Box::new(CTSectType::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"pgSz" => {
                                f_pg_sz = Some(Box::new(PageSize::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"pgMar" => {
                                f_pg_mar =
                                    Some(Box::new(PageMargins::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"paperSrc" => {
                                f_paper_src =
                                    Some(Box::new(CTPaperSource::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"pgBorders" => {
                                f_pg_borders =
                                    Some(Box::new(CTPageBorders::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"lnNumType" => {
                                f_ln_num_type =
                                    Some(Box::new(CTLineNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"pgNumType" => {
                                f_pg_num_type =
                                    Some(Box::new(CTPageNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"cols" => {
                                f_cols = Some(Box::new(Columns::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"formProt" => {
                                f_form_prot = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"vAlign" => {
                                f_v_align =
                                    Some(Box::new(CTVerticalJc::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-comments")]
                            b"noEndnote" => {
                                f_no_endnote =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"titlePg" => {
                                f_title_pg = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"textDirection" => {
                                f_text_direction =
                                    Some(Box::new(CTTextDirection::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"bidi" => {
                                f_bidi = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"rtlGutter" => {
                                f_rtl_gutter =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"docGrid" => {
                                f_doc_grid =
                                    Some(Box::new(DocumentGrid::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"printerSettings" => {
                                f_printer_settings =
                                    Some(Box::new(CTRel::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-track-changes")]
                            b"sectPrChange" => {
                                f_sect_pr_change =
                                    Some(Box::new(CTSectPrChange::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"headerReference" | b"footerReference" => {
                                f_header_footer_refs
                                    .push(Box::new(HeaderFooterRef::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-comments")]
                            b"footnotePr" => {
                                f_footnote_pr =
                                    Some(Box::new(CTFtnProps::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-comments")]
                            b"endnotePr" => {
                                f_endnote_pr =
                                    Some(Box::new(CTEdnProps::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"type" => {
                                f_type = Some(Box::new(CTSectType::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"pgSz" => {
                                f_pg_sz = Some(Box::new(PageSize::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"pgMar" => {
                                f_pg_mar = Some(Box::new(PageMargins::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"paperSrc" => {
                                f_paper_src =
                                    Some(Box::new(CTPaperSource::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"pgBorders" => {
                                f_pg_borders =
                                    Some(Box::new(CTPageBorders::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"lnNumType" => {
                                f_ln_num_type =
                                    Some(Box::new(CTLineNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"pgNumType" => {
                                f_pg_num_type =
                                    Some(Box::new(CTPageNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"cols" => {
                                f_cols = Some(Box::new(Columns::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"formProt" => {
                                f_form_prot = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"vAlign" => {
                                f_v_align =
                                    Some(Box::new(CTVerticalJc::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-comments")]
                            b"noEndnote" => {
                                f_no_endnote = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"titlePg" => {
                                f_title_pg = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"textDirection" => {
                                f_text_direction =
                                    Some(Box::new(CTTextDirection::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"bidi" => {
                                f_bidi = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"rtlGutter" => {
                                f_rtl_gutter = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"docGrid" => {
                                f_doc_grid =
                                    Some(Box::new(DocumentGrid::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"printerSettings" => {
                                f_printer_settings =
                                    Some(Box::new(CTRel::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-track-changes")]
                            b"sectPrChange" => {
                                f_sect_pr_change =
                                    Some(Box::new(CTSectPrChange::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            rsid_r_pr: f_rsid_r_pr,
            rsid_del: f_rsid_del,
            rsid_r: f_rsid_r,
            rsid_sect: f_rsid_sect,
            header_footer_refs: f_header_footer_refs,
            #[cfg(feature = "wml-comments")]
            footnote_pr: f_footnote_pr,
            #[cfg(feature = "wml-comments")]
            endnote_pr: f_endnote_pr,
            #[cfg(feature = "wml-layout")]
            r#type: f_type,
            #[cfg(feature = "wml-layout")]
            pg_sz: f_pg_sz,
            #[cfg(feature = "wml-layout")]
            pg_mar: f_pg_mar,
            #[cfg(feature = "wml-layout")]
            paper_src: f_paper_src,
            #[cfg(feature = "wml-layout")]
            pg_borders: f_pg_borders,
            #[cfg(feature = "wml-layout")]
            ln_num_type: f_ln_num_type,
            #[cfg(feature = "wml-layout")]
            pg_num_type: f_pg_num_type,
            #[cfg(feature = "wml-layout")]
            cols: f_cols,
            #[cfg(feature = "wml-layout")]
            form_prot: f_form_prot,
            #[cfg(feature = "wml-layout")]
            v_align: f_v_align,
            #[cfg(feature = "wml-comments")]
            no_endnote: f_no_endnote,
            #[cfg(feature = "wml-layout")]
            title_pg: f_title_pg,
            #[cfg(feature = "wml-layout")]
            text_direction: f_text_direction,
            #[cfg(feature = "wml-layout")]
            bidi: f_bidi,
            #[cfg(feature = "wml-layout")]
            rtl_gutter: f_rtl_gutter,
            #[cfg(feature = "wml-layout")]
            doc_grid: f_doc_grid,
            #[cfg(feature = "wml-layout")]
            printer_settings: f_printer_settings,
            #[cfg(feature = "wml-track-changes")]
            sect_pr_change: f_sect_pr_change,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTBr {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_type = None;
        let mut f_clear = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"type" => {
                    f_type = val.parse().ok();
                }
                b"clear" => {
                    f_clear = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r#type: f_type,
            clear: f_clear,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTPTab {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_alignment: Option<STPTabAlignment> = None;
        let mut f_relative_to: Option<STPTabRelativeTo> = None;
        let mut f_leader: Option<STPTabLeader> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"alignment" => {
                    f_alignment = val.parse().ok();
                }
                b"relativeTo" => {
                    f_relative_to = val.parse().ok();
                }
                b"leader" => {
                    f_leader = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            alignment: f_alignment
                .ok_or_else(|| ParseError::MissingAttribute("alignment".to_string()))?,
            relative_to: f_relative_to
                .ok_or_else(|| ParseError::MissingAttribute("relativeTo".to_string()))?,
            leader: f_leader.ok_or_else(|| ParseError::MissingAttribute("leader".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTSym {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_font = None;
        let mut f_char = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"font" => {
                    f_font = Some(val.into_owned());
                }
                b"char" => {
                    f_char = decode_hex(&val);
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            font: f_font,
            char: f_char,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTProofErr {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_type: Option<STProofErr> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"type" => {
                    f_type = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r#type: f_type.ok_or_else(|| ParseError::MissingAttribute("type".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTPerm {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STString> = None;
        let mut f_displaced_by_custom_xml = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = Some(val.into_owned());
                }
                b"displacedByCustomXml" => {
                    f_displaced_by_custom_xml = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            displaced_by_custom_xml: f_displaced_by_custom_xml,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTPermStart {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STString> = None;
        let mut f_displaced_by_custom_xml = None;
        let mut f_ed_grp = None;
        let mut f_ed = None;
        let mut f_col_first = None;
        let mut f_col_last = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = Some(val.into_owned());
                }
                b"displacedByCustomXml" => {
                    f_displaced_by_custom_xml = val.parse().ok();
                }
                b"edGrp" => {
                    f_ed_grp = val.parse().ok();
                }
                b"ed" => {
                    f_ed = Some(val.into_owned());
                }
                b"colFirst" => {
                    f_col_first = val.parse().ok();
                }
                b"colLast" => {
                    f_col_last = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            displaced_by_custom_xml: f_displaced_by_custom_xml,
            ed_grp: f_ed_grp,
            ed: f_ed,
            col_first: f_col_first,
            col_last: f_col_last,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for Text {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_text = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::Text(e) => {
                        f_text = Some(e.decode().unwrap_or_default().into_owned());
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            text: f_text,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for RunContent {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let tag = start_tag.local_name();
        match tag.as_ref() {
            b"br" => {
                let inner = CTBr::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Br(Box::new(inner)))
            }
            b"t" => {
                let inner = Text::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::T(Box::new(inner)))
            }
            b"contentPart" => {
                let inner = CTRel::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::ContentPart(Box::new(inner)))
            }
            b"delText" => {
                let inner = Text::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::DelText(Box::new(inner)))
            }
            b"instrText" => {
                let inner = Text::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::InstrText(Box::new(inner)))
            }
            b"delInstrText" => {
                let inner = Text::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::DelInstrText(Box::new(inner)))
            }
            b"noBreakHyphen" => {
                let inner = CTEmpty::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::NoBreakHyphen(Box::new(inner)))
            }
            b"softHyphen" => {
                let inner = CTEmpty::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::SoftHyphen(Box::new(inner)))
            }
            b"dayShort" => {
                let inner = CTEmpty::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::DayShort(Box::new(inner)))
            }
            b"monthShort" => {
                let inner = CTEmpty::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MonthShort(Box::new(inner)))
            }
            b"yearShort" => {
                let inner = CTEmpty::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::YearShort(Box::new(inner)))
            }
            b"dayLong" => {
                let inner = CTEmpty::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::DayLong(Box::new(inner)))
            }
            b"monthLong" => {
                let inner = CTEmpty::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MonthLong(Box::new(inner)))
            }
            b"yearLong" => {
                let inner = CTEmpty::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::YearLong(Box::new(inner)))
            }
            b"annotationRef" => {
                let inner = CTEmpty::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::AnnotationRef(Box::new(inner)))
            }
            b"footnoteRef" => {
                let inner = CTEmpty::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::FootnoteRef(Box::new(inner)))
            }
            b"endnoteRef" => {
                let inner = CTEmpty::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::EndnoteRef(Box::new(inner)))
            }
            b"separator" => {
                let inner = CTEmpty::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Separator(Box::new(inner)))
            }
            b"continuationSeparator" => {
                let inner = CTEmpty::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::ContinuationSeparator(Box::new(inner)))
            }
            b"sym" => {
                let inner = CTSym::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Sym(Box::new(inner)))
            }
            b"pgNum" => {
                let inner = CTEmpty::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::PgNum(Box::new(inner)))
            }
            b"cr" => {
                let inner = CTEmpty::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Cr(Box::new(inner)))
            }
            b"tab" => {
                let inner = CTEmpty::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Tab(Box::new(inner)))
            }
            b"object" => {
                let inner = CTObject::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Object(Box::new(inner)))
            }
            b"pict" => {
                let inner = CTPicture::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Pict(Box::new(inner)))
            }
            b"fldChar" => {
                let inner = CTFldChar::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::FldChar(Box::new(inner)))
            }
            b"ruby" => {
                let inner = CTRuby::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Ruby(Box::new(inner)))
            }
            b"footnoteReference" => {
                let inner = FootnoteEndnoteRef::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::FootnoteReference(Box::new(inner)))
            }
            b"endnoteReference" => {
                let inner = FootnoteEndnoteRef::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::EndnoteReference(Box::new(inner)))
            }
            b"commentReference" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CommentReference(Box::new(inner)))
            }
            b"drawing" => {
                let inner = CTDrawing::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Drawing(Box::new(inner)))
            }
            b"ptab" => {
                let inner = CTPTab::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Ptab(Box::new(inner)))
            }
            b"lastRenderedPageBreak" => {
                let inner = CTEmpty::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::LastRenderedPageBreak(Box::new(inner)))
            }
            _ => Err(ParseError::UnexpectedElement(
                String::from_utf8_lossy(start_tag.name().as_ref()).into_owned(),
            )),
        }
    }
}

impl FromXml for Run {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_rsid_r_pr = None;
        let mut f_rsid_del = None;
        let mut f_rsid_r = None;
        #[cfg(feature = "wml-styling")]
        let mut f_r_pr = None;
        let mut f_run_content = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"rsidRPr" => {
                    f_rsid_r_pr = decode_hex(&val);
                }
                b"rsidDel" => {
                    f_rsid_del = decode_hex(&val);
                }
                b"rsidR" => {
                    f_rsid_r = decode_hex(&val);
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "wml-styling")]
                            b"rPr" => {
                                f_r_pr =
                                    Some(Box::new(RunProperties::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"br"
                            | b"t"
                            | b"contentPart"
                            | b"delText"
                            | b"instrText"
                            | b"delInstrText"
                            | b"noBreakHyphen"
                            | b"softHyphen"
                            | b"dayShort"
                            | b"monthShort"
                            | b"yearShort"
                            | b"dayLong"
                            | b"monthLong"
                            | b"yearLong"
                            | b"annotationRef"
                            | b"footnoteRef"
                            | b"endnoteRef"
                            | b"separator"
                            | b"continuationSeparator"
                            | b"sym"
                            | b"pgNum"
                            | b"cr"
                            | b"tab"
                            | b"object"
                            | b"pict"
                            | b"fldChar"
                            | b"ruby"
                            | b"footnoteReference"
                            | b"endnoteReference"
                            | b"commentReference"
                            | b"drawing"
                            | b"ptab"
                            | b"lastRenderedPageBreak" => {
                                f_run_content
                                    .push(Box::new(RunContent::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "wml-styling")]
                            b"rPr" => {
                                f_r_pr = Some(Box::new(RunProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"br"
                            | b"t"
                            | b"contentPart"
                            | b"delText"
                            | b"instrText"
                            | b"delInstrText"
                            | b"noBreakHyphen"
                            | b"softHyphen"
                            | b"dayShort"
                            | b"monthShort"
                            | b"yearShort"
                            | b"dayLong"
                            | b"monthLong"
                            | b"yearLong"
                            | b"annotationRef"
                            | b"footnoteRef"
                            | b"endnoteRef"
                            | b"separator"
                            | b"continuationSeparator"
                            | b"sym"
                            | b"pgNum"
                            | b"cr"
                            | b"tab"
                            | b"object"
                            | b"pict"
                            | b"fldChar"
                            | b"ruby"
                            | b"footnoteReference"
                            | b"endnoteReference"
                            | b"commentReference"
                            | b"drawing"
                            | b"ptab"
                            | b"lastRenderedPageBreak" => {
                                f_run_content
                                    .push(Box::new(RunContent::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            rsid_r_pr: f_rsid_r_pr,
            rsid_del: f_rsid_del,
            rsid_r: f_rsid_r,
            #[cfg(feature = "wml-styling")]
            r_pr: f_r_pr,
            run_content: f_run_content,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Fonts {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_hint = None;
        let mut f_ascii = None;
        let mut f_h_ansi = None;
        let mut f_east_asia = None;
        let mut f_cs = None;
        let mut f_ascii_theme = None;
        let mut f_h_ansi_theme = None;
        let mut f_east_asia_theme = None;
        let mut f_cstheme = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"hint" => {
                    f_hint = val.parse().ok();
                }
                b"ascii" => {
                    f_ascii = Some(val.into_owned());
                }
                b"hAnsi" => {
                    f_h_ansi = Some(val.into_owned());
                }
                b"eastAsia" => {
                    f_east_asia = Some(val.into_owned());
                }
                b"cs" => {
                    f_cs = Some(val.into_owned());
                }
                b"asciiTheme" => {
                    f_ascii_theme = val.parse().ok();
                }
                b"hAnsiTheme" => {
                    f_h_ansi_theme = val.parse().ok();
                }
                b"eastAsiaTheme" => {
                    f_east_asia_theme = val.parse().ok();
                }
                b"cstheme" => {
                    f_cstheme = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            hint: f_hint,
            ascii: f_ascii,
            h_ansi: f_h_ansi,
            east_asia: f_east_asia,
            cs: f_cs,
            ascii_theme: f_ascii_theme,
            h_ansi_theme: f_h_ansi_theme,
            east_asia_theme: f_east_asia_theme,
            cstheme: f_cstheme,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for EGRPrBase {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_run_style = None;
        let mut f_fonts = None;
        let mut f_bold = None;
        let mut f_b_cs = None;
        let mut f_italic = None;
        let mut f_i_cs = None;
        let mut f_caps = None;
        let mut f_small_caps = None;
        let mut f_strikethrough = None;
        let mut f_dstrike = None;
        let mut f_outline = None;
        let mut f_shadow = None;
        let mut f_emboss = None;
        let mut f_imprint = None;
        let mut f_no_proof = None;
        let mut f_snap_to_grid = None;
        let mut f_vanish = None;
        let mut f_web_hidden = None;
        let mut f_color = None;
        let mut f_spacing = None;
        let mut f_width = None;
        let mut f_kern = None;
        let mut f_position = None;
        let mut f_size = None;
        let mut f_size_complex_script = None;
        let mut f_highlight = None;
        let mut f_underline = None;
        let mut f_effect = None;
        let mut f_bdr = None;
        let mut f_shading = None;
        let mut f_fit_text = None;
        let mut f_vert_align = None;
        let mut f_rtl = None;
        let mut f_cs = None;
        let mut f_em = None;
        let mut f_lang = None;
        let mut f_east_asian_layout = None;
        let mut f_spec_vanish = None;
        let mut f_o_math = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"rStyle" => {
                                f_run_style =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rFonts" => {
                                f_fonts = Some(Box::new(Fonts::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"b" => {
                                f_bold = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bCs" => {
                                f_b_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"i" => {
                                f_italic = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"iCs" => {
                                f_i_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"caps" => {
                                f_caps = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"smallCaps" => {
                                f_small_caps =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"strike" => {
                                f_strikethrough =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dstrike" => {
                                f_dstrike = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"outline" => {
                                f_outline = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shadow" => {
                                f_shadow = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"emboss" => {
                                f_emboss = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"imprint" => {
                                f_imprint = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noProof" => {
                                f_no_proof = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"snapToGrid" => {
                                f_snap_to_grid =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vanish" => {
                                f_vanish = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"webHidden" => {
                                f_web_hidden =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"color" => {
                                f_color = Some(Box::new(CTColor::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"spacing" => {
                                f_spacing = Some(Box::new(CTSignedTwipsMeasure::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"w" => {
                                f_width = Some(Box::new(CTTextScale::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"kern" => {
                                f_kern = Some(Box::new(CTHpsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"position" => {
                                f_position = Some(Box::new(CTSignedHpsMeasure::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sz" => {
                                f_size = Some(Box::new(CTHpsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"szCs" => {
                                f_size_complex_script =
                                    Some(Box::new(CTHpsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"highlight" => {
                                f_highlight =
                                    Some(Box::new(CTHighlight::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"u" => {
                                f_underline =
                                    Some(Box::new(CTUnderline::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"effect" => {
                                f_effect =
                                    Some(Box::new(CTTextEffect::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bdr" => {
                                f_bdr = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"fitText" => {
                                f_fit_text =
                                    Some(Box::new(CTFitText::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vertAlign" => {
                                f_vert_align = Some(Box::new(CTVerticalAlignRun::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rtl" => {
                                f_rtl = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cs" => {
                                f_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"em" => {
                                f_em = Some(Box::new(CTEm::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lang" => {
                                f_lang = Some(Box::new(CTLanguage::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"eastAsianLayout" => {
                                f_east_asian_layout =
                                    Some(Box::new(CTEastAsianLayout::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"specVanish" => {
                                f_spec_vanish =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"oMath" => {
                                f_o_math = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"rStyle" => {
                                f_run_style = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rFonts" => {
                                f_fonts = Some(Box::new(Fonts::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"b" => {
                                f_bold = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bCs" => {
                                f_b_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"i" => {
                                f_italic = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"iCs" => {
                                f_i_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"caps" => {
                                f_caps = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"smallCaps" => {
                                f_small_caps = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"strike" => {
                                f_strikethrough =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dstrike" => {
                                f_dstrike = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"outline" => {
                                f_outline = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shadow" => {
                                f_shadow = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"emboss" => {
                                f_emboss = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"imprint" => {
                                f_imprint = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noProof" => {
                                f_no_proof = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"snapToGrid" => {
                                f_snap_to_grid =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vanish" => {
                                f_vanish = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"webHidden" => {
                                f_web_hidden = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"color" => {
                                f_color = Some(Box::new(CTColor::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"spacing" => {
                                f_spacing = Some(Box::new(CTSignedTwipsMeasure::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"w" => {
                                f_width = Some(Box::new(CTTextScale::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"kern" => {
                                f_kern = Some(Box::new(CTHpsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"position" => {
                                f_position =
                                    Some(Box::new(CTSignedHpsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sz" => {
                                f_size = Some(Box::new(CTHpsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"szCs" => {
                                f_size_complex_script =
                                    Some(Box::new(CTHpsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"highlight" => {
                                f_highlight =
                                    Some(Box::new(CTHighlight::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"u" => {
                                f_underline =
                                    Some(Box::new(CTUnderline::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"effect" => {
                                f_effect =
                                    Some(Box::new(CTTextEffect::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bdr" => {
                                f_bdr = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"fitText" => {
                                f_fit_text = Some(Box::new(CTFitText::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vertAlign" => {
                                f_vert_align =
                                    Some(Box::new(CTVerticalAlignRun::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rtl" => {
                                f_rtl = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cs" => {
                                f_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"em" => {
                                f_em = Some(Box::new(CTEm::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lang" => {
                                f_lang = Some(Box::new(CTLanguage::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"eastAsianLayout" => {
                                f_east_asian_layout =
                                    Some(Box::new(CTEastAsianLayout::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"specVanish" => {
                                f_spec_vanish =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"oMath" => {
                                f_o_math = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            run_style: f_run_style,
            fonts: f_fonts,
            bold: f_bold,
            b_cs: f_b_cs,
            italic: f_italic,
            i_cs: f_i_cs,
            caps: f_caps,
            small_caps: f_small_caps,
            strikethrough: f_strikethrough,
            dstrike: f_dstrike,
            outline: f_outline,
            shadow: f_shadow,
            emboss: f_emboss,
            imprint: f_imprint,
            no_proof: f_no_proof,
            snap_to_grid: f_snap_to_grid,
            vanish: f_vanish,
            web_hidden: f_web_hidden,
            color: f_color,
            spacing: f_spacing,
            width: f_width,
            kern: f_kern,
            position: f_position,
            size: f_size,
            size_complex_script: f_size_complex_script,
            highlight: f_highlight,
            underline: f_underline,
            effect: f_effect,
            bdr: f_bdr,
            shading: f_shading,
            fit_text: f_fit_text,
            vert_align: f_vert_align,
            rtl: f_rtl,
            cs: f_cs,
            em: f_em,
            lang: f_lang,
            east_asian_layout: f_east_asian_layout,
            spec_vanish: f_spec_vanish,
            o_math: f_o_math,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for EGRPrContent {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_run_style = None;
        let mut f_fonts = None;
        let mut f_bold = None;
        let mut f_b_cs = None;
        let mut f_italic = None;
        let mut f_i_cs = None;
        let mut f_caps = None;
        let mut f_small_caps = None;
        let mut f_strikethrough = None;
        let mut f_dstrike = None;
        let mut f_outline = None;
        let mut f_shadow = None;
        let mut f_emboss = None;
        let mut f_imprint = None;
        let mut f_no_proof = None;
        let mut f_snap_to_grid = None;
        let mut f_vanish = None;
        let mut f_web_hidden = None;
        let mut f_color = None;
        let mut f_spacing = None;
        let mut f_width = None;
        let mut f_kern = None;
        let mut f_position = None;
        let mut f_size = None;
        let mut f_size_complex_script = None;
        let mut f_highlight = None;
        let mut f_underline = None;
        let mut f_effect = None;
        let mut f_bdr = None;
        let mut f_shading = None;
        let mut f_fit_text = None;
        let mut f_vert_align = None;
        let mut f_rtl = None;
        let mut f_cs = None;
        let mut f_em = None;
        let mut f_lang = None;
        let mut f_east_asian_layout = None;
        let mut f_spec_vanish = None;
        let mut f_o_math = None;
        let mut f_r_pr_change = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"rStyle" => {
                                f_run_style =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rFonts" => {
                                f_fonts = Some(Box::new(Fonts::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"b" => {
                                f_bold = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bCs" => {
                                f_b_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"i" => {
                                f_italic = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"iCs" => {
                                f_i_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"caps" => {
                                f_caps = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"smallCaps" => {
                                f_small_caps =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"strike" => {
                                f_strikethrough =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dstrike" => {
                                f_dstrike = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"outline" => {
                                f_outline = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shadow" => {
                                f_shadow = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"emboss" => {
                                f_emboss = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"imprint" => {
                                f_imprint = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noProof" => {
                                f_no_proof = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"snapToGrid" => {
                                f_snap_to_grid =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vanish" => {
                                f_vanish = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"webHidden" => {
                                f_web_hidden =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"color" => {
                                f_color = Some(Box::new(CTColor::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"spacing" => {
                                f_spacing = Some(Box::new(CTSignedTwipsMeasure::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"w" => {
                                f_width = Some(Box::new(CTTextScale::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"kern" => {
                                f_kern = Some(Box::new(CTHpsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"position" => {
                                f_position = Some(Box::new(CTSignedHpsMeasure::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sz" => {
                                f_size = Some(Box::new(CTHpsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"szCs" => {
                                f_size_complex_script =
                                    Some(Box::new(CTHpsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"highlight" => {
                                f_highlight =
                                    Some(Box::new(CTHighlight::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"u" => {
                                f_underline =
                                    Some(Box::new(CTUnderline::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"effect" => {
                                f_effect =
                                    Some(Box::new(CTTextEffect::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bdr" => {
                                f_bdr = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"fitText" => {
                                f_fit_text =
                                    Some(Box::new(CTFitText::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vertAlign" => {
                                f_vert_align = Some(Box::new(CTVerticalAlignRun::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rtl" => {
                                f_rtl = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cs" => {
                                f_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"em" => {
                                f_em = Some(Box::new(CTEm::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lang" => {
                                f_lang = Some(Box::new(CTLanguage::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"eastAsianLayout" => {
                                f_east_asian_layout =
                                    Some(Box::new(CTEastAsianLayout::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"specVanish" => {
                                f_spec_vanish =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"oMath" => {
                                f_o_math = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rPrChange" => {
                                f_r_pr_change =
                                    Some(Box::new(CTRPrChange::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"rStyle" => {
                                f_run_style = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rFonts" => {
                                f_fonts = Some(Box::new(Fonts::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"b" => {
                                f_bold = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bCs" => {
                                f_b_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"i" => {
                                f_italic = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"iCs" => {
                                f_i_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"caps" => {
                                f_caps = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"smallCaps" => {
                                f_small_caps = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"strike" => {
                                f_strikethrough =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dstrike" => {
                                f_dstrike = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"outline" => {
                                f_outline = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shadow" => {
                                f_shadow = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"emboss" => {
                                f_emboss = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"imprint" => {
                                f_imprint = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noProof" => {
                                f_no_proof = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"snapToGrid" => {
                                f_snap_to_grid =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vanish" => {
                                f_vanish = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"webHidden" => {
                                f_web_hidden = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"color" => {
                                f_color = Some(Box::new(CTColor::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"spacing" => {
                                f_spacing = Some(Box::new(CTSignedTwipsMeasure::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"w" => {
                                f_width = Some(Box::new(CTTextScale::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"kern" => {
                                f_kern = Some(Box::new(CTHpsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"position" => {
                                f_position =
                                    Some(Box::new(CTSignedHpsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sz" => {
                                f_size = Some(Box::new(CTHpsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"szCs" => {
                                f_size_complex_script =
                                    Some(Box::new(CTHpsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"highlight" => {
                                f_highlight =
                                    Some(Box::new(CTHighlight::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"u" => {
                                f_underline =
                                    Some(Box::new(CTUnderline::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"effect" => {
                                f_effect =
                                    Some(Box::new(CTTextEffect::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bdr" => {
                                f_bdr = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"fitText" => {
                                f_fit_text = Some(Box::new(CTFitText::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vertAlign" => {
                                f_vert_align =
                                    Some(Box::new(CTVerticalAlignRun::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rtl" => {
                                f_rtl = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cs" => {
                                f_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"em" => {
                                f_em = Some(Box::new(CTEm::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lang" => {
                                f_lang = Some(Box::new(CTLanguage::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"eastAsianLayout" => {
                                f_east_asian_layout =
                                    Some(Box::new(CTEastAsianLayout::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"specVanish" => {
                                f_spec_vanish =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"oMath" => {
                                f_o_math = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rPrChange" => {
                                f_r_pr_change =
                                    Some(Box::new(CTRPrChange::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            run_style: f_run_style,
            fonts: f_fonts,
            bold: f_bold,
            b_cs: f_b_cs,
            italic: f_italic,
            i_cs: f_i_cs,
            caps: f_caps,
            small_caps: f_small_caps,
            strikethrough: f_strikethrough,
            dstrike: f_dstrike,
            outline: f_outline,
            shadow: f_shadow,
            emboss: f_emboss,
            imprint: f_imprint,
            no_proof: f_no_proof,
            snap_to_grid: f_snap_to_grid,
            vanish: f_vanish,
            web_hidden: f_web_hidden,
            color: f_color,
            spacing: f_spacing,
            width: f_width,
            kern: f_kern,
            position: f_position,
            size: f_size,
            size_complex_script: f_size_complex_script,
            highlight: f_highlight,
            underline: f_underline,
            effect: f_effect,
            bdr: f_bdr,
            shading: f_shading,
            fit_text: f_fit_text,
            vert_align: f_vert_align,
            rtl: f_rtl,
            cs: f_cs,
            em: f_em,
            lang: f_lang,
            east_asian_layout: f_east_asian_layout,
            spec_vanish: f_spec_vanish,
            o_math: f_o_math,
            r_pr_change: f_r_pr_change,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for RunProperties {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_run_style = None;
        #[cfg(feature = "wml-styling")]
        let mut f_fonts = None;
        #[cfg(feature = "wml-styling")]
        let mut f_bold = None;
        #[cfg(feature = "wml-styling")]
        let mut f_b_cs = None;
        #[cfg(feature = "wml-styling")]
        let mut f_italic = None;
        #[cfg(feature = "wml-styling")]
        let mut f_i_cs = None;
        #[cfg(feature = "wml-styling")]
        let mut f_caps = None;
        #[cfg(feature = "wml-styling")]
        let mut f_small_caps = None;
        #[cfg(feature = "wml-styling")]
        let mut f_strikethrough = None;
        #[cfg(feature = "wml-styling")]
        let mut f_dstrike = None;
        #[cfg(feature = "wml-styling")]
        let mut f_outline = None;
        #[cfg(feature = "wml-styling")]
        let mut f_shadow = None;
        #[cfg(feature = "wml-styling")]
        let mut f_emboss = None;
        #[cfg(feature = "wml-styling")]
        let mut f_imprint = None;
        #[cfg(feature = "wml-styling")]
        let mut f_no_proof = None;
        #[cfg(feature = "wml-styling")]
        let mut f_snap_to_grid = None;
        #[cfg(feature = "wml-styling")]
        let mut f_vanish = None;
        #[cfg(feature = "wml-styling")]
        let mut f_web_hidden = None;
        #[cfg(feature = "wml-styling")]
        let mut f_color = None;
        #[cfg(feature = "wml-styling")]
        let mut f_spacing = None;
        #[cfg(feature = "wml-styling")]
        let mut f_width = None;
        #[cfg(feature = "wml-styling")]
        let mut f_kern = None;
        #[cfg(feature = "wml-styling")]
        let mut f_position = None;
        #[cfg(feature = "wml-styling")]
        let mut f_size = None;
        #[cfg(feature = "wml-styling")]
        let mut f_size_complex_script = None;
        #[cfg(feature = "wml-styling")]
        let mut f_highlight = None;
        #[cfg(feature = "wml-styling")]
        let mut f_underline = None;
        #[cfg(feature = "wml-styling")]
        let mut f_effect = None;
        #[cfg(feature = "wml-styling")]
        let mut f_bdr = None;
        #[cfg(feature = "wml-styling")]
        let mut f_shading = None;
        #[cfg(feature = "wml-styling")]
        let mut f_fit_text = None;
        #[cfg(feature = "wml-styling")]
        let mut f_vert_align = None;
        #[cfg(feature = "wml-styling")]
        let mut f_rtl = None;
        #[cfg(feature = "wml-styling")]
        let mut f_cs = None;
        #[cfg(feature = "wml-styling")]
        let mut f_em = None;
        #[cfg(feature = "wml-styling")]
        let mut f_lang = None;
        #[cfg(feature = "wml-styling")]
        let mut f_east_asian_layout = None;
        #[cfg(feature = "wml-styling")]
        let mut f_spec_vanish = None;
        #[cfg(feature = "wml-styling")]
        let mut f_o_math = None;
        #[cfg(feature = "wml-track-changes")]
        let mut f_r_pr_change = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"rStyle" => {
                                f_run_style =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"rFonts" => {
                                f_fonts = Some(Box::new(Fonts::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"b" => {
                                f_bold = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"bCs" => {
                                f_b_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"i" => {
                                f_italic = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"iCs" => {
                                f_i_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"caps" => {
                                f_caps = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"smallCaps" => {
                                f_small_caps =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"strike" => {
                                f_strikethrough =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"dstrike" => {
                                f_dstrike = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"outline" => {
                                f_outline = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"shadow" => {
                                f_shadow = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"emboss" => {
                                f_emboss = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"imprint" => {
                                f_imprint = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"noProof" => {
                                f_no_proof = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"snapToGrid" => {
                                f_snap_to_grid =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"vanish" => {
                                f_vanish = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"webHidden" => {
                                f_web_hidden =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"color" => {
                                f_color = Some(Box::new(CTColor::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"spacing" => {
                                f_spacing = Some(Box::new(CTSignedTwipsMeasure::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"w" => {
                                f_width = Some(Box::new(CTTextScale::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"kern" => {
                                f_kern = Some(Box::new(CTHpsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"position" => {
                                f_position = Some(Box::new(CTSignedHpsMeasure::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"sz" => {
                                f_size = Some(Box::new(CTHpsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"szCs" => {
                                f_size_complex_script =
                                    Some(Box::new(CTHpsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"highlight" => {
                                f_highlight =
                                    Some(Box::new(CTHighlight::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"u" => {
                                f_underline =
                                    Some(Box::new(CTUnderline::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"effect" => {
                                f_effect =
                                    Some(Box::new(CTTextEffect::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"bdr" => {
                                f_bdr = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"fitText" => {
                                f_fit_text =
                                    Some(Box::new(CTFitText::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"vertAlign" => {
                                f_vert_align = Some(Box::new(CTVerticalAlignRun::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"rtl" => {
                                f_rtl = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"cs" => {
                                f_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"em" => {
                                f_em = Some(Box::new(CTEm::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"lang" => {
                                f_lang = Some(Box::new(CTLanguage::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"eastAsianLayout" => {
                                f_east_asian_layout =
                                    Some(Box::new(CTEastAsianLayout::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"specVanish" => {
                                f_spec_vanish =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"oMath" => {
                                f_o_math = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-track-changes")]
                            b"rPrChange" => {
                                f_r_pr_change =
                                    Some(Box::new(CTRPrChange::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"rStyle" => {
                                f_run_style = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"rFonts" => {
                                f_fonts = Some(Box::new(Fonts::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"b" => {
                                f_bold = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"bCs" => {
                                f_b_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"i" => {
                                f_italic = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"iCs" => {
                                f_i_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"caps" => {
                                f_caps = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"smallCaps" => {
                                f_small_caps = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"strike" => {
                                f_strikethrough =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"dstrike" => {
                                f_dstrike = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"outline" => {
                                f_outline = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"shadow" => {
                                f_shadow = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"emboss" => {
                                f_emboss = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"imprint" => {
                                f_imprint = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"noProof" => {
                                f_no_proof = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"snapToGrid" => {
                                f_snap_to_grid =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"vanish" => {
                                f_vanish = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"webHidden" => {
                                f_web_hidden = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"color" => {
                                f_color = Some(Box::new(CTColor::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"spacing" => {
                                f_spacing = Some(Box::new(CTSignedTwipsMeasure::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"w" => {
                                f_width = Some(Box::new(CTTextScale::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"kern" => {
                                f_kern = Some(Box::new(CTHpsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"position" => {
                                f_position =
                                    Some(Box::new(CTSignedHpsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"sz" => {
                                f_size = Some(Box::new(CTHpsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"szCs" => {
                                f_size_complex_script =
                                    Some(Box::new(CTHpsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"highlight" => {
                                f_highlight =
                                    Some(Box::new(CTHighlight::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"u" => {
                                f_underline =
                                    Some(Box::new(CTUnderline::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"effect" => {
                                f_effect =
                                    Some(Box::new(CTTextEffect::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"bdr" => {
                                f_bdr = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"fitText" => {
                                f_fit_text = Some(Box::new(CTFitText::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"vertAlign" => {
                                f_vert_align =
                                    Some(Box::new(CTVerticalAlignRun::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"rtl" => {
                                f_rtl = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"cs" => {
                                f_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"em" => {
                                f_em = Some(Box::new(CTEm::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"lang" => {
                                f_lang = Some(Box::new(CTLanguage::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"eastAsianLayout" => {
                                f_east_asian_layout =
                                    Some(Box::new(CTEastAsianLayout::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"specVanish" => {
                                f_spec_vanish =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"oMath" => {
                                f_o_math = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-track-changes")]
                            b"rPrChange" => {
                                f_r_pr_change =
                                    Some(Box::new(CTRPrChange::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            run_style: f_run_style,
            #[cfg(feature = "wml-styling")]
            fonts: f_fonts,
            #[cfg(feature = "wml-styling")]
            bold: f_bold,
            #[cfg(feature = "wml-styling")]
            b_cs: f_b_cs,
            #[cfg(feature = "wml-styling")]
            italic: f_italic,
            #[cfg(feature = "wml-styling")]
            i_cs: f_i_cs,
            #[cfg(feature = "wml-styling")]
            caps: f_caps,
            #[cfg(feature = "wml-styling")]
            small_caps: f_small_caps,
            #[cfg(feature = "wml-styling")]
            strikethrough: f_strikethrough,
            #[cfg(feature = "wml-styling")]
            dstrike: f_dstrike,
            #[cfg(feature = "wml-styling")]
            outline: f_outline,
            #[cfg(feature = "wml-styling")]
            shadow: f_shadow,
            #[cfg(feature = "wml-styling")]
            emboss: f_emboss,
            #[cfg(feature = "wml-styling")]
            imprint: f_imprint,
            #[cfg(feature = "wml-styling")]
            no_proof: f_no_proof,
            #[cfg(feature = "wml-styling")]
            snap_to_grid: f_snap_to_grid,
            #[cfg(feature = "wml-styling")]
            vanish: f_vanish,
            #[cfg(feature = "wml-styling")]
            web_hidden: f_web_hidden,
            #[cfg(feature = "wml-styling")]
            color: f_color,
            #[cfg(feature = "wml-styling")]
            spacing: f_spacing,
            #[cfg(feature = "wml-styling")]
            width: f_width,
            #[cfg(feature = "wml-styling")]
            kern: f_kern,
            #[cfg(feature = "wml-styling")]
            position: f_position,
            #[cfg(feature = "wml-styling")]
            size: f_size,
            #[cfg(feature = "wml-styling")]
            size_complex_script: f_size_complex_script,
            #[cfg(feature = "wml-styling")]
            highlight: f_highlight,
            #[cfg(feature = "wml-styling")]
            underline: f_underline,
            #[cfg(feature = "wml-styling")]
            effect: f_effect,
            #[cfg(feature = "wml-styling")]
            bdr: f_bdr,
            #[cfg(feature = "wml-styling")]
            shading: f_shading,
            #[cfg(feature = "wml-styling")]
            fit_text: f_fit_text,
            #[cfg(feature = "wml-styling")]
            vert_align: f_vert_align,
            #[cfg(feature = "wml-styling")]
            rtl: f_rtl,
            #[cfg(feature = "wml-styling")]
            cs: f_cs,
            #[cfg(feature = "wml-styling")]
            em: f_em,
            #[cfg(feature = "wml-styling")]
            lang: f_lang,
            #[cfg(feature = "wml-styling")]
            east_asian_layout: f_east_asian_layout,
            #[cfg(feature = "wml-styling")]
            spec_vanish: f_spec_vanish,
            #[cfg(feature = "wml-styling")]
            o_math: f_o_math,
            #[cfg(feature = "wml-track-changes")]
            r_pr_change: f_r_pr_change,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for EGRPr {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_r_pr = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"rPr" => {
                                f_r_pr =
                                    Some(Box::new(RunProperties::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"rPr" => {
                                f_r_pr = Some(Box::new(RunProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r_pr: f_r_pr,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for MathRunProperties {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let tag = start_tag.local_name();
        match tag.as_ref() {
            b"rPr" => {
                let inner = RunProperties::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::RPr(Box::new(inner)))
            }
            b"ins" => {
                let inner = CTMathCtrlIns::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Ins(Box::new(inner)))
            }
            b"del" => {
                let inner = CTMathCtrlDel::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Del(Box::new(inner)))
            }
            _ => Err(ParseError::UnexpectedElement(
                String::from_utf8_lossy(start_tag.name().as_ref()).into_owned(),
            )),
        }
    }
}

impl FromXml for CTMathCtrlIns {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STDecimalNumber> = None;
        let mut f_author: Option<STString> = None;
        let mut f_date = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"author" => {
                    f_author = Some(val.into_owned());
                }
                b"date" => {
                    f_date = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            author: f_author.ok_or_else(|| ParseError::MissingAttribute("author".to_string()))?,
            date: f_date,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTMathCtrlDel {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STDecimalNumber> = None;
        let mut f_author: Option<STString> = None;
        let mut f_date = None;
        let mut f_r_pr = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"author" => {
                    f_author = Some(val.into_owned());
                }
                b"date" => {
                    f_date = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"rPr" => {
                                f_r_pr =
                                    Some(Box::new(RunProperties::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"rPr" => {
                                f_r_pr = Some(Box::new(RunProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            author: f_author.ok_or_else(|| ParseError::MissingAttribute("author".to_string()))?,
            date: f_date,
            r_pr: f_r_pr,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTRPrOriginal {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_run_style = None;
        let mut f_fonts = None;
        let mut f_bold = None;
        let mut f_b_cs = None;
        let mut f_italic = None;
        let mut f_i_cs = None;
        let mut f_caps = None;
        let mut f_small_caps = None;
        let mut f_strikethrough = None;
        let mut f_dstrike = None;
        let mut f_outline = None;
        let mut f_shadow = None;
        let mut f_emboss = None;
        let mut f_imprint = None;
        let mut f_no_proof = None;
        let mut f_snap_to_grid = None;
        let mut f_vanish = None;
        let mut f_web_hidden = None;
        let mut f_color = None;
        let mut f_spacing = None;
        let mut f_width = None;
        let mut f_kern = None;
        let mut f_position = None;
        let mut f_size = None;
        let mut f_size_complex_script = None;
        let mut f_highlight = None;
        let mut f_underline = None;
        let mut f_effect = None;
        let mut f_bdr = None;
        let mut f_shading = None;
        let mut f_fit_text = None;
        let mut f_vert_align = None;
        let mut f_rtl = None;
        let mut f_cs = None;
        let mut f_em = None;
        let mut f_lang = None;
        let mut f_east_asian_layout = None;
        let mut f_spec_vanish = None;
        let mut f_o_math = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"rStyle" => {
                                f_run_style =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rFonts" => {
                                f_fonts = Some(Box::new(Fonts::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"b" => {
                                f_bold = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bCs" => {
                                f_b_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"i" => {
                                f_italic = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"iCs" => {
                                f_i_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"caps" => {
                                f_caps = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"smallCaps" => {
                                f_small_caps =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"strike" => {
                                f_strikethrough =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dstrike" => {
                                f_dstrike = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"outline" => {
                                f_outline = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shadow" => {
                                f_shadow = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"emboss" => {
                                f_emboss = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"imprint" => {
                                f_imprint = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noProof" => {
                                f_no_proof = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"snapToGrid" => {
                                f_snap_to_grid =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vanish" => {
                                f_vanish = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"webHidden" => {
                                f_web_hidden =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"color" => {
                                f_color = Some(Box::new(CTColor::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"spacing" => {
                                f_spacing = Some(Box::new(CTSignedTwipsMeasure::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"w" => {
                                f_width = Some(Box::new(CTTextScale::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"kern" => {
                                f_kern = Some(Box::new(CTHpsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"position" => {
                                f_position = Some(Box::new(CTSignedHpsMeasure::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sz" => {
                                f_size = Some(Box::new(CTHpsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"szCs" => {
                                f_size_complex_script =
                                    Some(Box::new(CTHpsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"highlight" => {
                                f_highlight =
                                    Some(Box::new(CTHighlight::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"u" => {
                                f_underline =
                                    Some(Box::new(CTUnderline::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"effect" => {
                                f_effect =
                                    Some(Box::new(CTTextEffect::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bdr" => {
                                f_bdr = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"fitText" => {
                                f_fit_text =
                                    Some(Box::new(CTFitText::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vertAlign" => {
                                f_vert_align = Some(Box::new(CTVerticalAlignRun::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rtl" => {
                                f_rtl = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cs" => {
                                f_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"em" => {
                                f_em = Some(Box::new(CTEm::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lang" => {
                                f_lang = Some(Box::new(CTLanguage::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"eastAsianLayout" => {
                                f_east_asian_layout =
                                    Some(Box::new(CTEastAsianLayout::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"specVanish" => {
                                f_spec_vanish =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"oMath" => {
                                f_o_math = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"rStyle" => {
                                f_run_style = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rFonts" => {
                                f_fonts = Some(Box::new(Fonts::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"b" => {
                                f_bold = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bCs" => {
                                f_b_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"i" => {
                                f_italic = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"iCs" => {
                                f_i_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"caps" => {
                                f_caps = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"smallCaps" => {
                                f_small_caps = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"strike" => {
                                f_strikethrough =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dstrike" => {
                                f_dstrike = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"outline" => {
                                f_outline = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shadow" => {
                                f_shadow = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"emboss" => {
                                f_emboss = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"imprint" => {
                                f_imprint = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noProof" => {
                                f_no_proof = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"snapToGrid" => {
                                f_snap_to_grid =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vanish" => {
                                f_vanish = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"webHidden" => {
                                f_web_hidden = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"color" => {
                                f_color = Some(Box::new(CTColor::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"spacing" => {
                                f_spacing = Some(Box::new(CTSignedTwipsMeasure::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"w" => {
                                f_width = Some(Box::new(CTTextScale::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"kern" => {
                                f_kern = Some(Box::new(CTHpsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"position" => {
                                f_position =
                                    Some(Box::new(CTSignedHpsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sz" => {
                                f_size = Some(Box::new(CTHpsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"szCs" => {
                                f_size_complex_script =
                                    Some(Box::new(CTHpsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"highlight" => {
                                f_highlight =
                                    Some(Box::new(CTHighlight::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"u" => {
                                f_underline =
                                    Some(Box::new(CTUnderline::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"effect" => {
                                f_effect =
                                    Some(Box::new(CTTextEffect::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bdr" => {
                                f_bdr = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"fitText" => {
                                f_fit_text = Some(Box::new(CTFitText::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vertAlign" => {
                                f_vert_align =
                                    Some(Box::new(CTVerticalAlignRun::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rtl" => {
                                f_rtl = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cs" => {
                                f_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"em" => {
                                f_em = Some(Box::new(CTEm::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lang" => {
                                f_lang = Some(Box::new(CTLanguage::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"eastAsianLayout" => {
                                f_east_asian_layout =
                                    Some(Box::new(CTEastAsianLayout::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"specVanish" => {
                                f_spec_vanish =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"oMath" => {
                                f_o_math = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            run_style: f_run_style,
            fonts: f_fonts,
            bold: f_bold,
            b_cs: f_b_cs,
            italic: f_italic,
            i_cs: f_i_cs,
            caps: f_caps,
            small_caps: f_small_caps,
            strikethrough: f_strikethrough,
            dstrike: f_dstrike,
            outline: f_outline,
            shadow: f_shadow,
            emboss: f_emboss,
            imprint: f_imprint,
            no_proof: f_no_proof,
            snap_to_grid: f_snap_to_grid,
            vanish: f_vanish,
            web_hidden: f_web_hidden,
            color: f_color,
            spacing: f_spacing,
            width: f_width,
            kern: f_kern,
            position: f_position,
            size: f_size,
            size_complex_script: f_size_complex_script,
            highlight: f_highlight,
            underline: f_underline,
            effect: f_effect,
            bdr: f_bdr,
            shading: f_shading,
            fit_text: f_fit_text,
            vert_align: f_vert_align,
            rtl: f_rtl,
            cs: f_cs,
            em: f_em,
            lang: f_lang,
            east_asian_layout: f_east_asian_layout,
            spec_vanish: f_spec_vanish,
            o_math: f_o_math,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTParaRPrOriginal {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_ins = None;
        let mut f_del = None;
        let mut f_move_from = None;
        let mut f_move_to = None;
        let mut f_run_style = None;
        let mut f_fonts = None;
        let mut f_bold = None;
        let mut f_b_cs = None;
        let mut f_italic = None;
        let mut f_i_cs = None;
        let mut f_caps = None;
        let mut f_small_caps = None;
        let mut f_strikethrough = None;
        let mut f_dstrike = None;
        let mut f_outline = None;
        let mut f_shadow = None;
        let mut f_emboss = None;
        let mut f_imprint = None;
        let mut f_no_proof = None;
        let mut f_snap_to_grid = None;
        let mut f_vanish = None;
        let mut f_web_hidden = None;
        let mut f_color = None;
        let mut f_spacing = None;
        let mut f_width = None;
        let mut f_kern = None;
        let mut f_position = None;
        let mut f_size = None;
        let mut f_size_complex_script = None;
        let mut f_highlight = None;
        let mut f_underline = None;
        let mut f_effect = None;
        let mut f_bdr = None;
        let mut f_shading = None;
        let mut f_fit_text = None;
        let mut f_vert_align = None;
        let mut f_rtl = None;
        let mut f_cs = None;
        let mut f_em = None;
        let mut f_lang = None;
        let mut f_east_asian_layout = None;
        let mut f_spec_vanish = None;
        let mut f_o_math = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"ins" => {
                                f_ins = Some(Box::new(CTTrackChange::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"del" => {
                                f_del = Some(Box::new(CTTrackChange::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"moveFrom" => {
                                f_move_from =
                                    Some(Box::new(CTTrackChange::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"moveTo" => {
                                f_move_to =
                                    Some(Box::new(CTTrackChange::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rStyle" => {
                                f_run_style =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rFonts" => {
                                f_fonts = Some(Box::new(Fonts::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"b" => {
                                f_bold = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bCs" => {
                                f_b_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"i" => {
                                f_italic = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"iCs" => {
                                f_i_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"caps" => {
                                f_caps = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"smallCaps" => {
                                f_small_caps =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"strike" => {
                                f_strikethrough =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dstrike" => {
                                f_dstrike = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"outline" => {
                                f_outline = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shadow" => {
                                f_shadow = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"emboss" => {
                                f_emboss = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"imprint" => {
                                f_imprint = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noProof" => {
                                f_no_proof = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"snapToGrid" => {
                                f_snap_to_grid =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vanish" => {
                                f_vanish = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"webHidden" => {
                                f_web_hidden =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"color" => {
                                f_color = Some(Box::new(CTColor::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"spacing" => {
                                f_spacing = Some(Box::new(CTSignedTwipsMeasure::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"w" => {
                                f_width = Some(Box::new(CTTextScale::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"kern" => {
                                f_kern = Some(Box::new(CTHpsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"position" => {
                                f_position = Some(Box::new(CTSignedHpsMeasure::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sz" => {
                                f_size = Some(Box::new(CTHpsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"szCs" => {
                                f_size_complex_script =
                                    Some(Box::new(CTHpsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"highlight" => {
                                f_highlight =
                                    Some(Box::new(CTHighlight::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"u" => {
                                f_underline =
                                    Some(Box::new(CTUnderline::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"effect" => {
                                f_effect =
                                    Some(Box::new(CTTextEffect::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bdr" => {
                                f_bdr = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"fitText" => {
                                f_fit_text =
                                    Some(Box::new(CTFitText::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vertAlign" => {
                                f_vert_align = Some(Box::new(CTVerticalAlignRun::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rtl" => {
                                f_rtl = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cs" => {
                                f_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"em" => {
                                f_em = Some(Box::new(CTEm::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lang" => {
                                f_lang = Some(Box::new(CTLanguage::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"eastAsianLayout" => {
                                f_east_asian_layout =
                                    Some(Box::new(CTEastAsianLayout::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"specVanish" => {
                                f_spec_vanish =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"oMath" => {
                                f_o_math = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"ins" => {
                                f_ins = Some(Box::new(CTTrackChange::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"del" => {
                                f_del = Some(Box::new(CTTrackChange::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"moveFrom" => {
                                f_move_from =
                                    Some(Box::new(CTTrackChange::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"moveTo" => {
                                f_move_to =
                                    Some(Box::new(CTTrackChange::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rStyle" => {
                                f_run_style = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rFonts" => {
                                f_fonts = Some(Box::new(Fonts::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"b" => {
                                f_bold = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bCs" => {
                                f_b_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"i" => {
                                f_italic = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"iCs" => {
                                f_i_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"caps" => {
                                f_caps = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"smallCaps" => {
                                f_small_caps = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"strike" => {
                                f_strikethrough =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dstrike" => {
                                f_dstrike = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"outline" => {
                                f_outline = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shadow" => {
                                f_shadow = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"emboss" => {
                                f_emboss = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"imprint" => {
                                f_imprint = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noProof" => {
                                f_no_proof = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"snapToGrid" => {
                                f_snap_to_grid =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vanish" => {
                                f_vanish = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"webHidden" => {
                                f_web_hidden = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"color" => {
                                f_color = Some(Box::new(CTColor::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"spacing" => {
                                f_spacing = Some(Box::new(CTSignedTwipsMeasure::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"w" => {
                                f_width = Some(Box::new(CTTextScale::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"kern" => {
                                f_kern = Some(Box::new(CTHpsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"position" => {
                                f_position =
                                    Some(Box::new(CTSignedHpsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sz" => {
                                f_size = Some(Box::new(CTHpsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"szCs" => {
                                f_size_complex_script =
                                    Some(Box::new(CTHpsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"highlight" => {
                                f_highlight =
                                    Some(Box::new(CTHighlight::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"u" => {
                                f_underline =
                                    Some(Box::new(CTUnderline::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"effect" => {
                                f_effect =
                                    Some(Box::new(CTTextEffect::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bdr" => {
                                f_bdr = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"fitText" => {
                                f_fit_text = Some(Box::new(CTFitText::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vertAlign" => {
                                f_vert_align =
                                    Some(Box::new(CTVerticalAlignRun::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rtl" => {
                                f_rtl = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cs" => {
                                f_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"em" => {
                                f_em = Some(Box::new(CTEm::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lang" => {
                                f_lang = Some(Box::new(CTLanguage::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"eastAsianLayout" => {
                                f_east_asian_layout =
                                    Some(Box::new(CTEastAsianLayout::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"specVanish" => {
                                f_spec_vanish =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"oMath" => {
                                f_o_math = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            ins: f_ins,
            del: f_del,
            move_from: f_move_from,
            move_to: f_move_to,
            run_style: f_run_style,
            fonts: f_fonts,
            bold: f_bold,
            b_cs: f_b_cs,
            italic: f_italic,
            i_cs: f_i_cs,
            caps: f_caps,
            small_caps: f_small_caps,
            strikethrough: f_strikethrough,
            dstrike: f_dstrike,
            outline: f_outline,
            shadow: f_shadow,
            emboss: f_emboss,
            imprint: f_imprint,
            no_proof: f_no_proof,
            snap_to_grid: f_snap_to_grid,
            vanish: f_vanish,
            web_hidden: f_web_hidden,
            color: f_color,
            spacing: f_spacing,
            width: f_width,
            kern: f_kern,
            position: f_position,
            size: f_size,
            size_complex_script: f_size_complex_script,
            highlight: f_highlight,
            underline: f_underline,
            effect: f_effect,
            bdr: f_bdr,
            shading: f_shading,
            fit_text: f_fit_text,
            vert_align: f_vert_align,
            rtl: f_rtl,
            cs: f_cs,
            em: f_em,
            lang: f_lang,
            east_asian_layout: f_east_asian_layout,
            spec_vanish: f_spec_vanish,
            o_math: f_o_math,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTParaRPr {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_ins = None;
        let mut f_del = None;
        let mut f_move_from = None;
        let mut f_move_to = None;
        let mut f_run_style = None;
        let mut f_fonts = None;
        let mut f_bold = None;
        let mut f_b_cs = None;
        let mut f_italic = None;
        let mut f_i_cs = None;
        let mut f_caps = None;
        let mut f_small_caps = None;
        let mut f_strikethrough = None;
        let mut f_dstrike = None;
        let mut f_outline = None;
        let mut f_shadow = None;
        let mut f_emboss = None;
        let mut f_imprint = None;
        let mut f_no_proof = None;
        let mut f_snap_to_grid = None;
        let mut f_vanish = None;
        let mut f_web_hidden = None;
        let mut f_color = None;
        let mut f_spacing = None;
        let mut f_width = None;
        let mut f_kern = None;
        let mut f_position = None;
        let mut f_size = None;
        let mut f_size_complex_script = None;
        let mut f_highlight = None;
        let mut f_underline = None;
        let mut f_effect = None;
        let mut f_bdr = None;
        let mut f_shading = None;
        let mut f_fit_text = None;
        let mut f_vert_align = None;
        let mut f_rtl = None;
        let mut f_cs = None;
        let mut f_em = None;
        let mut f_lang = None;
        let mut f_east_asian_layout = None;
        let mut f_spec_vanish = None;
        let mut f_o_math = None;
        let mut f_r_pr_change = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"ins" => {
                                f_ins = Some(Box::new(CTTrackChange::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"del" => {
                                f_del = Some(Box::new(CTTrackChange::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"moveFrom" => {
                                f_move_from =
                                    Some(Box::new(CTTrackChange::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"moveTo" => {
                                f_move_to =
                                    Some(Box::new(CTTrackChange::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rStyle" => {
                                f_run_style =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rFonts" => {
                                f_fonts = Some(Box::new(Fonts::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"b" => {
                                f_bold = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bCs" => {
                                f_b_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"i" => {
                                f_italic = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"iCs" => {
                                f_i_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"caps" => {
                                f_caps = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"smallCaps" => {
                                f_small_caps =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"strike" => {
                                f_strikethrough =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dstrike" => {
                                f_dstrike = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"outline" => {
                                f_outline = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shadow" => {
                                f_shadow = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"emboss" => {
                                f_emboss = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"imprint" => {
                                f_imprint = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noProof" => {
                                f_no_proof = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"snapToGrid" => {
                                f_snap_to_grid =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vanish" => {
                                f_vanish = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"webHidden" => {
                                f_web_hidden =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"color" => {
                                f_color = Some(Box::new(CTColor::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"spacing" => {
                                f_spacing = Some(Box::new(CTSignedTwipsMeasure::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"w" => {
                                f_width = Some(Box::new(CTTextScale::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"kern" => {
                                f_kern = Some(Box::new(CTHpsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"position" => {
                                f_position = Some(Box::new(CTSignedHpsMeasure::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sz" => {
                                f_size = Some(Box::new(CTHpsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"szCs" => {
                                f_size_complex_script =
                                    Some(Box::new(CTHpsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"highlight" => {
                                f_highlight =
                                    Some(Box::new(CTHighlight::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"u" => {
                                f_underline =
                                    Some(Box::new(CTUnderline::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"effect" => {
                                f_effect =
                                    Some(Box::new(CTTextEffect::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bdr" => {
                                f_bdr = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"fitText" => {
                                f_fit_text =
                                    Some(Box::new(CTFitText::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vertAlign" => {
                                f_vert_align = Some(Box::new(CTVerticalAlignRun::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rtl" => {
                                f_rtl = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cs" => {
                                f_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"em" => {
                                f_em = Some(Box::new(CTEm::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lang" => {
                                f_lang = Some(Box::new(CTLanguage::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"eastAsianLayout" => {
                                f_east_asian_layout =
                                    Some(Box::new(CTEastAsianLayout::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"specVanish" => {
                                f_spec_vanish =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"oMath" => {
                                f_o_math = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rPrChange" => {
                                f_r_pr_change =
                                    Some(Box::new(CTParaRPrChange::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"ins" => {
                                f_ins = Some(Box::new(CTTrackChange::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"del" => {
                                f_del = Some(Box::new(CTTrackChange::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"moveFrom" => {
                                f_move_from =
                                    Some(Box::new(CTTrackChange::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"moveTo" => {
                                f_move_to =
                                    Some(Box::new(CTTrackChange::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rStyle" => {
                                f_run_style = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rFonts" => {
                                f_fonts = Some(Box::new(Fonts::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"b" => {
                                f_bold = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bCs" => {
                                f_b_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"i" => {
                                f_italic = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"iCs" => {
                                f_i_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"caps" => {
                                f_caps = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"smallCaps" => {
                                f_small_caps = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"strike" => {
                                f_strikethrough =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dstrike" => {
                                f_dstrike = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"outline" => {
                                f_outline = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shadow" => {
                                f_shadow = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"emboss" => {
                                f_emboss = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"imprint" => {
                                f_imprint = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noProof" => {
                                f_no_proof = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"snapToGrid" => {
                                f_snap_to_grid =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vanish" => {
                                f_vanish = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"webHidden" => {
                                f_web_hidden = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"color" => {
                                f_color = Some(Box::new(CTColor::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"spacing" => {
                                f_spacing = Some(Box::new(CTSignedTwipsMeasure::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"w" => {
                                f_width = Some(Box::new(CTTextScale::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"kern" => {
                                f_kern = Some(Box::new(CTHpsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"position" => {
                                f_position =
                                    Some(Box::new(CTSignedHpsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sz" => {
                                f_size = Some(Box::new(CTHpsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"szCs" => {
                                f_size_complex_script =
                                    Some(Box::new(CTHpsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"highlight" => {
                                f_highlight =
                                    Some(Box::new(CTHighlight::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"u" => {
                                f_underline =
                                    Some(Box::new(CTUnderline::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"effect" => {
                                f_effect =
                                    Some(Box::new(CTTextEffect::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bdr" => {
                                f_bdr = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"fitText" => {
                                f_fit_text = Some(Box::new(CTFitText::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vertAlign" => {
                                f_vert_align =
                                    Some(Box::new(CTVerticalAlignRun::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rtl" => {
                                f_rtl = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cs" => {
                                f_cs = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"em" => {
                                f_em = Some(Box::new(CTEm::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lang" => {
                                f_lang = Some(Box::new(CTLanguage::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"eastAsianLayout" => {
                                f_east_asian_layout =
                                    Some(Box::new(CTEastAsianLayout::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"specVanish" => {
                                f_spec_vanish =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"oMath" => {
                                f_o_math = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rPrChange" => {
                                f_r_pr_change =
                                    Some(Box::new(CTParaRPrChange::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            ins: f_ins,
            del: f_del,
            move_from: f_move_from,
            move_to: f_move_to,
            run_style: f_run_style,
            fonts: f_fonts,
            bold: f_bold,
            b_cs: f_b_cs,
            italic: f_italic,
            i_cs: f_i_cs,
            caps: f_caps,
            small_caps: f_small_caps,
            strikethrough: f_strikethrough,
            dstrike: f_dstrike,
            outline: f_outline,
            shadow: f_shadow,
            emboss: f_emboss,
            imprint: f_imprint,
            no_proof: f_no_proof,
            snap_to_grid: f_snap_to_grid,
            vanish: f_vanish,
            web_hidden: f_web_hidden,
            color: f_color,
            spacing: f_spacing,
            width: f_width,
            kern: f_kern,
            position: f_position,
            size: f_size,
            size_complex_script: f_size_complex_script,
            highlight: f_highlight,
            underline: f_underline,
            effect: f_effect,
            bdr: f_bdr,
            shading: f_shading,
            fit_text: f_fit_text,
            vert_align: f_vert_align,
            rtl: f_rtl,
            cs: f_cs,
            em: f_em,
            lang: f_lang,
            east_asian_layout: f_east_asian_layout,
            spec_vanish: f_spec_vanish,
            o_math: f_o_math,
            r_pr_change: f_r_pr_change,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for EGParaRPrTrackChanges {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_ins = None;
        let mut f_del = None;
        let mut f_move_from = None;
        let mut f_move_to = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"ins" => {
                                f_ins = Some(Box::new(CTTrackChange::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"del" => {
                                f_del = Some(Box::new(CTTrackChange::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"moveFrom" => {
                                f_move_from =
                                    Some(Box::new(CTTrackChange::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"moveTo" => {
                                f_move_to =
                                    Some(Box::new(CTTrackChange::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"ins" => {
                                f_ins = Some(Box::new(CTTrackChange::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"del" => {
                                f_del = Some(Box::new(CTTrackChange::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"moveFrom" => {
                                f_move_from =
                                    Some(Box::new(CTTrackChange::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"moveTo" => {
                                f_move_to =
                                    Some(Box::new(CTTrackChange::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            ins: f_ins,
            del: f_del,
            move_from: f_move_from,
            move_to: f_move_to,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTAltChunk {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_alt_chunk_pr = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"altChunkPr" => {
                                f_alt_chunk_pr =
                                    Some(Box::new(CTAltChunkPr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"altChunkPr" => {
                                f_alt_chunk_pr =
                                    Some(Box::new(CTAltChunkPr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            alt_chunk_pr: f_alt_chunk_pr,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTAltChunkPr {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_match_src = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"matchSrc" => {
                                f_match_src = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"matchSrc" => {
                                f_match_src = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            match_src: f_match_src,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTRubyAlign {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STRubyAlign> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTRubyPr {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_ruby_align: Option<Box<CTRubyAlign>> = None;
        let mut f_hps: Option<Box<CTHpsMeasure>> = None;
        let mut f_hps_raise: Option<Box<CTHpsMeasure>> = None;
        let mut f_hps_base_text: Option<Box<CTHpsMeasure>> = None;
        let mut f_lid: Option<Box<CTLang>> = None;
        let mut f_dirty = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"rubyAlign" => {
                                f_ruby_align =
                                    Some(Box::new(CTRubyAlign::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"hps" => {
                                f_hps = Some(Box::new(CTHpsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"hpsRaise" => {
                                f_hps_raise =
                                    Some(Box::new(CTHpsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"hpsBaseText" => {
                                f_hps_base_text =
                                    Some(Box::new(CTHpsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lid" => {
                                f_lid = Some(Box::new(CTLang::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dirty" => {
                                f_dirty = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"rubyAlign" => {
                                f_ruby_align =
                                    Some(Box::new(CTRubyAlign::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"hps" => {
                                f_hps = Some(Box::new(CTHpsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"hpsRaise" => {
                                f_hps_raise =
                                    Some(Box::new(CTHpsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"hpsBaseText" => {
                                f_hps_base_text =
                                    Some(Box::new(CTHpsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lid" => {
                                f_lid = Some(Box::new(CTLang::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dirty" => {
                                f_dirty = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            ruby_align: f_ruby_align
                .ok_or_else(|| ParseError::MissingAttribute("rubyAlign".to_string()))?,
            hps: f_hps.ok_or_else(|| ParseError::MissingAttribute("hps".to_string()))?,
            hps_raise: f_hps_raise
                .ok_or_else(|| ParseError::MissingAttribute("hpsRaise".to_string()))?,
            hps_base_text: f_hps_base_text
                .ok_or_else(|| ParseError::MissingAttribute("hpsBaseText".to_string()))?,
            lid: f_lid.ok_or_else(|| ParseError::MissingAttribute("lid".to_string()))?,
            dirty: f_dirty,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for RubyContent {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let tag = start_tag.local_name();
        match tag.as_ref() {
            b"r" => {
                let inner = Run::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::R(Box::new(inner)))
            }
            b"proofErr" => {
                let inner = CTProofErr::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::ProofErr(Box::new(inner)))
            }
            b"permStart" => {
                let inner = CTPermStart::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::PermStart(Box::new(inner)))
            }
            b"permEnd" => {
                let inner = CTPerm::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::PermEnd(Box::new(inner)))
            }
            b"bookmarkStart" => {
                let inner = Bookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::BookmarkStart(Box::new(inner)))
            }
            b"bookmarkEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::BookmarkEnd(Box::new(inner)))
            }
            b"moveFromRangeStart" => {
                let inner = CTMoveBookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveFromRangeStart(Box::new(inner)))
            }
            b"moveFromRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveFromRangeEnd(Box::new(inner)))
            }
            b"moveToRangeStart" => {
                let inner = CTMoveBookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveToRangeStart(Box::new(inner)))
            }
            b"moveToRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveToRangeEnd(Box::new(inner)))
            }
            b"commentRangeStart" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CommentRangeStart(Box::new(inner)))
            }
            b"commentRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CommentRangeEnd(Box::new(inner)))
            }
            b"customXmlInsRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlInsRangeStart(Box::new(inner)))
            }
            b"customXmlInsRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlInsRangeEnd(Box::new(inner)))
            }
            b"customXmlDelRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlDelRangeStart(Box::new(inner)))
            }
            b"customXmlDelRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlDelRangeEnd(Box::new(inner)))
            }
            b"customXmlMoveFromRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveFromRangeStart(Box::new(inner)))
            }
            b"customXmlMoveFromRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveFromRangeEnd(Box::new(inner)))
            }
            b"customXmlMoveToRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveToRangeStart(Box::new(inner)))
            }
            b"customXmlMoveToRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveToRangeEnd(Box::new(inner)))
            }
            b"ins" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Ins(Box::new(inner)))
            }
            b"del" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Del(Box::new(inner)))
            }
            b"moveFrom" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveFrom(Box::new(inner)))
            }
            b"moveTo" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveTo(Box::new(inner)))
            }
            _ => Err(ParseError::UnexpectedElement(
                String::from_utf8_lossy(start_tag.name().as_ref()).into_owned(),
            )),
        }
    }
}

impl FromXml for CTRubyContent {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_ruby_content = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"r"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo" => {
                                f_ruby_content
                                    .push(Box::new(RubyContent::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"r"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo" => {
                                f_ruby_content
                                    .push(Box::new(RubyContent::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            ruby_content: f_ruby_content,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTRuby {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_ruby_pr: Option<Box<CTRubyPr>> = None;
        let mut f_rt: Option<Box<CTRubyContent>> = None;
        let mut f_ruby_base: Option<Box<CTRubyContent>> = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"rubyPr" => {
                                f_ruby_pr = Some(Box::new(CTRubyPr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rt" => {
                                f_rt = Some(Box::new(CTRubyContent::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rubyBase" => {
                                f_ruby_base =
                                    Some(Box::new(CTRubyContent::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"rubyPr" => {
                                f_ruby_pr = Some(Box::new(CTRubyPr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rt" => {
                                f_rt = Some(Box::new(CTRubyContent::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rubyBase" => {
                                f_ruby_base =
                                    Some(Box::new(CTRubyContent::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            ruby_pr: f_ruby_pr.ok_or_else(|| ParseError::MissingAttribute("rubyPr".to_string()))?,
            rt: f_rt.ok_or_else(|| ParseError::MissingAttribute("rt".to_string()))?,
            ruby_base: f_ruby_base
                .ok_or_else(|| ParseError::MissingAttribute("rubyBase".to_string()))?,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTLock {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTSdtListItem {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_display_text = None;
        let mut f_value = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"displayText" => {
                    f_display_text = Some(val.into_owned());
                }
                b"value" => {
                    f_value = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            display_text: f_display_text,
            value: f_value,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTSdtDateMappingType {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTCalendarType {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTSdtDate {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_full_date = None;
        let mut f_date_format = None;
        let mut f_lid = None;
        let mut f_store_mapped_data_as = None;
        let mut f_calendar = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"fullDate" => {
                    f_full_date = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"dateFormat" => {
                                f_date_format =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lid" => {
                                f_lid = Some(Box::new(CTLang::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"storeMappedDataAs" => {
                                f_store_mapped_data_as = Some(Box::new(
                                    CTSdtDateMappingType::from_xml(reader, &e, false)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"calendar" => {
                                f_calendar =
                                    Some(Box::new(CTCalendarType::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"dateFormat" => {
                                f_date_format =
                                    Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lid" => {
                                f_lid = Some(Box::new(CTLang::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"storeMappedDataAs" => {
                                f_store_mapped_data_as = Some(Box::new(
                                    CTSdtDateMappingType::from_xml(reader, &e, true)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"calendar" => {
                                f_calendar =
                                    Some(Box::new(CTCalendarType::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            full_date: f_full_date,
            date_format: f_date_format,
            lid: f_lid,
            store_mapped_data_as: f_store_mapped_data_as,
            calendar: f_calendar,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTSdtComboBox {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_last_value = None;
        let mut f_list_item = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"lastValue" => {
                    f_last_value = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"listItem" => {
                                f_list_item
                                    .push(Box::new(CTSdtListItem::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"listItem" => {
                                f_list_item
                                    .push(Box::new(CTSdtListItem::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            last_value: f_last_value,
            list_item: f_list_item,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTSdtDocPart {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_doc_part_gallery = None;
        let mut f_doc_part_category = None;
        let mut f_doc_part_unique = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"docPartGallery" => {
                                f_doc_part_gallery =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"docPartCategory" => {
                                f_doc_part_category =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"docPartUnique" => {
                                f_doc_part_unique =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"docPartGallery" => {
                                f_doc_part_gallery =
                                    Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"docPartCategory" => {
                                f_doc_part_category =
                                    Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"docPartUnique" => {
                                f_doc_part_unique =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            doc_part_gallery: f_doc_part_gallery,
            doc_part_category: f_doc_part_category,
            doc_part_unique: f_doc_part_unique,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTSdtDropDownList {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_last_value = None;
        let mut f_list_item = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"lastValue" => {
                    f_last_value = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"listItem" => {
                                f_list_item
                                    .push(Box::new(CTSdtListItem::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"listItem" => {
                                f_list_item
                                    .push(Box::new(CTSdtListItem::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            last_value: f_last_value,
            list_item: f_list_item,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTSdtText {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_multi_line = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"multiLine" => {
                    f_multi_line = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            multi_line: f_multi_line,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTDataBinding {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_prefix_mappings = None;
        let mut f_xpath: Option<STString> = None;
        let mut f_store_item_i_d: Option<STString> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"prefixMappings" => {
                    f_prefix_mappings = Some(val.into_owned());
                }
                b"xpath" => {
                    f_xpath = Some(val.into_owned());
                }
                b"storeItemID" => {
                    f_store_item_i_d = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            prefix_mappings: f_prefix_mappings,
            xpath: f_xpath.ok_or_else(|| ParseError::MissingAttribute("xpath".to_string()))?,
            store_item_i_d: f_store_item_i_d
                .ok_or_else(|| ParseError::MissingAttribute("storeItemID".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTSdtPr {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_r_pr = None;
        let mut f_alias = None;
        let mut f_tag = None;
        let mut f_id = None;
        let mut f_lock = None;
        let mut f_placeholder = None;
        let mut f_temporary = None;
        let mut f_showing_plc_hdr = None;
        let mut f_data_binding = None;
        let mut f_label = None;
        let mut f_tab_index = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"rPr" => {
                                f_r_pr =
                                    Some(Box::new(RunProperties::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"alias" => {
                                f_alias = Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tag" => {
                                f_tag = Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"id" => {
                                f_id =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lock" => {
                                f_lock = Some(Box::new(CTLock::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"placeholder" => {
                                f_placeholder = Some(Box::new(Box::new(CTString::from_xml(
                                    reader, &e, false,
                                )?)));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"temporary" => {
                                f_temporary = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"showingPlcHdr" => {
                                f_showing_plc_hdr =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dataBinding" => {
                                f_data_binding =
                                    Some(Box::new(CTDataBinding::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"label" => {
                                f_label =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tabIndex" => {
                                f_tab_index = Some(Box::new(CTUnsignedDecimalNumber::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"rPr" => {
                                f_r_pr = Some(Box::new(RunProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"alias" => {
                                f_alias = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tag" => {
                                f_tag = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"id" => {
                                f_id = Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lock" => {
                                f_lock = Some(Box::new(CTLock::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"placeholder" => {
                                f_placeholder =
                                    Some(Box::new(Box::new(CTString::from_xml(reader, &e, true)?)));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"temporary" => {
                                f_temporary = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"showingPlcHdr" => {
                                f_showing_plc_hdr =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dataBinding" => {
                                f_data_binding =
                                    Some(Box::new(CTDataBinding::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"label" => {
                                f_label =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tabIndex" => {
                                f_tab_index = Some(Box::new(CTUnsignedDecimalNumber::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r_pr: f_r_pr,
            alias: f_alias,
            tag: f_tag,
            id: f_id,
            lock: f_lock,
            placeholder: f_placeholder,
            temporary: f_temporary,
            showing_plc_hdr: f_showing_plc_hdr,
            data_binding: f_data_binding,
            label: f_label,
            tab_index: f_tab_index,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTSdtEndPr {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    #[cfg(feature = "extra-children")]
                    Event::Start(e) => {
                        let elem = RawXmlElement::from_reader(reader, &e)?;
                        extra_children
                            .push(PositionedNode::new(child_idx, RawXmlNode::Element(elem)));
                        child_idx += 1;
                    }
                    #[cfg(not(feature = "extra-children"))]
                    Event::Start(_) => {
                        skip_element(reader)?;
                    }
                    #[cfg(feature = "extra-children")]
                    Event::Empty(e) => {
                        let elem = RawXmlElement::from_empty(&e);
                        extra_children
                            .push(PositionedNode::new(child_idx, RawXmlNode::Element(elem)));
                        child_idx += 1;
                    }
                    #[cfg(not(feature = "extra-children"))]
                    Event::Empty(_) => {}
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }
        Ok(Self {
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for RunContentChoice {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let tag = start_tag.local_name();
        match tag.as_ref() {
            b"customXml" => {
                let inner = CTCustomXmlRun::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXml(Box::new(inner)))
            }
            b"smartTag" => {
                let inner = CTSmartTagRun::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::SmartTag(Box::new(inner)))
            }
            b"sdt" => {
                let inner = CTSdtRun::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Sdt(Box::new(inner)))
            }
            b"dir" => {
                let inner = CTDirContentRun::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Dir(Box::new(inner)))
            }
            b"bdo" => {
                let inner = CTBdoContentRun::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Bdo(Box::new(inner)))
            }
            b"r" => {
                let inner = Run::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::R(Box::new(inner)))
            }
            b"proofErr" => {
                let inner = CTProofErr::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::ProofErr(Box::new(inner)))
            }
            b"permStart" => {
                let inner = CTPermStart::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::PermStart(Box::new(inner)))
            }
            b"permEnd" => {
                let inner = CTPerm::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::PermEnd(Box::new(inner)))
            }
            b"bookmarkStart" => {
                let inner = Bookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::BookmarkStart(Box::new(inner)))
            }
            b"bookmarkEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::BookmarkEnd(Box::new(inner)))
            }
            b"moveFromRangeStart" => {
                let inner = CTMoveBookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveFromRangeStart(Box::new(inner)))
            }
            b"moveFromRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveFromRangeEnd(Box::new(inner)))
            }
            b"moveToRangeStart" => {
                let inner = CTMoveBookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveToRangeStart(Box::new(inner)))
            }
            b"moveToRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveToRangeEnd(Box::new(inner)))
            }
            b"commentRangeStart" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CommentRangeStart(Box::new(inner)))
            }
            b"commentRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CommentRangeEnd(Box::new(inner)))
            }
            b"customXmlInsRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlInsRangeStart(Box::new(inner)))
            }
            b"customXmlInsRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlInsRangeEnd(Box::new(inner)))
            }
            b"customXmlDelRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlDelRangeStart(Box::new(inner)))
            }
            b"customXmlDelRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlDelRangeEnd(Box::new(inner)))
            }
            b"customXmlMoveFromRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveFromRangeStart(Box::new(inner)))
            }
            b"customXmlMoveFromRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveFromRangeEnd(Box::new(inner)))
            }
            b"customXmlMoveToRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveToRangeStart(Box::new(inner)))
            }
            b"customXmlMoveToRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveToRangeEnd(Box::new(inner)))
            }
            b"ins" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Ins(Box::new(inner)))
            }
            b"del" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Del(Box::new(inner)))
            }
            b"moveFrom" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveFrom(Box::new(inner)))
            }
            b"moveTo" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveTo(Box::new(inner)))
            }
            _ => Err(ParseError::UnexpectedElement(
                String::from_utf8_lossy(start_tag.name().as_ref()).into_owned(),
            )),
        }
    }
}

impl FromXml for CTDirContentRun {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value = None;
        let mut f_paragraph_content = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"customXml"
                            | b"smartTag"
                            | b"sdt"
                            | b"dir"
                            | b"bdo"
                            | b"r"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo"
                            | b"fldSimple"
                            | b"hyperlink"
                            | b"subDoc" => {
                                f_paragraph_content
                                    .push(Box::new(ParagraphContent::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"customXml"
                            | b"smartTag"
                            | b"sdt"
                            | b"dir"
                            | b"bdo"
                            | b"r"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo"
                            | b"fldSimple"
                            | b"hyperlink"
                            | b"subDoc" => {
                                f_paragraph_content
                                    .push(Box::new(ParagraphContent::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value,
            paragraph_content: f_paragraph_content,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTBdoContentRun {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value = None;
        let mut f_paragraph_content = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"customXml"
                            | b"smartTag"
                            | b"sdt"
                            | b"dir"
                            | b"bdo"
                            | b"r"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo"
                            | b"fldSimple"
                            | b"hyperlink"
                            | b"subDoc" => {
                                f_paragraph_content
                                    .push(Box::new(ParagraphContent::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"customXml"
                            | b"smartTag"
                            | b"sdt"
                            | b"dir"
                            | b"bdo"
                            | b"r"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo"
                            | b"fldSimple"
                            | b"hyperlink"
                            | b"subDoc" => {
                                f_paragraph_content
                                    .push(Box::new(ParagraphContent::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value,
            paragraph_content: f_paragraph_content,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTSdtContentRun {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_paragraph_content = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"customXml"
                            | b"smartTag"
                            | b"sdt"
                            | b"dir"
                            | b"bdo"
                            | b"r"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo"
                            | b"fldSimple"
                            | b"hyperlink"
                            | b"subDoc" => {
                                f_paragraph_content
                                    .push(Box::new(ParagraphContent::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"customXml"
                            | b"smartTag"
                            | b"sdt"
                            | b"dir"
                            | b"bdo"
                            | b"r"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo"
                            | b"fldSimple"
                            | b"hyperlink"
                            | b"subDoc" => {
                                f_paragraph_content
                                    .push(Box::new(ParagraphContent::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            paragraph_content: f_paragraph_content,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for BlockContentChoice {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let tag = start_tag.local_name();
        match tag.as_ref() {
            b"customXml" => {
                let inner = CTCustomXmlBlock::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXml(Box::new(inner)))
            }
            b"sdt" => {
                let inner = CTSdtBlock::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Sdt(Box::new(inner)))
            }
            b"p" => {
                let inner = Paragraph::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::P(Box::new(inner)))
            }
            b"tbl" => {
                let inner = Table::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Tbl(Box::new(inner)))
            }
            b"proofErr" => {
                let inner = CTProofErr::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::ProofErr(Box::new(inner)))
            }
            b"permStart" => {
                let inner = CTPermStart::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::PermStart(Box::new(inner)))
            }
            b"permEnd" => {
                let inner = CTPerm::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::PermEnd(Box::new(inner)))
            }
            b"bookmarkStart" => {
                let inner = Bookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::BookmarkStart(Box::new(inner)))
            }
            b"bookmarkEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::BookmarkEnd(Box::new(inner)))
            }
            b"moveFromRangeStart" => {
                let inner = CTMoveBookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveFromRangeStart(Box::new(inner)))
            }
            b"moveFromRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveFromRangeEnd(Box::new(inner)))
            }
            b"moveToRangeStart" => {
                let inner = CTMoveBookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveToRangeStart(Box::new(inner)))
            }
            b"moveToRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveToRangeEnd(Box::new(inner)))
            }
            b"commentRangeStart" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CommentRangeStart(Box::new(inner)))
            }
            b"commentRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CommentRangeEnd(Box::new(inner)))
            }
            b"customXmlInsRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlInsRangeStart(Box::new(inner)))
            }
            b"customXmlInsRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlInsRangeEnd(Box::new(inner)))
            }
            b"customXmlDelRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlDelRangeStart(Box::new(inner)))
            }
            b"customXmlDelRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlDelRangeEnd(Box::new(inner)))
            }
            b"customXmlMoveFromRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveFromRangeStart(Box::new(inner)))
            }
            b"customXmlMoveFromRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveFromRangeEnd(Box::new(inner)))
            }
            b"customXmlMoveToRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveToRangeStart(Box::new(inner)))
            }
            b"customXmlMoveToRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveToRangeEnd(Box::new(inner)))
            }
            b"ins" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Ins(Box::new(inner)))
            }
            b"del" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Del(Box::new(inner)))
            }
            b"moveFrom" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveFrom(Box::new(inner)))
            }
            b"moveTo" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveTo(Box::new(inner)))
            }
            _ => Err(ParseError::UnexpectedElement(
                String::from_utf8_lossy(start_tag.name().as_ref()).into_owned(),
            )),
        }
    }
}

impl FromXml for CTSdtContentBlock {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_block_content = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"customXml"
                            | b"sdt"
                            | b"p"
                            | b"tbl"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo" => {
                                f_block_content.push(Box::new(BlockContentChoice::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"customXml"
                            | b"sdt"
                            | b"p"
                            | b"tbl"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo" => {
                                f_block_content.push(Box::new(BlockContentChoice::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            block_content: f_block_content,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for RowContent {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let tag = start_tag.local_name();
        match tag.as_ref() {
            b"tr" => {
                let inner = CTRow::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Tr(Box::new(inner)))
            }
            b"customXml" => {
                let inner = CTCustomXmlRow::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXml(Box::new(inner)))
            }
            b"sdt" => {
                let inner = CTSdtRow::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Sdt(Box::new(inner)))
            }
            b"proofErr" => {
                let inner = CTProofErr::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::ProofErr(Box::new(inner)))
            }
            b"permStart" => {
                let inner = CTPermStart::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::PermStart(Box::new(inner)))
            }
            b"permEnd" => {
                let inner = CTPerm::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::PermEnd(Box::new(inner)))
            }
            b"bookmarkStart" => {
                let inner = Bookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::BookmarkStart(Box::new(inner)))
            }
            b"bookmarkEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::BookmarkEnd(Box::new(inner)))
            }
            b"moveFromRangeStart" => {
                let inner = CTMoveBookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveFromRangeStart(Box::new(inner)))
            }
            b"moveFromRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveFromRangeEnd(Box::new(inner)))
            }
            b"moveToRangeStart" => {
                let inner = CTMoveBookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveToRangeStart(Box::new(inner)))
            }
            b"moveToRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveToRangeEnd(Box::new(inner)))
            }
            b"commentRangeStart" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CommentRangeStart(Box::new(inner)))
            }
            b"commentRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CommentRangeEnd(Box::new(inner)))
            }
            b"customXmlInsRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlInsRangeStart(Box::new(inner)))
            }
            b"customXmlInsRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlInsRangeEnd(Box::new(inner)))
            }
            b"customXmlDelRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlDelRangeStart(Box::new(inner)))
            }
            b"customXmlDelRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlDelRangeEnd(Box::new(inner)))
            }
            b"customXmlMoveFromRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveFromRangeStart(Box::new(inner)))
            }
            b"customXmlMoveFromRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveFromRangeEnd(Box::new(inner)))
            }
            b"customXmlMoveToRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveToRangeStart(Box::new(inner)))
            }
            b"customXmlMoveToRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveToRangeEnd(Box::new(inner)))
            }
            b"ins" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Ins(Box::new(inner)))
            }
            b"del" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Del(Box::new(inner)))
            }
            b"moveFrom" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveFrom(Box::new(inner)))
            }
            b"moveTo" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveTo(Box::new(inner)))
            }
            _ => Err(ParseError::UnexpectedElement(
                String::from_utf8_lossy(start_tag.name().as_ref()).into_owned(),
            )),
        }
    }
}

impl FromXml for CTSdtContentRow {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_rows = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"tr"
                            | b"customXml"
                            | b"sdt"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo" => {
                                f_rows.push(Box::new(RowContent::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"tr"
                            | b"customXml"
                            | b"sdt"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo" => {
                                f_rows.push(Box::new(RowContent::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            rows: f_rows,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CellContent {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let tag = start_tag.local_name();
        match tag.as_ref() {
            b"tc" => {
                let inner = TableCell::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Tc(Box::new(inner)))
            }
            b"customXml" => {
                let inner = CTCustomXmlCell::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXml(Box::new(inner)))
            }
            b"sdt" => {
                let inner = CTSdtCell::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Sdt(Box::new(inner)))
            }
            b"proofErr" => {
                let inner = CTProofErr::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::ProofErr(Box::new(inner)))
            }
            b"permStart" => {
                let inner = CTPermStart::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::PermStart(Box::new(inner)))
            }
            b"permEnd" => {
                let inner = CTPerm::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::PermEnd(Box::new(inner)))
            }
            b"bookmarkStart" => {
                let inner = Bookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::BookmarkStart(Box::new(inner)))
            }
            b"bookmarkEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::BookmarkEnd(Box::new(inner)))
            }
            b"moveFromRangeStart" => {
                let inner = CTMoveBookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveFromRangeStart(Box::new(inner)))
            }
            b"moveFromRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveFromRangeEnd(Box::new(inner)))
            }
            b"moveToRangeStart" => {
                let inner = CTMoveBookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveToRangeStart(Box::new(inner)))
            }
            b"moveToRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveToRangeEnd(Box::new(inner)))
            }
            b"commentRangeStart" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CommentRangeStart(Box::new(inner)))
            }
            b"commentRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CommentRangeEnd(Box::new(inner)))
            }
            b"customXmlInsRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlInsRangeStart(Box::new(inner)))
            }
            b"customXmlInsRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlInsRangeEnd(Box::new(inner)))
            }
            b"customXmlDelRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlDelRangeStart(Box::new(inner)))
            }
            b"customXmlDelRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlDelRangeEnd(Box::new(inner)))
            }
            b"customXmlMoveFromRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveFromRangeStart(Box::new(inner)))
            }
            b"customXmlMoveFromRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveFromRangeEnd(Box::new(inner)))
            }
            b"customXmlMoveToRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveToRangeStart(Box::new(inner)))
            }
            b"customXmlMoveToRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveToRangeEnd(Box::new(inner)))
            }
            b"ins" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Ins(Box::new(inner)))
            }
            b"del" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Del(Box::new(inner)))
            }
            b"moveFrom" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveFrom(Box::new(inner)))
            }
            b"moveTo" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveTo(Box::new(inner)))
            }
            _ => Err(ParseError::UnexpectedElement(
                String::from_utf8_lossy(start_tag.name().as_ref()).into_owned(),
            )),
        }
    }
}

impl FromXml for CTSdtContentCell {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_cells = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"tc"
                            | b"customXml"
                            | b"sdt"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo" => {
                                f_cells.push(Box::new(CellContent::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"tc"
                            | b"customXml"
                            | b"sdt"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo" => {
                                f_cells.push(Box::new(CellContent::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            cells: f_cells,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTSdtBlock {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_sdt_pr = None;
        let mut f_sdt_end_pr = None;
        let mut f_sdt_content = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"sdtPr" => {
                                f_sdt_pr = Some(Box::new(CTSdtPr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sdtEndPr" => {
                                f_sdt_end_pr =
                                    Some(Box::new(CTSdtEndPr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sdtContent" => {
                                f_sdt_content =
                                    Some(Box::new(CTSdtContentBlock::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"sdtPr" => {
                                f_sdt_pr = Some(Box::new(CTSdtPr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sdtEndPr" => {
                                f_sdt_end_pr =
                                    Some(Box::new(CTSdtEndPr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sdtContent" => {
                                f_sdt_content =
                                    Some(Box::new(CTSdtContentBlock::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            sdt_pr: f_sdt_pr,
            sdt_end_pr: f_sdt_end_pr,
            sdt_content: f_sdt_content,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTSdtRun {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_sdt_pr = None;
        let mut f_sdt_end_pr = None;
        let mut f_sdt_content = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"sdtPr" => {
                                f_sdt_pr = Some(Box::new(CTSdtPr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sdtEndPr" => {
                                f_sdt_end_pr =
                                    Some(Box::new(CTSdtEndPr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sdtContent" => {
                                f_sdt_content =
                                    Some(Box::new(CTSdtContentRun::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"sdtPr" => {
                                f_sdt_pr = Some(Box::new(CTSdtPr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sdtEndPr" => {
                                f_sdt_end_pr =
                                    Some(Box::new(CTSdtEndPr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sdtContent" => {
                                f_sdt_content =
                                    Some(Box::new(CTSdtContentRun::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            sdt_pr: f_sdt_pr,
            sdt_end_pr: f_sdt_end_pr,
            sdt_content: f_sdt_content,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTSdtCell {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_sdt_pr = None;
        let mut f_sdt_end_pr = None;
        let mut f_sdt_content = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"sdtPr" => {
                                f_sdt_pr = Some(Box::new(CTSdtPr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sdtEndPr" => {
                                f_sdt_end_pr =
                                    Some(Box::new(CTSdtEndPr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sdtContent" => {
                                f_sdt_content =
                                    Some(Box::new(CTSdtContentCell::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"sdtPr" => {
                                f_sdt_pr = Some(Box::new(CTSdtPr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sdtEndPr" => {
                                f_sdt_end_pr =
                                    Some(Box::new(CTSdtEndPr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sdtContent" => {
                                f_sdt_content =
                                    Some(Box::new(CTSdtContentCell::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            sdt_pr: f_sdt_pr,
            sdt_end_pr: f_sdt_end_pr,
            sdt_content: f_sdt_content,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTSdtRow {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_sdt_pr = None;
        let mut f_sdt_end_pr = None;
        let mut f_sdt_content = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"sdtPr" => {
                                f_sdt_pr = Some(Box::new(CTSdtPr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sdtEndPr" => {
                                f_sdt_end_pr =
                                    Some(Box::new(CTSdtEndPr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sdtContent" => {
                                f_sdt_content =
                                    Some(Box::new(CTSdtContentRow::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"sdtPr" => {
                                f_sdt_pr = Some(Box::new(CTSdtPr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sdtEndPr" => {
                                f_sdt_end_pr =
                                    Some(Box::new(CTSdtEndPr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sdtContent" => {
                                f_sdt_content =
                                    Some(Box::new(CTSdtContentRow::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            sdt_pr: f_sdt_pr,
            sdt_end_pr: f_sdt_end_pr,
            sdt_content: f_sdt_content,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTAttr {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_uri = None;
        let mut f_name: Option<STString> = None;
        let mut f_value: Option<STString> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"uri" => {
                    f_uri = Some(val.into_owned());
                }
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            uri: f_uri,
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTCustomXmlRun {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_uri = None;
        let mut f_element: Option<STXmlName> = None;
        let mut f_custom_xml_pr = None;
        let mut f_paragraph_content = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"uri" => {
                    f_uri = Some(val.into_owned());
                }
                b"element" => {
                    f_element = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"customXmlPr" => {
                                f_custom_xml_pr =
                                    Some(Box::new(CTCustomXmlPr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"customXml"
                            | b"smartTag"
                            | b"sdt"
                            | b"dir"
                            | b"bdo"
                            | b"r"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo"
                            | b"fldSimple"
                            | b"hyperlink"
                            | b"subDoc" => {
                                f_paragraph_content
                                    .push(Box::new(ParagraphContent::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"customXmlPr" => {
                                f_custom_xml_pr =
                                    Some(Box::new(CTCustomXmlPr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"customXml"
                            | b"smartTag"
                            | b"sdt"
                            | b"dir"
                            | b"bdo"
                            | b"r"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo"
                            | b"fldSimple"
                            | b"hyperlink"
                            | b"subDoc" => {
                                f_paragraph_content
                                    .push(Box::new(ParagraphContent::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            uri: f_uri,
            element: f_element
                .ok_or_else(|| ParseError::MissingAttribute("element".to_string()))?,
            custom_xml_pr: f_custom_xml_pr,
            paragraph_content: f_paragraph_content,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTSmartTagRun {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_uri = None;
        let mut f_element: Option<STXmlName> = None;
        let mut f_smart_tag_pr = None;
        let mut f_paragraph_content = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"uri" => {
                    f_uri = Some(val.into_owned());
                }
                b"element" => {
                    f_element = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"smartTagPr" => {
                                f_smart_tag_pr =
                                    Some(Box::new(CTSmartTagPr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"customXml"
                            | b"smartTag"
                            | b"sdt"
                            | b"dir"
                            | b"bdo"
                            | b"r"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo"
                            | b"fldSimple"
                            | b"hyperlink"
                            | b"subDoc" => {
                                f_paragraph_content
                                    .push(Box::new(ParagraphContent::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"smartTagPr" => {
                                f_smart_tag_pr =
                                    Some(Box::new(CTSmartTagPr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"customXml"
                            | b"smartTag"
                            | b"sdt"
                            | b"dir"
                            | b"bdo"
                            | b"r"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo"
                            | b"fldSimple"
                            | b"hyperlink"
                            | b"subDoc" => {
                                f_paragraph_content
                                    .push(Box::new(ParagraphContent::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            uri: f_uri,
            element: f_element
                .ok_or_else(|| ParseError::MissingAttribute("element".to_string()))?,
            smart_tag_pr: f_smart_tag_pr,
            paragraph_content: f_paragraph_content,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTCustomXmlBlock {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_uri = None;
        let mut f_element: Option<STXmlName> = None;
        let mut f_custom_xml_pr = None;
        let mut f_block_content = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"uri" => {
                    f_uri = Some(val.into_owned());
                }
                b"element" => {
                    f_element = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"customXmlPr" => {
                                f_custom_xml_pr =
                                    Some(Box::new(CTCustomXmlPr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"customXml"
                            | b"sdt"
                            | b"p"
                            | b"tbl"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo" => {
                                f_block_content.push(Box::new(BlockContentChoice::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"customXmlPr" => {
                                f_custom_xml_pr =
                                    Some(Box::new(CTCustomXmlPr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"customXml"
                            | b"sdt"
                            | b"p"
                            | b"tbl"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo" => {
                                f_block_content.push(Box::new(BlockContentChoice::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            uri: f_uri,
            element: f_element
                .ok_or_else(|| ParseError::MissingAttribute("element".to_string()))?,
            custom_xml_pr: f_custom_xml_pr,
            block_content: f_block_content,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTCustomXmlPr {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_placeholder = None;
        let mut f_attr = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"placeholder" => {
                                f_placeholder =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"attr" => {
                                f_attr.push(Box::new(CTAttr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"placeholder" => {
                                f_placeholder =
                                    Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"attr" => {
                                f_attr.push(Box::new(CTAttr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            placeholder: f_placeholder,
            attr: f_attr,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTCustomXmlRow {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_uri = None;
        let mut f_element: Option<STXmlName> = None;
        let mut f_custom_xml_pr = None;
        let mut f_rows = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"uri" => {
                    f_uri = Some(val.into_owned());
                }
                b"element" => {
                    f_element = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"customXmlPr" => {
                                f_custom_xml_pr =
                                    Some(Box::new(CTCustomXmlPr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tr"
                            | b"customXml"
                            | b"sdt"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo" => {
                                f_rows.push(Box::new(RowContent::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"customXmlPr" => {
                                f_custom_xml_pr =
                                    Some(Box::new(CTCustomXmlPr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tr"
                            | b"customXml"
                            | b"sdt"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo" => {
                                f_rows.push(Box::new(RowContent::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            uri: f_uri,
            element: f_element
                .ok_or_else(|| ParseError::MissingAttribute("element".to_string()))?,
            custom_xml_pr: f_custom_xml_pr,
            rows: f_rows,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTCustomXmlCell {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_uri = None;
        let mut f_element: Option<STXmlName> = None;
        let mut f_custom_xml_pr = None;
        let mut f_cells = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"uri" => {
                    f_uri = Some(val.into_owned());
                }
                b"element" => {
                    f_element = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"customXmlPr" => {
                                f_custom_xml_pr =
                                    Some(Box::new(CTCustomXmlPr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tc"
                            | b"customXml"
                            | b"sdt"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo" => {
                                f_cells.push(Box::new(CellContent::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"customXmlPr" => {
                                f_custom_xml_pr =
                                    Some(Box::new(CTCustomXmlPr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tc"
                            | b"customXml"
                            | b"sdt"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo" => {
                                f_cells.push(Box::new(CellContent::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            uri: f_uri,
            element: f_element
                .ok_or_else(|| ParseError::MissingAttribute("element".to_string()))?,
            custom_xml_pr: f_custom_xml_pr,
            cells: f_cells,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTSmartTagPr {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_attr = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"attr" => {
                                f_attr.push(Box::new(CTAttr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"attr" => {
                                f_attr.push(Box::new(CTAttr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            attr: f_attr,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for ParagraphContent {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let tag = start_tag.local_name();
        match tag.as_ref() {
            b"customXml" => {
                let inner = CTCustomXmlRun::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXml(Box::new(inner)))
            }
            b"smartTag" => {
                let inner = CTSmartTagRun::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::SmartTag(Box::new(inner)))
            }
            b"sdt" => {
                let inner = CTSdtRun::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Sdt(Box::new(inner)))
            }
            b"dir" => {
                let inner = CTDirContentRun::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Dir(Box::new(inner)))
            }
            b"bdo" => {
                let inner = CTBdoContentRun::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Bdo(Box::new(inner)))
            }
            b"r" => {
                let inner = Run::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::R(Box::new(inner)))
            }
            b"proofErr" => {
                let inner = CTProofErr::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::ProofErr(Box::new(inner)))
            }
            b"permStart" => {
                let inner = CTPermStart::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::PermStart(Box::new(inner)))
            }
            b"permEnd" => {
                let inner = CTPerm::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::PermEnd(Box::new(inner)))
            }
            b"bookmarkStart" => {
                let inner = Bookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::BookmarkStart(Box::new(inner)))
            }
            b"bookmarkEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::BookmarkEnd(Box::new(inner)))
            }
            b"moveFromRangeStart" => {
                let inner = CTMoveBookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveFromRangeStart(Box::new(inner)))
            }
            b"moveFromRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveFromRangeEnd(Box::new(inner)))
            }
            b"moveToRangeStart" => {
                let inner = CTMoveBookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveToRangeStart(Box::new(inner)))
            }
            b"moveToRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveToRangeEnd(Box::new(inner)))
            }
            b"commentRangeStart" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CommentRangeStart(Box::new(inner)))
            }
            b"commentRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CommentRangeEnd(Box::new(inner)))
            }
            b"customXmlInsRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlInsRangeStart(Box::new(inner)))
            }
            b"customXmlInsRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlInsRangeEnd(Box::new(inner)))
            }
            b"customXmlDelRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlDelRangeStart(Box::new(inner)))
            }
            b"customXmlDelRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlDelRangeEnd(Box::new(inner)))
            }
            b"customXmlMoveFromRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveFromRangeStart(Box::new(inner)))
            }
            b"customXmlMoveFromRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveFromRangeEnd(Box::new(inner)))
            }
            b"customXmlMoveToRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveToRangeStart(Box::new(inner)))
            }
            b"customXmlMoveToRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveToRangeEnd(Box::new(inner)))
            }
            b"ins" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Ins(Box::new(inner)))
            }
            b"del" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Del(Box::new(inner)))
            }
            b"moveFrom" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveFrom(Box::new(inner)))
            }
            b"moveTo" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveTo(Box::new(inner)))
            }
            b"fldSimple" => {
                let inner = CTSimpleField::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::FldSimple(Box::new(inner)))
            }
            b"hyperlink" => {
                let inner = Hyperlink::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Hyperlink(Box::new(inner)))
            }
            b"subDoc" => {
                let inner = CTRel::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::SubDoc(Box::new(inner)))
            }
            _ => Err(ParseError::UnexpectedElement(
                String::from_utf8_lossy(start_tag.name().as_ref()).into_owned(),
            )),
        }
    }
}

impl FromXml for Paragraph {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_rsid_r_pr = None;
        let mut f_rsid_r = None;
        let mut f_rsid_del = None;
        let mut f_rsid_p = None;
        let mut f_rsid_r_default = None;
        #[cfg(feature = "wml-styling")]
        let mut f_p_pr = None;
        let mut f_paragraph_content = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"rsidRPr" => {
                    f_rsid_r_pr = decode_hex(&val);
                }
                b"rsidR" => {
                    f_rsid_r = decode_hex(&val);
                }
                b"rsidDel" => {
                    f_rsid_del = decode_hex(&val);
                }
                b"rsidP" => {
                    f_rsid_p = decode_hex(&val);
                }
                b"rsidRDefault" => {
                    f_rsid_r_default = decode_hex(&val);
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "wml-styling")]
                            b"pPr" => {
                                f_p_pr = Some(Box::new(ParagraphProperties::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"customXml"
                            | b"smartTag"
                            | b"sdt"
                            | b"dir"
                            | b"bdo"
                            | b"r"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo"
                            | b"fldSimple"
                            | b"hyperlink"
                            | b"subDoc" => {
                                f_paragraph_content
                                    .push(Box::new(ParagraphContent::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "wml-styling")]
                            b"pPr" => {
                                f_p_pr = Some(Box::new(ParagraphProperties::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"customXml"
                            | b"smartTag"
                            | b"sdt"
                            | b"dir"
                            | b"bdo"
                            | b"r"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo"
                            | b"fldSimple"
                            | b"hyperlink"
                            | b"subDoc" => {
                                f_paragraph_content
                                    .push(Box::new(ParagraphContent::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            rsid_r_pr: f_rsid_r_pr,
            rsid_r: f_rsid_r,
            rsid_del: f_rsid_del,
            rsid_p: f_rsid_p,
            rsid_r_default: f_rsid_r_default,
            #[cfg(feature = "wml-styling")]
            p_pr: f_p_pr,
            paragraph_content: f_paragraph_content,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTHeight {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value = None;
        let mut f_h_rule = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                b"hRule" => {
                    f_h_rule = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value,
            h_rule: f_h_rule,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTTblWidth {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_width = None;
        let mut f_type = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"w" => {
                    f_width = Some(val.into_owned());
                }
                b"type" => {
                    f_type = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            width: f_width,
            r#type: f_type,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for TableGridColumn {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_width = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"w" => {
                    f_width = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            width: f_width,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTTblGridBase {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_grid_col = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"gridCol" => {
                                f_grid_col
                                    .push(Box::new(TableGridColumn::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"gridCol" => {
                                f_grid_col
                                    .push(Box::new(TableGridColumn::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            grid_col: f_grid_col,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for TableGrid {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_grid_col = Vec::new();
        let mut f_tbl_grid_change = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"gridCol" => {
                                f_grid_col
                                    .push(Box::new(TableGridColumn::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblGridChange" => {
                                f_tbl_grid_change =
                                    Some(Box::new(CTTblGridChange::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"gridCol" => {
                                f_grid_col
                                    .push(Box::new(TableGridColumn::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblGridChange" => {
                                f_tbl_grid_change =
                                    Some(Box::new(CTTblGridChange::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            grid_col: f_grid_col,
            tbl_grid_change: f_tbl_grid_change,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTTcBorders {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_top = None;
        let mut f_start = None;
        let mut f_left = None;
        let mut f_bottom = None;
        let mut f_end = None;
        let mut f_right = None;
        let mut f_inside_h = None;
        let mut f_inside_v = None;
        let mut f_tl2br = None;
        let mut f_tr2bl = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"top" => {
                                f_top = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"start" => {
                                f_start = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"left" => {
                                f_left = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bottom" => {
                                f_bottom = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"end" => {
                                f_end = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"right" => {
                                f_right = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"insideH" => {
                                f_inside_h = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"insideV" => {
                                f_inside_v = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tl2br" => {
                                f_tl2br = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tr2bl" => {
                                f_tr2bl = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"top" => {
                                f_top = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"start" => {
                                f_start = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"left" => {
                                f_left = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bottom" => {
                                f_bottom = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"end" => {
                                f_end = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"right" => {
                                f_right = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"insideH" => {
                                f_inside_h = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"insideV" => {
                                f_inside_v = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tl2br" => {
                                f_tl2br = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tr2bl" => {
                                f_tr2bl = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            top: f_top,
            start: f_start,
            left: f_left,
            bottom: f_bottom,
            end: f_end,
            right: f_right,
            inside_h: f_inside_h,
            inside_v: f_inside_v,
            tl2br: f_tl2br,
            tr2bl: f_tr2bl,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTTcMar {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_top = None;
        let mut f_start = None;
        let mut f_left = None;
        let mut f_bottom = None;
        let mut f_end = None;
        let mut f_right = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"top" => {
                                f_top = Some(Box::new(CTTblWidth::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"start" => {
                                f_start = Some(Box::new(CTTblWidth::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"left" => {
                                f_left = Some(Box::new(CTTblWidth::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bottom" => {
                                f_bottom = Some(Box::new(CTTblWidth::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"end" => {
                                f_end = Some(Box::new(CTTblWidth::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"right" => {
                                f_right = Some(Box::new(CTTblWidth::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"top" => {
                                f_top = Some(Box::new(CTTblWidth::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"start" => {
                                f_start = Some(Box::new(CTTblWidth::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"left" => {
                                f_left = Some(Box::new(CTTblWidth::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bottom" => {
                                f_bottom = Some(Box::new(CTTblWidth::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"end" => {
                                f_end = Some(Box::new(CTTblWidth::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"right" => {
                                f_right = Some(Box::new(CTTblWidth::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            top: f_top,
            start: f_start,
            left: f_left,
            bottom: f_bottom,
            end: f_end,
            right: f_right,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTVMerge {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTHMerge {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTTcPrBase {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_cnf_style = None;
        let mut f_tc_w = None;
        let mut f_grid_span = None;
        let mut f_horizontal_merge = None;
        let mut f_vertical_merge = None;
        let mut f_tc_borders = None;
        let mut f_shading = None;
        let mut f_no_wrap = None;
        let mut f_tc_mar = None;
        let mut f_text_direction = None;
        let mut f_tc_fit_text = None;
        let mut f_v_align = None;
        let mut f_hide_mark = None;
        let mut f_headers = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"cnfStyle" => {
                                f_cnf_style = Some(Box::new(CTCnf::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tcW" => {
                                f_tc_w = Some(Box::new(CTTblWidth::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"gridSpan" => {
                                f_grid_span =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"hMerge" => {
                                f_horizontal_merge =
                                    Some(Box::new(CTHMerge::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vMerge" => {
                                f_vertical_merge =
                                    Some(Box::new(CTVMerge::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tcBorders" => {
                                f_tc_borders =
                                    Some(Box::new(CTTcBorders::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noWrap" => {
                                f_no_wrap = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tcMar" => {
                                f_tc_mar = Some(Box::new(CTTcMar::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"textDirection" => {
                                f_text_direction =
                                    Some(Box::new(CTTextDirection::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tcFitText" => {
                                f_tc_fit_text =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vAlign" => {
                                f_v_align =
                                    Some(Box::new(CTVerticalJc::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"hideMark" => {
                                f_hide_mark = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"headers" => {
                                f_headers = Some(Box::new(CTHeaders::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"cnfStyle" => {
                                f_cnf_style = Some(Box::new(CTCnf::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tcW" => {
                                f_tc_w = Some(Box::new(CTTblWidth::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"gridSpan" => {
                                f_grid_span =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"hMerge" => {
                                f_horizontal_merge =
                                    Some(Box::new(CTHMerge::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vMerge" => {
                                f_vertical_merge =
                                    Some(Box::new(CTVMerge::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tcBorders" => {
                                f_tc_borders =
                                    Some(Box::new(CTTcBorders::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noWrap" => {
                                f_no_wrap = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tcMar" => {
                                f_tc_mar = Some(Box::new(CTTcMar::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"textDirection" => {
                                f_text_direction =
                                    Some(Box::new(CTTextDirection::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tcFitText" => {
                                f_tc_fit_text =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vAlign" => {
                                f_v_align =
                                    Some(Box::new(CTVerticalJc::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"hideMark" => {
                                f_hide_mark = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"headers" => {
                                f_headers = Some(Box::new(CTHeaders::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            cnf_style: f_cnf_style,
            tc_w: f_tc_w,
            grid_span: f_grid_span,
            horizontal_merge: f_horizontal_merge,
            vertical_merge: f_vertical_merge,
            tc_borders: f_tc_borders,
            shading: f_shading,
            no_wrap: f_no_wrap,
            tc_mar: f_tc_mar,
            text_direction: f_text_direction,
            tc_fit_text: f_tc_fit_text,
            v_align: f_v_align,
            hide_mark: f_hide_mark,
            headers: f_headers,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for TableCellProperties {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "wml-styling")]
        let mut f_cnf_style = None;
        #[cfg(feature = "wml-tables")]
        let mut f_tc_w = None;
        #[cfg(feature = "wml-tables")]
        let mut f_grid_span = None;
        #[cfg(feature = "wml-tables")]
        let mut f_horizontal_merge = None;
        #[cfg(feature = "wml-tables")]
        let mut f_vertical_merge = None;
        #[cfg(feature = "wml-tables")]
        let mut f_tc_borders = None;
        #[cfg(feature = "wml-tables")]
        let mut f_shading = None;
        #[cfg(feature = "wml-tables")]
        let mut f_no_wrap = None;
        #[cfg(feature = "wml-tables")]
        let mut f_tc_mar = None;
        #[cfg(feature = "wml-tables")]
        let mut f_text_direction = None;
        #[cfg(feature = "wml-tables")]
        let mut f_tc_fit_text = None;
        #[cfg(feature = "wml-tables")]
        let mut f_v_align = None;
        #[cfg(feature = "wml-tables")]
        let mut f_hide_mark = None;
        #[cfg(feature = "wml-tables")]
        let mut f_headers = None;
        let mut f_cell_markup = None;
        let mut f_tc_pr_change = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "wml-styling")]
                            b"cnfStyle" => {
                                f_cnf_style = Some(Box::new(CTCnf::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tcW" => {
                                f_tc_w = Some(Box::new(CTTblWidth::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"gridSpan" => {
                                f_grid_span =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"hMerge" => {
                                f_horizontal_merge =
                                    Some(Box::new(CTHMerge::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"vMerge" => {
                                f_vertical_merge =
                                    Some(Box::new(CTVMerge::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tcBorders" => {
                                f_tc_borders =
                                    Some(Box::new(CTTcBorders::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"noWrap" => {
                                f_no_wrap = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tcMar" => {
                                f_tc_mar = Some(Box::new(CTTcMar::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"textDirection" => {
                                f_text_direction =
                                    Some(Box::new(CTTextDirection::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tcFitText" => {
                                f_tc_fit_text =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"vAlign" => {
                                f_v_align =
                                    Some(Box::new(CTVerticalJc::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"hideMark" => {
                                f_hide_mark = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"headers" => {
                                f_headers = Some(Box::new(CTHeaders::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cellIns" | b"cellDel" | b"cellMerge" => {
                                f_cell_markup =
                                    Some(Box::new(CellMarkup::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tcPrChange" => {
                                f_tc_pr_change =
                                    Some(Box::new(CTTcPrChange::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "wml-styling")]
                            b"cnfStyle" => {
                                f_cnf_style = Some(Box::new(CTCnf::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tcW" => {
                                f_tc_w = Some(Box::new(CTTblWidth::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"gridSpan" => {
                                f_grid_span =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"hMerge" => {
                                f_horizontal_merge =
                                    Some(Box::new(CTHMerge::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"vMerge" => {
                                f_vertical_merge =
                                    Some(Box::new(CTVMerge::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tcBorders" => {
                                f_tc_borders =
                                    Some(Box::new(CTTcBorders::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"noWrap" => {
                                f_no_wrap = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tcMar" => {
                                f_tc_mar = Some(Box::new(CTTcMar::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"textDirection" => {
                                f_text_direction =
                                    Some(Box::new(CTTextDirection::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tcFitText" => {
                                f_tc_fit_text =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"vAlign" => {
                                f_v_align =
                                    Some(Box::new(CTVerticalJc::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"hideMark" => {
                                f_hide_mark = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"headers" => {
                                f_headers = Some(Box::new(CTHeaders::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cellIns" | b"cellDel" | b"cellMerge" => {
                                f_cell_markup =
                                    Some(Box::new(CellMarkup::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tcPrChange" => {
                                f_tc_pr_change =
                                    Some(Box::new(CTTcPrChange::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            #[cfg(feature = "wml-styling")]
            cnf_style: f_cnf_style,
            #[cfg(feature = "wml-tables")]
            tc_w: f_tc_w,
            #[cfg(feature = "wml-tables")]
            grid_span: f_grid_span,
            #[cfg(feature = "wml-tables")]
            horizontal_merge: f_horizontal_merge,
            #[cfg(feature = "wml-tables")]
            vertical_merge: f_vertical_merge,
            #[cfg(feature = "wml-tables")]
            tc_borders: f_tc_borders,
            #[cfg(feature = "wml-tables")]
            shading: f_shading,
            #[cfg(feature = "wml-tables")]
            no_wrap: f_no_wrap,
            #[cfg(feature = "wml-tables")]
            tc_mar: f_tc_mar,
            #[cfg(feature = "wml-tables")]
            text_direction: f_text_direction,
            #[cfg(feature = "wml-tables")]
            tc_fit_text: f_tc_fit_text,
            #[cfg(feature = "wml-tables")]
            v_align: f_v_align,
            #[cfg(feature = "wml-tables")]
            hide_mark: f_hide_mark,
            #[cfg(feature = "wml-tables")]
            headers: f_headers,
            cell_markup: f_cell_markup,
            tc_pr_change: f_tc_pr_change,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTTcPrInner {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_cnf_style = None;
        let mut f_tc_w = None;
        let mut f_grid_span = None;
        let mut f_horizontal_merge = None;
        let mut f_vertical_merge = None;
        let mut f_tc_borders = None;
        let mut f_shading = None;
        let mut f_no_wrap = None;
        let mut f_tc_mar = None;
        let mut f_text_direction = None;
        let mut f_tc_fit_text = None;
        let mut f_v_align = None;
        let mut f_hide_mark = None;
        let mut f_headers = None;
        let mut f_cell_markup = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"cnfStyle" => {
                                f_cnf_style = Some(Box::new(CTCnf::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tcW" => {
                                f_tc_w = Some(Box::new(CTTblWidth::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"gridSpan" => {
                                f_grid_span =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"hMerge" => {
                                f_horizontal_merge =
                                    Some(Box::new(CTHMerge::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vMerge" => {
                                f_vertical_merge =
                                    Some(Box::new(CTVMerge::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tcBorders" => {
                                f_tc_borders =
                                    Some(Box::new(CTTcBorders::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noWrap" => {
                                f_no_wrap = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tcMar" => {
                                f_tc_mar = Some(Box::new(CTTcMar::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"textDirection" => {
                                f_text_direction =
                                    Some(Box::new(CTTextDirection::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tcFitText" => {
                                f_tc_fit_text =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vAlign" => {
                                f_v_align =
                                    Some(Box::new(CTVerticalJc::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"hideMark" => {
                                f_hide_mark = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"headers" => {
                                f_headers = Some(Box::new(CTHeaders::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cellIns" | b"cellDel" | b"cellMerge" => {
                                f_cell_markup =
                                    Some(Box::new(CellMarkup::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"cnfStyle" => {
                                f_cnf_style = Some(Box::new(CTCnf::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tcW" => {
                                f_tc_w = Some(Box::new(CTTblWidth::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"gridSpan" => {
                                f_grid_span =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"hMerge" => {
                                f_horizontal_merge =
                                    Some(Box::new(CTHMerge::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vMerge" => {
                                f_vertical_merge =
                                    Some(Box::new(CTVMerge::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tcBorders" => {
                                f_tc_borders =
                                    Some(Box::new(CTTcBorders::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noWrap" => {
                                f_no_wrap = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tcMar" => {
                                f_tc_mar = Some(Box::new(CTTcMar::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"textDirection" => {
                                f_text_direction =
                                    Some(Box::new(CTTextDirection::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tcFitText" => {
                                f_tc_fit_text =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vAlign" => {
                                f_v_align =
                                    Some(Box::new(CTVerticalJc::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"hideMark" => {
                                f_hide_mark = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"headers" => {
                                f_headers = Some(Box::new(CTHeaders::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cellIns" | b"cellDel" | b"cellMerge" => {
                                f_cell_markup =
                                    Some(Box::new(CellMarkup::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            cnf_style: f_cnf_style,
            tc_w: f_tc_w,
            grid_span: f_grid_span,
            horizontal_merge: f_horizontal_merge,
            vertical_merge: f_vertical_merge,
            tc_borders: f_tc_borders,
            shading: f_shading,
            no_wrap: f_no_wrap,
            tc_mar: f_tc_mar,
            text_direction: f_text_direction,
            tc_fit_text: f_tc_fit_text,
            v_align: f_v_align,
            hide_mark: f_hide_mark,
            headers: f_headers,
            cell_markup: f_cell_markup,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for TableCell {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id = None;
        #[cfg(feature = "wml-tables")]
        let mut f_cell_properties = None;
        let mut f_block_content = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "wml-tables")]
                            b"tcPr" => {
                                f_cell_properties = Some(Box::new(TableCellProperties::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"customXml"
                            | b"sdt"
                            | b"p"
                            | b"tbl"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo"
                            | b"altChunk" => {
                                f_block_content
                                    .push(Box::new(BlockContent::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "wml-tables")]
                            b"tcPr" => {
                                f_cell_properties = Some(Box::new(TableCellProperties::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"customXml"
                            | b"sdt"
                            | b"p"
                            | b"tbl"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo"
                            | b"altChunk" => {
                                f_block_content
                                    .push(Box::new(BlockContent::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id,
            #[cfg(feature = "wml-tables")]
            cell_properties: f_cell_properties,
            block_content: f_block_content,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTCnf {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value = None;
        let mut f_first_row = None;
        let mut f_last_row = None;
        let mut f_first_column = None;
        let mut f_last_column = None;
        let mut f_odd_v_band = None;
        let mut f_even_v_band = None;
        let mut f_odd_h_band = None;
        let mut f_even_h_band = None;
        let mut f_first_row_first_column = None;
        let mut f_first_row_last_column = None;
        let mut f_last_row_first_column = None;
        let mut f_last_row_last_column = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                b"firstRow" => {
                    f_first_row = Some(val.into_owned());
                }
                b"lastRow" => {
                    f_last_row = Some(val.into_owned());
                }
                b"firstColumn" => {
                    f_first_column = Some(val.into_owned());
                }
                b"lastColumn" => {
                    f_last_column = Some(val.into_owned());
                }
                b"oddVBand" => {
                    f_odd_v_band = Some(val.into_owned());
                }
                b"evenVBand" => {
                    f_even_v_band = Some(val.into_owned());
                }
                b"oddHBand" => {
                    f_odd_h_band = Some(val.into_owned());
                }
                b"evenHBand" => {
                    f_even_h_band = Some(val.into_owned());
                }
                b"firstRowFirstColumn" => {
                    f_first_row_first_column = Some(val.into_owned());
                }
                b"firstRowLastColumn" => {
                    f_first_row_last_column = Some(val.into_owned());
                }
                b"lastRowFirstColumn" => {
                    f_last_row_first_column = Some(val.into_owned());
                }
                b"lastRowLastColumn" => {
                    f_last_row_last_column = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value,
            first_row: f_first_row,
            last_row: f_last_row,
            first_column: f_first_column,
            last_column: f_last_column,
            odd_v_band: f_odd_v_band,
            even_v_band: f_even_v_band,
            odd_h_band: f_odd_h_band,
            even_h_band: f_even_h_band,
            first_row_first_column: f_first_row_first_column,
            first_row_last_column: f_first_row_last_column,
            last_row_first_column: f_last_row_first_column,
            last_row_last_column: f_last_row_last_column,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTHeaders {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_header = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"header" => {
                                f_header.push(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"header" => {
                                f_header.push(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            header: f_header,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTTrPrBase {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    #[cfg(feature = "extra-children")]
                    Event::Start(e) => {
                        let elem = RawXmlElement::from_reader(reader, &e)?;
                        extra_children
                            .push(PositionedNode::new(child_idx, RawXmlNode::Element(elem)));
                        child_idx += 1;
                    }
                    #[cfg(not(feature = "extra-children"))]
                    Event::Start(_) => {
                        skip_element(reader)?;
                    }
                    #[cfg(feature = "extra-children")]
                    Event::Empty(e) => {
                        let elem = RawXmlElement::from_empty(&e);
                        extra_children
                            .push(PositionedNode::new(child_idx, RawXmlNode::Element(elem)));
                        child_idx += 1;
                    }
                    #[cfg(not(feature = "extra-children"))]
                    Event::Empty(_) => {}
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }
        Ok(Self {
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for TableRowProperties {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "wml-track-changes")]
        let mut f_ins = None;
        #[cfg(feature = "wml-track-changes")]
        let mut f_del = None;
        #[cfg(feature = "wml-track-changes")]
        let mut f_tr_pr_change = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "wml-track-changes")]
                            b"ins" => {
                                f_ins = Some(Box::new(CTTrackChange::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-track-changes")]
                            b"del" => {
                                f_del = Some(Box::new(CTTrackChange::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-track-changes")]
                            b"trPrChange" => {
                                f_tr_pr_change =
                                    Some(Box::new(CTTrPrChange::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "wml-track-changes")]
                            b"ins" => {
                                f_ins = Some(Box::new(CTTrackChange::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-track-changes")]
                            b"del" => {
                                f_del = Some(Box::new(CTTrackChange::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-track-changes")]
                            b"trPrChange" => {
                                f_tr_pr_change =
                                    Some(Box::new(CTTrPrChange::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            #[cfg(feature = "wml-track-changes")]
            ins: f_ins,
            #[cfg(feature = "wml-track-changes")]
            del: f_del,
            #[cfg(feature = "wml-track-changes")]
            tr_pr_change: f_tr_pr_change,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTRow {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_rsid_r_pr = None;
        let mut f_rsid_r = None;
        let mut f_rsid_del = None;
        let mut f_rsid_tr = None;
        #[cfg(feature = "wml-tables")]
        let mut f_tbl_pr_ex = None;
        #[cfg(feature = "wml-tables")]
        let mut f_row_properties = None;
        let mut f_cells = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"rsidRPr" => {
                    f_rsid_r_pr = decode_hex(&val);
                }
                b"rsidR" => {
                    f_rsid_r = decode_hex(&val);
                }
                b"rsidDel" => {
                    f_rsid_del = decode_hex(&val);
                }
                b"rsidTr" => {
                    f_rsid_tr = decode_hex(&val);
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "wml-tables")]
                            b"tblPrEx" => {
                                f_tbl_pr_ex =
                                    Some(Box::new(CTTblPrEx::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"trPr" => {
                                f_row_properties = Some(Box::new(TableRowProperties::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tc"
                            | b"customXml"
                            | b"sdt"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo" => {
                                f_cells.push(Box::new(CellContent::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "wml-tables")]
                            b"tblPrEx" => {
                                f_tbl_pr_ex =
                                    Some(Box::new(CTTblPrEx::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"trPr" => {
                                f_row_properties =
                                    Some(Box::new(TableRowProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tc"
                            | b"customXml"
                            | b"sdt"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo" => {
                                f_cells.push(Box::new(CellContent::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            rsid_r_pr: f_rsid_r_pr,
            rsid_r: f_rsid_r,
            rsid_del: f_rsid_del,
            rsid_tr: f_rsid_tr,
            #[cfg(feature = "wml-tables")]
            tbl_pr_ex: f_tbl_pr_ex,
            #[cfg(feature = "wml-tables")]
            row_properties: f_row_properties,
            cells: f_cells,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTTblLayoutType {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_type = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"type" => {
                    f_type = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r#type: f_type,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTTblOverlap {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STTblOverlap> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTTblPPr {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_left_from_text = None;
        let mut f_right_from_text = None;
        let mut f_top_from_text = None;
        let mut f_bottom_from_text = None;
        let mut f_vert_anchor = None;
        let mut f_horz_anchor = None;
        let mut f_tblp_x_spec = None;
        let mut f_tblp_x = None;
        let mut f_tblp_y_spec = None;
        let mut f_tblp_y = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"leftFromText" => {
                    f_left_from_text = Some(val.into_owned());
                }
                b"rightFromText" => {
                    f_right_from_text = Some(val.into_owned());
                }
                b"topFromText" => {
                    f_top_from_text = Some(val.into_owned());
                }
                b"bottomFromText" => {
                    f_bottom_from_text = Some(val.into_owned());
                }
                b"vertAnchor" => {
                    f_vert_anchor = val.parse().ok();
                }
                b"horzAnchor" => {
                    f_horz_anchor = val.parse().ok();
                }
                b"tblpXSpec" => {
                    f_tblp_x_spec = val.parse().ok();
                }
                b"tblpX" => {
                    f_tblp_x = Some(val.into_owned());
                }
                b"tblpYSpec" => {
                    f_tblp_y_spec = val.parse().ok();
                }
                b"tblpY" => {
                    f_tblp_y = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            left_from_text: f_left_from_text,
            right_from_text: f_right_from_text,
            top_from_text: f_top_from_text,
            bottom_from_text: f_bottom_from_text,
            vert_anchor: f_vert_anchor,
            horz_anchor: f_horz_anchor,
            tblp_x_spec: f_tblp_x_spec,
            tblp_x: f_tblp_x,
            tblp_y_spec: f_tblp_y_spec,
            tblp_y: f_tblp_y,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTTblCellMar {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_top = None;
        let mut f_start = None;
        let mut f_left = None;
        let mut f_bottom = None;
        let mut f_end = None;
        let mut f_right = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"top" => {
                                f_top = Some(Box::new(CTTblWidth::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"start" => {
                                f_start = Some(Box::new(CTTblWidth::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"left" => {
                                f_left = Some(Box::new(CTTblWidth::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bottom" => {
                                f_bottom = Some(Box::new(CTTblWidth::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"end" => {
                                f_end = Some(Box::new(CTTblWidth::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"right" => {
                                f_right = Some(Box::new(CTTblWidth::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"top" => {
                                f_top = Some(Box::new(CTTblWidth::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"start" => {
                                f_start = Some(Box::new(CTTblWidth::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"left" => {
                                f_left = Some(Box::new(CTTblWidth::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bottom" => {
                                f_bottom = Some(Box::new(CTTblWidth::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"end" => {
                                f_end = Some(Box::new(CTTblWidth::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"right" => {
                                f_right = Some(Box::new(CTTblWidth::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            top: f_top,
            start: f_start,
            left: f_left,
            bottom: f_bottom,
            end: f_end,
            right: f_right,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTTblBorders {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_top = None;
        let mut f_start = None;
        let mut f_left = None;
        let mut f_bottom = None;
        let mut f_end = None;
        let mut f_right = None;
        let mut f_inside_h = None;
        let mut f_inside_v = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"top" => {
                                f_top = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"start" => {
                                f_start = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"left" => {
                                f_left = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bottom" => {
                                f_bottom = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"end" => {
                                f_end = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"right" => {
                                f_right = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"insideH" => {
                                f_inside_h = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"insideV" => {
                                f_inside_v = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"top" => {
                                f_top = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"start" => {
                                f_start = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"left" => {
                                f_left = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bottom" => {
                                f_bottom = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"end" => {
                                f_end = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"right" => {
                                f_right = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"insideH" => {
                                f_inside_h = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"insideV" => {
                                f_inside_v = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            top: f_top,
            start: f_start,
            left: f_left,
            bottom: f_bottom,
            end: f_end,
            right: f_right,
            inside_h: f_inside_h,
            inside_v: f_inside_v,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTTblPrBase {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_tbl_style = None;
        let mut f_tblp_pr = None;
        let mut f_tbl_overlap = None;
        let mut f_bidi_visual = None;
        let mut f_tbl_style_row_band_size = None;
        let mut f_tbl_style_col_band_size = None;
        let mut f_tbl_w = None;
        let mut f_justification = None;
        let mut f_tbl_cell_spacing = None;
        let mut f_tbl_ind = None;
        let mut f_tbl_borders = None;
        let mut f_shading = None;
        let mut f_tbl_layout = None;
        let mut f_tbl_cell_mar = None;
        let mut f_tbl_look = None;
        let mut f_tbl_caption = None;
        let mut f_tbl_description = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"tblStyle" => {
                                f_tbl_style =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblpPr" => {
                                f_tblp_pr = Some(Box::new(CTTblPPr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblOverlap" => {
                                f_tbl_overlap =
                                    Some(Box::new(CTTblOverlap::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bidiVisual" => {
                                f_bidi_visual =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblStyleRowBandSize" => {
                                f_tbl_style_row_band_size =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblStyleColBandSize" => {
                                f_tbl_style_col_band_size =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblW" => {
                                f_tbl_w = Some(Box::new(CTTblWidth::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"jc" => {
                                f_justification =
                                    Some(Box::new(CTJcTable::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblCellSpacing" => {
                                f_tbl_cell_spacing =
                                    Some(Box::new(CTTblWidth::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblInd" => {
                                f_tbl_ind =
                                    Some(Box::new(CTTblWidth::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblBorders" => {
                                f_tbl_borders =
                                    Some(Box::new(CTTblBorders::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblLayout" => {
                                f_tbl_layout =
                                    Some(Box::new(CTTblLayoutType::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblCellMar" => {
                                f_tbl_cell_mar =
                                    Some(Box::new(CTTblCellMar::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblLook" => {
                                f_tbl_look =
                                    Some(Box::new(CTTblLook::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblCaption" => {
                                f_tbl_caption =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblDescription" => {
                                f_tbl_description =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"tblStyle" => {
                                f_tbl_style = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblpPr" => {
                                f_tblp_pr = Some(Box::new(CTTblPPr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblOverlap" => {
                                f_tbl_overlap =
                                    Some(Box::new(CTTblOverlap::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bidiVisual" => {
                                f_bidi_visual =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblStyleRowBandSize" => {
                                f_tbl_style_row_band_size =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblStyleColBandSize" => {
                                f_tbl_style_col_band_size =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblW" => {
                                f_tbl_w = Some(Box::new(CTTblWidth::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"jc" => {
                                f_justification =
                                    Some(Box::new(CTJcTable::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblCellSpacing" => {
                                f_tbl_cell_spacing =
                                    Some(Box::new(CTTblWidth::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblInd" => {
                                f_tbl_ind = Some(Box::new(CTTblWidth::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblBorders" => {
                                f_tbl_borders =
                                    Some(Box::new(CTTblBorders::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblLayout" => {
                                f_tbl_layout =
                                    Some(Box::new(CTTblLayoutType::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblCellMar" => {
                                f_tbl_cell_mar =
                                    Some(Box::new(CTTblCellMar::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblLook" => {
                                f_tbl_look = Some(Box::new(CTTblLook::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblCaption" => {
                                f_tbl_caption =
                                    Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblDescription" => {
                                f_tbl_description =
                                    Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            tbl_style: f_tbl_style,
            tblp_pr: f_tblp_pr,
            tbl_overlap: f_tbl_overlap,
            bidi_visual: f_bidi_visual,
            tbl_style_row_band_size: f_tbl_style_row_band_size,
            tbl_style_col_band_size: f_tbl_style_col_band_size,
            tbl_w: f_tbl_w,
            justification: f_justification,
            tbl_cell_spacing: f_tbl_cell_spacing,
            tbl_ind: f_tbl_ind,
            tbl_borders: f_tbl_borders,
            shading: f_shading,
            tbl_layout: f_tbl_layout,
            tbl_cell_mar: f_tbl_cell_mar,
            tbl_look: f_tbl_look,
            tbl_caption: f_tbl_caption,
            tbl_description: f_tbl_description,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for TableProperties {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "wml-styling")]
        let mut f_tbl_style = None;
        #[cfg(feature = "wml-tables")]
        let mut f_tblp_pr = None;
        #[cfg(feature = "wml-tables")]
        let mut f_tbl_overlap = None;
        #[cfg(feature = "wml-tables")]
        let mut f_bidi_visual = None;
        #[cfg(feature = "wml-styling")]
        let mut f_tbl_style_row_band_size = None;
        #[cfg(feature = "wml-styling")]
        let mut f_tbl_style_col_band_size = None;
        #[cfg(feature = "wml-tables")]
        let mut f_tbl_w = None;
        #[cfg(feature = "wml-tables")]
        let mut f_justification = None;
        #[cfg(feature = "wml-tables")]
        let mut f_tbl_cell_spacing = None;
        #[cfg(feature = "wml-tables")]
        let mut f_tbl_ind = None;
        #[cfg(feature = "wml-tables")]
        let mut f_tbl_borders = None;
        #[cfg(feature = "wml-tables")]
        let mut f_shading = None;
        #[cfg(feature = "wml-tables")]
        let mut f_tbl_layout = None;
        #[cfg(feature = "wml-tables")]
        let mut f_tbl_cell_mar = None;
        #[cfg(feature = "wml-tables")]
        let mut f_tbl_look = None;
        #[cfg(feature = "wml-tables")]
        let mut f_tbl_caption = None;
        #[cfg(feature = "wml-tables")]
        let mut f_tbl_description = None;
        #[cfg(feature = "wml-track-changes")]
        let mut f_tbl_pr_change = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "wml-styling")]
                            b"tblStyle" => {
                                f_tbl_style =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tblpPr" => {
                                f_tblp_pr = Some(Box::new(CTTblPPr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tblOverlap" => {
                                f_tbl_overlap =
                                    Some(Box::new(CTTblOverlap::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"bidiVisual" => {
                                f_bidi_visual =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"tblStyleRowBandSize" => {
                                f_tbl_style_row_band_size =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"tblStyleColBandSize" => {
                                f_tbl_style_col_band_size =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tblW" => {
                                f_tbl_w = Some(Box::new(CTTblWidth::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"jc" => {
                                f_justification =
                                    Some(Box::new(CTJcTable::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tblCellSpacing" => {
                                f_tbl_cell_spacing =
                                    Some(Box::new(CTTblWidth::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tblInd" => {
                                f_tbl_ind =
                                    Some(Box::new(CTTblWidth::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tblBorders" => {
                                f_tbl_borders =
                                    Some(Box::new(CTTblBorders::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tblLayout" => {
                                f_tbl_layout =
                                    Some(Box::new(CTTblLayoutType::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tblCellMar" => {
                                f_tbl_cell_mar =
                                    Some(Box::new(CTTblCellMar::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tblLook" => {
                                f_tbl_look =
                                    Some(Box::new(CTTblLook::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tblCaption" => {
                                f_tbl_caption =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tblDescription" => {
                                f_tbl_description =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-track-changes")]
                            b"tblPrChange" => {
                                f_tbl_pr_change =
                                    Some(Box::new(CTTblPrChange::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "wml-styling")]
                            b"tblStyle" => {
                                f_tbl_style = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tblpPr" => {
                                f_tblp_pr = Some(Box::new(CTTblPPr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tblOverlap" => {
                                f_tbl_overlap =
                                    Some(Box::new(CTTblOverlap::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"bidiVisual" => {
                                f_bidi_visual =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"tblStyleRowBandSize" => {
                                f_tbl_style_row_band_size =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"tblStyleColBandSize" => {
                                f_tbl_style_col_band_size =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tblW" => {
                                f_tbl_w = Some(Box::new(CTTblWidth::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"jc" => {
                                f_justification =
                                    Some(Box::new(CTJcTable::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tblCellSpacing" => {
                                f_tbl_cell_spacing =
                                    Some(Box::new(CTTblWidth::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tblInd" => {
                                f_tbl_ind = Some(Box::new(CTTblWidth::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tblBorders" => {
                                f_tbl_borders =
                                    Some(Box::new(CTTblBorders::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tblLayout" => {
                                f_tbl_layout =
                                    Some(Box::new(CTTblLayoutType::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tblCellMar" => {
                                f_tbl_cell_mar =
                                    Some(Box::new(CTTblCellMar::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tblLook" => {
                                f_tbl_look = Some(Box::new(CTTblLook::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tblCaption" => {
                                f_tbl_caption =
                                    Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-tables")]
                            b"tblDescription" => {
                                f_tbl_description =
                                    Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-track-changes")]
                            b"tblPrChange" => {
                                f_tbl_pr_change =
                                    Some(Box::new(CTTblPrChange::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            #[cfg(feature = "wml-styling")]
            tbl_style: f_tbl_style,
            #[cfg(feature = "wml-tables")]
            tblp_pr: f_tblp_pr,
            #[cfg(feature = "wml-tables")]
            tbl_overlap: f_tbl_overlap,
            #[cfg(feature = "wml-tables")]
            bidi_visual: f_bidi_visual,
            #[cfg(feature = "wml-styling")]
            tbl_style_row_band_size: f_tbl_style_row_band_size,
            #[cfg(feature = "wml-styling")]
            tbl_style_col_band_size: f_tbl_style_col_band_size,
            #[cfg(feature = "wml-tables")]
            tbl_w: f_tbl_w,
            #[cfg(feature = "wml-tables")]
            justification: f_justification,
            #[cfg(feature = "wml-tables")]
            tbl_cell_spacing: f_tbl_cell_spacing,
            #[cfg(feature = "wml-tables")]
            tbl_ind: f_tbl_ind,
            #[cfg(feature = "wml-tables")]
            tbl_borders: f_tbl_borders,
            #[cfg(feature = "wml-tables")]
            shading: f_shading,
            #[cfg(feature = "wml-tables")]
            tbl_layout: f_tbl_layout,
            #[cfg(feature = "wml-tables")]
            tbl_cell_mar: f_tbl_cell_mar,
            #[cfg(feature = "wml-tables")]
            tbl_look: f_tbl_look,
            #[cfg(feature = "wml-tables")]
            tbl_caption: f_tbl_caption,
            #[cfg(feature = "wml-tables")]
            tbl_description: f_tbl_description,
            #[cfg(feature = "wml-track-changes")]
            tbl_pr_change: f_tbl_pr_change,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTTblPrExBase {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_tbl_w = None;
        let mut f_justification = None;
        let mut f_tbl_cell_spacing = None;
        let mut f_tbl_ind = None;
        let mut f_tbl_borders = None;
        let mut f_shading = None;
        let mut f_tbl_layout = None;
        let mut f_tbl_cell_mar = None;
        let mut f_tbl_look = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"tblW" => {
                                f_tbl_w = Some(Box::new(CTTblWidth::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"jc" => {
                                f_justification =
                                    Some(Box::new(CTJcTable::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblCellSpacing" => {
                                f_tbl_cell_spacing =
                                    Some(Box::new(CTTblWidth::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblInd" => {
                                f_tbl_ind =
                                    Some(Box::new(CTTblWidth::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblBorders" => {
                                f_tbl_borders =
                                    Some(Box::new(CTTblBorders::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblLayout" => {
                                f_tbl_layout =
                                    Some(Box::new(CTTblLayoutType::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblCellMar" => {
                                f_tbl_cell_mar =
                                    Some(Box::new(CTTblCellMar::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblLook" => {
                                f_tbl_look =
                                    Some(Box::new(CTTblLook::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"tblW" => {
                                f_tbl_w = Some(Box::new(CTTblWidth::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"jc" => {
                                f_justification =
                                    Some(Box::new(CTJcTable::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblCellSpacing" => {
                                f_tbl_cell_spacing =
                                    Some(Box::new(CTTblWidth::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblInd" => {
                                f_tbl_ind = Some(Box::new(CTTblWidth::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblBorders" => {
                                f_tbl_borders =
                                    Some(Box::new(CTTblBorders::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblLayout" => {
                                f_tbl_layout =
                                    Some(Box::new(CTTblLayoutType::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblCellMar" => {
                                f_tbl_cell_mar =
                                    Some(Box::new(CTTblCellMar::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblLook" => {
                                f_tbl_look = Some(Box::new(CTTblLook::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            tbl_w: f_tbl_w,
            justification: f_justification,
            tbl_cell_spacing: f_tbl_cell_spacing,
            tbl_ind: f_tbl_ind,
            tbl_borders: f_tbl_borders,
            shading: f_shading,
            tbl_layout: f_tbl_layout,
            tbl_cell_mar: f_tbl_cell_mar,
            tbl_look: f_tbl_look,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTTblPrEx {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_tbl_w = None;
        let mut f_justification = None;
        let mut f_tbl_cell_spacing = None;
        let mut f_tbl_ind = None;
        let mut f_tbl_borders = None;
        let mut f_shading = None;
        let mut f_tbl_layout = None;
        let mut f_tbl_cell_mar = None;
        let mut f_tbl_look = None;
        let mut f_tbl_pr_ex_change = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"tblW" => {
                                f_tbl_w = Some(Box::new(CTTblWidth::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"jc" => {
                                f_justification =
                                    Some(Box::new(CTJcTable::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblCellSpacing" => {
                                f_tbl_cell_spacing =
                                    Some(Box::new(CTTblWidth::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblInd" => {
                                f_tbl_ind =
                                    Some(Box::new(CTTblWidth::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblBorders" => {
                                f_tbl_borders =
                                    Some(Box::new(CTTblBorders::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblLayout" => {
                                f_tbl_layout =
                                    Some(Box::new(CTTblLayoutType::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblCellMar" => {
                                f_tbl_cell_mar =
                                    Some(Box::new(CTTblCellMar::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblLook" => {
                                f_tbl_look =
                                    Some(Box::new(CTTblLook::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblPrExChange" => {
                                f_tbl_pr_ex_change =
                                    Some(Box::new(CTTblPrExChange::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"tblW" => {
                                f_tbl_w = Some(Box::new(CTTblWidth::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"jc" => {
                                f_justification =
                                    Some(Box::new(CTJcTable::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblCellSpacing" => {
                                f_tbl_cell_spacing =
                                    Some(Box::new(CTTblWidth::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblInd" => {
                                f_tbl_ind = Some(Box::new(CTTblWidth::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblBorders" => {
                                f_tbl_borders =
                                    Some(Box::new(CTTblBorders::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shd" => {
                                f_shading = Some(Box::new(CTShd::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblLayout" => {
                                f_tbl_layout =
                                    Some(Box::new(CTTblLayoutType::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblCellMar" => {
                                f_tbl_cell_mar =
                                    Some(Box::new(CTTblCellMar::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblLook" => {
                                f_tbl_look = Some(Box::new(CTTblLook::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblPrExChange" => {
                                f_tbl_pr_ex_change =
                                    Some(Box::new(CTTblPrExChange::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            tbl_w: f_tbl_w,
            justification: f_justification,
            tbl_cell_spacing: f_tbl_cell_spacing,
            tbl_ind: f_tbl_ind,
            tbl_borders: f_tbl_borders,
            shading: f_shading,
            tbl_layout: f_tbl_layout,
            tbl_cell_mar: f_tbl_cell_mar,
            tbl_look: f_tbl_look,
            tbl_pr_ex_change: f_tbl_pr_ex_change,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Table {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_range_markup = Vec::new();
        let mut f_table_properties: Option<Box<TableProperties>> = None;
        let mut f_tbl_grid: Option<Box<TableGrid>> = None;
        let mut f_rows = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd" => {
                                f_range_markup
                                    .push(Box::new(RangeMarkup::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblPr" => {
                                f_table_properties =
                                    Some(Box::new(TableProperties::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblGrid" => {
                                f_tbl_grid =
                                    Some(Box::new(TableGrid::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tr" | b"customXml" | b"sdt" | b"proofErr" | b"permStart"
                            | b"permEnd" | b"ins" | b"del" | b"moveFrom" | b"moveTo" => {
                                f_rows.push(Box::new(RowContent::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd" => {
                                f_range_markup
                                    .push(Box::new(RangeMarkup::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblPr" => {
                                f_table_properties =
                                    Some(Box::new(TableProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblGrid" => {
                                f_tbl_grid = Some(Box::new(TableGrid::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tr" | b"customXml" | b"sdt" | b"proofErr" | b"permStart"
                            | b"permEnd" | b"ins" | b"del" | b"moveFrom" | b"moveTo" => {
                                f_rows.push(Box::new(RowContent::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            range_markup: f_range_markup,
            table_properties: f_table_properties
                .ok_or_else(|| ParseError::MissingAttribute("tblPr".to_string()))?,
            tbl_grid: f_tbl_grid
                .ok_or_else(|| ParseError::MissingAttribute("tblGrid".to_string()))?,
            rows: f_rows,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTTblLook {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_first_row = None;
        let mut f_last_row = None;
        let mut f_first_column = None;
        let mut f_last_column = None;
        let mut f_no_h_band = None;
        let mut f_no_v_band = None;
        let mut f_value = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"firstRow" => {
                    f_first_row = Some(val.into_owned());
                }
                b"lastRow" => {
                    f_last_row = Some(val.into_owned());
                }
                b"firstColumn" => {
                    f_first_column = Some(val.into_owned());
                }
                b"lastColumn" => {
                    f_last_column = Some(val.into_owned());
                }
                b"noHBand" => {
                    f_no_h_band = Some(val.into_owned());
                }
                b"noVBand" => {
                    f_no_v_band = Some(val.into_owned());
                }
                b"val" => {
                    f_value = decode_hex(&val);
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            first_row: f_first_row,
            last_row: f_last_row,
            first_column: f_first_column,
            last_column: f_last_column,
            no_h_band: f_no_h_band,
            no_v_band: f_no_v_band,
            value: f_value,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTFtnPos {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STFtnPos> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTEdnPos {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STEdnPos> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTNumFmt {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STNumberFormat> = None;
        let mut f_format = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                b"format" => {
                    f_format = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            format: f_format,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTNumRestart {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STRestartNumber> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for FootnoteEndnoteRef {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_custom_mark_follows = None;
        let mut f_id: Option<STDecimalNumber> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"customMarkFollows" => {
                    f_custom_mark_follows = Some(val.into_owned());
                }
                b"id" => {
                    f_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            custom_mark_follows: f_custom_mark_follows,
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTFtnEdnSepRef {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STDecimalNumber> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for FootnoteEndnote {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_type = None;
        let mut f_id: Option<STDecimalNumber> = None;
        let mut f_block_content = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"type" => {
                    f_type = val.parse().ok();
                }
                b"id" => {
                    f_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"customXml"
                            | b"sdt"
                            | b"p"
                            | b"tbl"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo"
                            | b"altChunk" => {
                                f_block_content
                                    .push(Box::new(BlockContent::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"customXml"
                            | b"sdt"
                            | b"p"
                            | b"tbl"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo"
                            | b"altChunk" => {
                                f_block_content
                                    .push(Box::new(BlockContent::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r#type: f_type,
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            block_content: f_block_content,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for EGFtnEdnNumProps {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_num_start = None;
        let mut f_num_restart = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"numStart" => {
                                f_num_start =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numRestart" => {
                                f_num_restart =
                                    Some(Box::new(CTNumRestart::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"numStart" => {
                                f_num_start =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numRestart" => {
                                f_num_restart =
                                    Some(Box::new(CTNumRestart::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            num_start: f_num_start,
            num_restart: f_num_restart,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTFtnProps {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_pos = None;
        let mut f_num_fmt = None;
        let mut f_num_start = None;
        let mut f_num_restart = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"pos" => {
                                f_pos = Some(Box::new(CTFtnPos::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numFmt" => {
                                f_num_fmt = Some(Box::new(CTNumFmt::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numStart" => {
                                f_num_start =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numRestart" => {
                                f_num_restart =
                                    Some(Box::new(CTNumRestart::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"pos" => {
                                f_pos = Some(Box::new(CTFtnPos::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numFmt" => {
                                f_num_fmt = Some(Box::new(CTNumFmt::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numStart" => {
                                f_num_start =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numRestart" => {
                                f_num_restart =
                                    Some(Box::new(CTNumRestart::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            pos: f_pos,
            num_fmt: f_num_fmt,
            num_start: f_num_start,
            num_restart: f_num_restart,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTEdnProps {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_pos = None;
        let mut f_num_fmt = None;
        let mut f_num_start = None;
        let mut f_num_restart = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"pos" => {
                                f_pos = Some(Box::new(CTEdnPos::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numFmt" => {
                                f_num_fmt = Some(Box::new(CTNumFmt::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numStart" => {
                                f_num_start =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numRestart" => {
                                f_num_restart =
                                    Some(Box::new(CTNumRestart::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"pos" => {
                                f_pos = Some(Box::new(CTEdnPos::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numFmt" => {
                                f_num_fmt = Some(Box::new(CTNumFmt::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numStart" => {
                                f_num_start =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numRestart" => {
                                f_num_restart =
                                    Some(Box::new(CTNumRestart::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            pos: f_pos,
            num_fmt: f_num_fmt,
            num_start: f_num_start,
            num_restart: f_num_restart,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTFtnDocProps {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_pos = None;
        let mut f_num_fmt = None;
        let mut f_num_start = None;
        let mut f_num_restart = None;
        let mut f_footnote = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"pos" => {
                                f_pos = Some(Box::new(CTFtnPos::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numFmt" => {
                                f_num_fmt = Some(Box::new(CTNumFmt::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numStart" => {
                                f_num_start =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numRestart" => {
                                f_num_restart =
                                    Some(Box::new(CTNumRestart::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"footnote" => {
                                f_footnote
                                    .push(Box::new(CTFtnEdnSepRef::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"pos" => {
                                f_pos = Some(Box::new(CTFtnPos::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numFmt" => {
                                f_num_fmt = Some(Box::new(CTNumFmt::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numStart" => {
                                f_num_start =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numRestart" => {
                                f_num_restart =
                                    Some(Box::new(CTNumRestart::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"footnote" => {
                                f_footnote
                                    .push(Box::new(CTFtnEdnSepRef::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            pos: f_pos,
            num_fmt: f_num_fmt,
            num_start: f_num_start,
            num_restart: f_num_restart,
            footnote: f_footnote,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTEdnDocProps {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_pos = None;
        let mut f_num_fmt = None;
        let mut f_num_start = None;
        let mut f_num_restart = None;
        let mut f_endnote = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"pos" => {
                                f_pos = Some(Box::new(CTEdnPos::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numFmt" => {
                                f_num_fmt = Some(Box::new(CTNumFmt::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numStart" => {
                                f_num_start =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numRestart" => {
                                f_num_restart =
                                    Some(Box::new(CTNumRestart::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"endnote" => {
                                f_endnote
                                    .push(Box::new(CTFtnEdnSepRef::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"pos" => {
                                f_pos = Some(Box::new(CTEdnPos::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numFmt" => {
                                f_num_fmt = Some(Box::new(CTNumFmt::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numStart" => {
                                f_num_start =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numRestart" => {
                                f_num_restart =
                                    Some(Box::new(CTNumRestart::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"endnote" => {
                                f_endnote
                                    .push(Box::new(CTFtnEdnSepRef::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            pos: f_pos,
            num_fmt: f_num_fmt,
            num_start: f_num_start,
            num_restart: f_num_restart,
            endnote: f_endnote,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTRecipientData {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_active = None;
        let mut f_column: Option<Box<CTDecimalNumber>> = None;
        let mut f_unique_tag: Option<Box<CTBase64Binary>> = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"active" => {
                                f_active = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"column" => {
                                f_column =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"uniqueTag" => {
                                f_unique_tag =
                                    Some(Box::new(CTBase64Binary::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"active" => {
                                f_active = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"column" => {
                                f_column =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"uniqueTag" => {
                                f_unique_tag =
                                    Some(Box::new(CTBase64Binary::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            active: f_active,
            column: f_column.ok_or_else(|| ParseError::MissingAttribute("column".to_string()))?,
            unique_tag: f_unique_tag
                .ok_or_else(|| ParseError::MissingAttribute("uniqueTag".to_string()))?,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTBase64Binary {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<Vec<u8>> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = decode_hex(&val);
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTRecipients {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_recipient_data = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"recipientData" => {
                                f_recipient_data
                                    .push(Box::new(CTRecipientData::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"recipientData" => {
                                f_recipient_data
                                    .push(Box::new(CTRecipientData::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            recipient_data: f_recipient_data,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTOdsoFieldMapData {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_type = None;
        let mut f_name = None;
        let mut f_mapped_name = None;
        let mut f_column = None;
        let mut f_lid = None;
        let mut f_dynamic_address = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"type" => {
                                f_type = Some(Box::new(CTMailMergeOdsoFMDFieldType::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"name" => {
                                f_name = Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"mappedName" => {
                                f_mapped_name =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"column" => {
                                f_column =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lid" => {
                                f_lid = Some(Box::new(CTLang::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dynamicAddress" => {
                                f_dynamic_address =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"type" => {
                                f_type = Some(Box::new(CTMailMergeOdsoFMDFieldType::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"name" => {
                                f_name = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"mappedName" => {
                                f_mapped_name =
                                    Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"column" => {
                                f_column =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lid" => {
                                f_lid = Some(Box::new(CTLang::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dynamicAddress" => {
                                f_dynamic_address =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r#type: f_type,
            name: f_name,
            mapped_name: f_mapped_name,
            column: f_column,
            lid: f_lid,
            dynamic_address: f_dynamic_address,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTMailMergeSourceType {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STMailMergeSourceType> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTOdso {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_udl = None;
        let mut f_table = None;
        let mut f_src = None;
        let mut f_col_delim = None;
        let mut f_type = None;
        let mut f_f_hdr = None;
        let mut f_field_map_data = Vec::new();
        let mut f_recipient_data = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"udl" => {
                                f_udl = Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"table" => {
                                f_table = Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"src" => {
                                f_src = Some(Box::new(CTRel::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"colDelim" => {
                                f_col_delim =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"type" => {
                                f_type = Some(Box::new(CTMailMergeSourceType::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"fHdr" => {
                                f_f_hdr = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"fieldMapData" => {
                                f_field_map_data.push(Box::new(CTOdsoFieldMapData::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"recipientData" => {
                                f_recipient_data
                                    .push(Box::new(CTRel::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"udl" => {
                                f_udl = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"table" => {
                                f_table = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"src" => {
                                f_src = Some(Box::new(CTRel::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"colDelim" => {
                                f_col_delim =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"type" => {
                                f_type = Some(Box::new(CTMailMergeSourceType::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"fHdr" => {
                                f_f_hdr = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"fieldMapData" => {
                                f_field_map_data.push(Box::new(CTOdsoFieldMapData::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"recipientData" => {
                                f_recipient_data.push(Box::new(CTRel::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            udl: f_udl,
            table: f_table,
            src: f_src,
            col_delim: f_col_delim,
            r#type: f_type,
            f_hdr: f_f_hdr,
            field_map_data: f_field_map_data,
            recipient_data: f_recipient_data,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTMailMerge {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_main_document_type: Option<Box<CTMailMergeDocType>> = None;
        let mut f_link_to_query = None;
        let mut f_data_type: Option<Box<CTMailMergeDataType>> = None;
        let mut f_connect_string = None;
        let mut f_query = None;
        let mut f_data_source = None;
        let mut f_header_source = None;
        let mut f_do_not_suppress_blank_lines = None;
        let mut f_destination = None;
        let mut f_address_field_name = None;
        let mut f_mail_subject = None;
        let mut f_mail_as_attachment = None;
        let mut f_view_merged_data = None;
        let mut f_active_record = None;
        let mut f_check_errors = None;
        let mut f_odso = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"mainDocumentType" => {
                                f_main_document_type = Some(Box::new(
                                    CTMailMergeDocType::from_xml(reader, &e, false)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"linkToQuery" => {
                                f_link_to_query =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dataType" => {
                                f_data_type = Some(Box::new(CTMailMergeDataType::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"connectString" => {
                                f_connect_string =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"query" => {
                                f_query = Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dataSource" => {
                                f_data_source = Some(Box::new(CTRel::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"headerSource" => {
                                f_header_source =
                                    Some(Box::new(CTRel::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotSuppressBlankLines" => {
                                f_do_not_suppress_blank_lines =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"destination" => {
                                f_destination =
                                    Some(Box::new(CTMailMergeDest::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"addressFieldName" => {
                                f_address_field_name =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"mailSubject" => {
                                f_mail_subject =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"mailAsAttachment" => {
                                f_mail_as_attachment =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"viewMergedData" => {
                                f_view_merged_data =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"activeRecord" => {
                                f_active_record =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"checkErrors" => {
                                f_check_errors =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"odso" => {
                                f_odso = Some(Box::new(CTOdso::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"mainDocumentType" => {
                                f_main_document_type =
                                    Some(Box::new(CTMailMergeDocType::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"linkToQuery" => {
                                f_link_to_query =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dataType" => {
                                f_data_type = Some(Box::new(CTMailMergeDataType::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"connectString" => {
                                f_connect_string =
                                    Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"query" => {
                                f_query = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dataSource" => {
                                f_data_source = Some(Box::new(CTRel::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"headerSource" => {
                                f_header_source =
                                    Some(Box::new(CTRel::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotSuppressBlankLines" => {
                                f_do_not_suppress_blank_lines =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"destination" => {
                                f_destination =
                                    Some(Box::new(CTMailMergeDest::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"addressFieldName" => {
                                f_address_field_name =
                                    Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"mailSubject" => {
                                f_mail_subject =
                                    Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"mailAsAttachment" => {
                                f_mail_as_attachment =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"viewMergedData" => {
                                f_view_merged_data =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"activeRecord" => {
                                f_active_record =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"checkErrors" => {
                                f_check_errors =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"odso" => {
                                f_odso = Some(Box::new(CTOdso::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            main_document_type: f_main_document_type
                .ok_or_else(|| ParseError::MissingAttribute("mainDocumentType".to_string()))?,
            link_to_query: f_link_to_query,
            data_type: f_data_type
                .ok_or_else(|| ParseError::MissingAttribute("dataType".to_string()))?,
            connect_string: f_connect_string,
            query: f_query,
            data_source: f_data_source,
            header_source: f_header_source,
            do_not_suppress_blank_lines: f_do_not_suppress_blank_lines,
            destination: f_destination,
            address_field_name: f_address_field_name,
            mail_subject: f_mail_subject,
            mail_as_attachment: f_mail_as_attachment,
            view_merged_data: f_view_merged_data,
            active_record: f_active_record,
            check_errors: f_check_errors,
            odso: f_odso,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTTargetScreenSz {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STTargetScreenSz> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for Compatibility {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_use_single_borderfor_contiguous_cells = None;
        let mut f_wp_justification = None;
        let mut f_no_tab_hang_ind = None;
        let mut f_no_leading = None;
        let mut f_space_for_u_l = None;
        let mut f_no_column_balance = None;
        let mut f_balance_single_byte_double_byte_width = None;
        let mut f_no_extra_line_spacing = None;
        let mut f_do_not_leave_backslash_alone = None;
        let mut f_ul_trail_space = None;
        let mut f_do_not_expand_shift_return = None;
        let mut f_spacing_in_whole_points = None;
        let mut f_line_wrap_like_word6 = None;
        let mut f_print_body_text_before_header = None;
        let mut f_print_col_black = None;
        let mut f_wp_space_width = None;
        let mut f_show_breaks_in_frames = None;
        let mut f_sub_font_by_size = None;
        let mut f_suppress_bottom_spacing = None;
        let mut f_suppress_top_spacing = None;
        let mut f_suppress_spacing_at_top_of_page = None;
        let mut f_suppress_top_spacing_w_p = None;
        let mut f_suppress_sp_bf_after_pg_brk = None;
        let mut f_swap_borders_facing_pages = None;
        let mut f_conv_mail_merge_esc = None;
        let mut f_truncate_font_heights_like_w_p6 = None;
        let mut f_mw_small_caps = None;
        let mut f_use_printer_metrics = None;
        let mut f_do_not_suppress_paragraph_borders = None;
        let mut f_wrap_trail_spaces = None;
        let mut f_footnote_layout_like_w_w8 = None;
        let mut f_shape_layout_like_w_w8 = None;
        let mut f_align_tables_row_by_row = None;
        let mut f_forget_last_tab_alignment = None;
        let mut f_adjust_line_height_in_table = None;
        let mut f_auto_space_like_word95 = None;
        let mut f_no_space_raise_lower = None;
        let mut f_do_not_use_h_t_m_l_paragraph_auto_spacing = None;
        let mut f_layout_raw_table_width = None;
        let mut f_layout_table_rows_apart = None;
        let mut f_use_word97_line_break_rules = None;
        let mut f_do_not_break_wrapped_tables = None;
        let mut f_do_not_snap_to_grid_in_cell = None;
        let mut f_select_fld_with_first_or_last_char = None;
        let mut f_apply_breaking_rules = None;
        let mut f_do_not_wrap_text_with_punct = None;
        let mut f_do_not_use_east_asian_break_rules = None;
        let mut f_use_word2002_table_style_rules = None;
        let mut f_grow_autofit = None;
        let mut f_use_f_e_layout = None;
        let mut f_use_normal_style_for_list = None;
        let mut f_do_not_use_indent_as_numbering_tab_stop = None;
        let mut f_use_alt_kinsoku_line_break_rules = None;
        let mut f_allow_space_of_same_style_in_table = None;
        let mut f_do_not_suppress_indentation = None;
        let mut f_do_not_autofit_constrained_tables = None;
        let mut f_autofit_to_first_fixed_width_cell = None;
        let mut f_underline_tab_in_num_list = None;
        let mut f_display_hangul_fixed_width = None;
        let mut f_split_pg_break_and_para_mark = None;
        let mut f_do_not_vert_align_cell_with_sp = None;
        let mut f_do_not_break_constrained_forced_table = None;
        let mut f_do_not_vert_align_in_txbx = None;
        let mut f_use_ansi_kerning_pairs = None;
        let mut f_cached_col_balance = None;
        let mut f_compat_setting = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"useSingleBorderforContiguousCells" => {
                                f_use_single_borderfor_contiguous_cells =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"wpJustification" => {
                                f_wp_justification =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noTabHangInd" => {
                                f_no_tab_hang_ind =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noLeading" => {
                                f_no_leading =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"spaceForUL" => {
                                f_space_for_u_l =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noColumnBalance" => {
                                f_no_column_balance =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"balanceSingleByteDoubleByteWidth" => {
                                f_balance_single_byte_double_byte_width =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noExtraLineSpacing" => {
                                f_no_extra_line_spacing =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotLeaveBackslashAlone" => {
                                f_do_not_leave_backslash_alone =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"ulTrailSpace" => {
                                f_ul_trail_space =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotExpandShiftReturn" => {
                                f_do_not_expand_shift_return =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"spacingInWholePoints" => {
                                f_spacing_in_whole_points =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lineWrapLikeWord6" => {
                                f_line_wrap_like_word6 =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"printBodyTextBeforeHeader" => {
                                f_print_body_text_before_header =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"printColBlack" => {
                                f_print_col_black =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"wpSpaceWidth" => {
                                f_wp_space_width =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"showBreaksInFrames" => {
                                f_show_breaks_in_frames =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"subFontBySize" => {
                                f_sub_font_by_size =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"suppressBottomSpacing" => {
                                f_suppress_bottom_spacing =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"suppressTopSpacing" => {
                                f_suppress_top_spacing =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"suppressSpacingAtTopOfPage" => {
                                f_suppress_spacing_at_top_of_page =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"suppressTopSpacingWP" => {
                                f_suppress_top_spacing_w_p =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"suppressSpBfAfterPgBrk" => {
                                f_suppress_sp_bf_after_pg_brk =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"swapBordersFacingPages" => {
                                f_swap_borders_facing_pages =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"convMailMergeEsc" => {
                                f_conv_mail_merge_esc =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"truncateFontHeightsLikeWP6" => {
                                f_truncate_font_heights_like_w_p6 =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"mwSmallCaps" => {
                                f_mw_small_caps =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"usePrinterMetrics" => {
                                f_use_printer_metrics =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotSuppressParagraphBorders" => {
                                f_do_not_suppress_paragraph_borders =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"wrapTrailSpaces" => {
                                f_wrap_trail_spaces =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"footnoteLayoutLikeWW8" => {
                                f_footnote_layout_like_w_w8 =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shapeLayoutLikeWW8" => {
                                f_shape_layout_like_w_w8 =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"alignTablesRowByRow" => {
                                f_align_tables_row_by_row =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"forgetLastTabAlignment" => {
                                f_forget_last_tab_alignment =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"adjustLineHeightInTable" => {
                                f_adjust_line_height_in_table =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"autoSpaceLikeWord95" => {
                                f_auto_space_like_word95 =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noSpaceRaiseLower" => {
                                f_no_space_raise_lower =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotUseHTMLParagraphAutoSpacing" => {
                                f_do_not_use_h_t_m_l_paragraph_auto_spacing =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"layoutRawTableWidth" => {
                                f_layout_raw_table_width =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"layoutTableRowsApart" => {
                                f_layout_table_rows_apart =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"useWord97LineBreakRules" => {
                                f_use_word97_line_break_rules =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotBreakWrappedTables" => {
                                f_do_not_break_wrapped_tables =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotSnapToGridInCell" => {
                                f_do_not_snap_to_grid_in_cell =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"selectFldWithFirstOrLastChar" => {
                                f_select_fld_with_first_or_last_char =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"applyBreakingRules" => {
                                f_apply_breaking_rules =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotWrapTextWithPunct" => {
                                f_do_not_wrap_text_with_punct =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotUseEastAsianBreakRules" => {
                                f_do_not_use_east_asian_break_rules =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"useWord2002TableStyleRules" => {
                                f_use_word2002_table_style_rules =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"growAutofit" => {
                                f_grow_autofit =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"useFELayout" => {
                                f_use_f_e_layout =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"useNormalStyleForList" => {
                                f_use_normal_style_for_list =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotUseIndentAsNumberingTabStop" => {
                                f_do_not_use_indent_as_numbering_tab_stop =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"useAltKinsokuLineBreakRules" => {
                                f_use_alt_kinsoku_line_break_rules =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"allowSpaceOfSameStyleInTable" => {
                                f_allow_space_of_same_style_in_table =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotSuppressIndentation" => {
                                f_do_not_suppress_indentation =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotAutofitConstrainedTables" => {
                                f_do_not_autofit_constrained_tables =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"autofitToFirstFixedWidthCell" => {
                                f_autofit_to_first_fixed_width_cell =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"underlineTabInNumList" => {
                                f_underline_tab_in_num_list =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"displayHangulFixedWidth" => {
                                f_display_hangul_fixed_width =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"splitPgBreakAndParaMark" => {
                                f_split_pg_break_and_para_mark =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotVertAlignCellWithSp" => {
                                f_do_not_vert_align_cell_with_sp =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotBreakConstrainedForcedTable" => {
                                f_do_not_break_constrained_forced_table =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotVertAlignInTxbx" => {
                                f_do_not_vert_align_in_txbx =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"useAnsiKerningPairs" => {
                                f_use_ansi_kerning_pairs =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cachedColBalance" => {
                                f_cached_col_balance =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"compatSetting" => {
                                f_compat_setting
                                    .push(Box::new(CTCompatSetting::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"useSingleBorderforContiguousCells" => {
                                f_use_single_borderfor_contiguous_cells =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"wpJustification" => {
                                f_wp_justification =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noTabHangInd" => {
                                f_no_tab_hang_ind =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noLeading" => {
                                f_no_leading = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"spaceForUL" => {
                                f_space_for_u_l =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noColumnBalance" => {
                                f_no_column_balance =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"balanceSingleByteDoubleByteWidth" => {
                                f_balance_single_byte_double_byte_width =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noExtraLineSpacing" => {
                                f_no_extra_line_spacing =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotLeaveBackslashAlone" => {
                                f_do_not_leave_backslash_alone =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"ulTrailSpace" => {
                                f_ul_trail_space =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotExpandShiftReturn" => {
                                f_do_not_expand_shift_return =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"spacingInWholePoints" => {
                                f_spacing_in_whole_points =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lineWrapLikeWord6" => {
                                f_line_wrap_like_word6 =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"printBodyTextBeforeHeader" => {
                                f_print_body_text_before_header =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"printColBlack" => {
                                f_print_col_black =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"wpSpaceWidth" => {
                                f_wp_space_width =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"showBreaksInFrames" => {
                                f_show_breaks_in_frames =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"subFontBySize" => {
                                f_sub_font_by_size =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"suppressBottomSpacing" => {
                                f_suppress_bottom_spacing =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"suppressTopSpacing" => {
                                f_suppress_top_spacing =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"suppressSpacingAtTopOfPage" => {
                                f_suppress_spacing_at_top_of_page =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"suppressTopSpacingWP" => {
                                f_suppress_top_spacing_w_p =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"suppressSpBfAfterPgBrk" => {
                                f_suppress_sp_bf_after_pg_brk =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"swapBordersFacingPages" => {
                                f_swap_borders_facing_pages =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"convMailMergeEsc" => {
                                f_conv_mail_merge_esc =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"truncateFontHeightsLikeWP6" => {
                                f_truncate_font_heights_like_w_p6 =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"mwSmallCaps" => {
                                f_mw_small_caps =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"usePrinterMetrics" => {
                                f_use_printer_metrics =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotSuppressParagraphBorders" => {
                                f_do_not_suppress_paragraph_borders =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"wrapTrailSpaces" => {
                                f_wrap_trail_spaces =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"footnoteLayoutLikeWW8" => {
                                f_footnote_layout_like_w_w8 =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shapeLayoutLikeWW8" => {
                                f_shape_layout_like_w_w8 =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"alignTablesRowByRow" => {
                                f_align_tables_row_by_row =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"forgetLastTabAlignment" => {
                                f_forget_last_tab_alignment =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"adjustLineHeightInTable" => {
                                f_adjust_line_height_in_table =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"autoSpaceLikeWord95" => {
                                f_auto_space_like_word95 =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noSpaceRaiseLower" => {
                                f_no_space_raise_lower =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotUseHTMLParagraphAutoSpacing" => {
                                f_do_not_use_h_t_m_l_paragraph_auto_spacing =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"layoutRawTableWidth" => {
                                f_layout_raw_table_width =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"layoutTableRowsApart" => {
                                f_layout_table_rows_apart =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"useWord97LineBreakRules" => {
                                f_use_word97_line_break_rules =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotBreakWrappedTables" => {
                                f_do_not_break_wrapped_tables =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotSnapToGridInCell" => {
                                f_do_not_snap_to_grid_in_cell =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"selectFldWithFirstOrLastChar" => {
                                f_select_fld_with_first_or_last_char =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"applyBreakingRules" => {
                                f_apply_breaking_rules =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotWrapTextWithPunct" => {
                                f_do_not_wrap_text_with_punct =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotUseEastAsianBreakRules" => {
                                f_do_not_use_east_asian_break_rules =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"useWord2002TableStyleRules" => {
                                f_use_word2002_table_style_rules =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"growAutofit" => {
                                f_grow_autofit =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"useFELayout" => {
                                f_use_f_e_layout =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"useNormalStyleForList" => {
                                f_use_normal_style_for_list =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotUseIndentAsNumberingTabStop" => {
                                f_do_not_use_indent_as_numbering_tab_stop =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"useAltKinsokuLineBreakRules" => {
                                f_use_alt_kinsoku_line_break_rules =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"allowSpaceOfSameStyleInTable" => {
                                f_allow_space_of_same_style_in_table =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotSuppressIndentation" => {
                                f_do_not_suppress_indentation =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotAutofitConstrainedTables" => {
                                f_do_not_autofit_constrained_tables =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"autofitToFirstFixedWidthCell" => {
                                f_autofit_to_first_fixed_width_cell =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"underlineTabInNumList" => {
                                f_underline_tab_in_num_list =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"displayHangulFixedWidth" => {
                                f_display_hangul_fixed_width =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"splitPgBreakAndParaMark" => {
                                f_split_pg_break_and_para_mark =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotVertAlignCellWithSp" => {
                                f_do_not_vert_align_cell_with_sp =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotBreakConstrainedForcedTable" => {
                                f_do_not_break_constrained_forced_table =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotVertAlignInTxbx" => {
                                f_do_not_vert_align_in_txbx =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"useAnsiKerningPairs" => {
                                f_use_ansi_kerning_pairs =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cachedColBalance" => {
                                f_cached_col_balance =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"compatSetting" => {
                                f_compat_setting
                                    .push(Box::new(CTCompatSetting::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            use_single_borderfor_contiguous_cells: f_use_single_borderfor_contiguous_cells,
            wp_justification: f_wp_justification,
            no_tab_hang_ind: f_no_tab_hang_ind,
            no_leading: f_no_leading,
            space_for_u_l: f_space_for_u_l,
            no_column_balance: f_no_column_balance,
            balance_single_byte_double_byte_width: f_balance_single_byte_double_byte_width,
            no_extra_line_spacing: f_no_extra_line_spacing,
            do_not_leave_backslash_alone: f_do_not_leave_backslash_alone,
            ul_trail_space: f_ul_trail_space,
            do_not_expand_shift_return: f_do_not_expand_shift_return,
            spacing_in_whole_points: f_spacing_in_whole_points,
            line_wrap_like_word6: f_line_wrap_like_word6,
            print_body_text_before_header: f_print_body_text_before_header,
            print_col_black: f_print_col_black,
            wp_space_width: f_wp_space_width,
            show_breaks_in_frames: f_show_breaks_in_frames,
            sub_font_by_size: f_sub_font_by_size,
            suppress_bottom_spacing: f_suppress_bottom_spacing,
            suppress_top_spacing: f_suppress_top_spacing,
            suppress_spacing_at_top_of_page: f_suppress_spacing_at_top_of_page,
            suppress_top_spacing_w_p: f_suppress_top_spacing_w_p,
            suppress_sp_bf_after_pg_brk: f_suppress_sp_bf_after_pg_brk,
            swap_borders_facing_pages: f_swap_borders_facing_pages,
            conv_mail_merge_esc: f_conv_mail_merge_esc,
            truncate_font_heights_like_w_p6: f_truncate_font_heights_like_w_p6,
            mw_small_caps: f_mw_small_caps,
            use_printer_metrics: f_use_printer_metrics,
            do_not_suppress_paragraph_borders: f_do_not_suppress_paragraph_borders,
            wrap_trail_spaces: f_wrap_trail_spaces,
            footnote_layout_like_w_w8: f_footnote_layout_like_w_w8,
            shape_layout_like_w_w8: f_shape_layout_like_w_w8,
            align_tables_row_by_row: f_align_tables_row_by_row,
            forget_last_tab_alignment: f_forget_last_tab_alignment,
            adjust_line_height_in_table: f_adjust_line_height_in_table,
            auto_space_like_word95: f_auto_space_like_word95,
            no_space_raise_lower: f_no_space_raise_lower,
            do_not_use_h_t_m_l_paragraph_auto_spacing: f_do_not_use_h_t_m_l_paragraph_auto_spacing,
            layout_raw_table_width: f_layout_raw_table_width,
            layout_table_rows_apart: f_layout_table_rows_apart,
            use_word97_line_break_rules: f_use_word97_line_break_rules,
            do_not_break_wrapped_tables: f_do_not_break_wrapped_tables,
            do_not_snap_to_grid_in_cell: f_do_not_snap_to_grid_in_cell,
            select_fld_with_first_or_last_char: f_select_fld_with_first_or_last_char,
            apply_breaking_rules: f_apply_breaking_rules,
            do_not_wrap_text_with_punct: f_do_not_wrap_text_with_punct,
            do_not_use_east_asian_break_rules: f_do_not_use_east_asian_break_rules,
            use_word2002_table_style_rules: f_use_word2002_table_style_rules,
            grow_autofit: f_grow_autofit,
            use_f_e_layout: f_use_f_e_layout,
            use_normal_style_for_list: f_use_normal_style_for_list,
            do_not_use_indent_as_numbering_tab_stop: f_do_not_use_indent_as_numbering_tab_stop,
            use_alt_kinsoku_line_break_rules: f_use_alt_kinsoku_line_break_rules,
            allow_space_of_same_style_in_table: f_allow_space_of_same_style_in_table,
            do_not_suppress_indentation: f_do_not_suppress_indentation,
            do_not_autofit_constrained_tables: f_do_not_autofit_constrained_tables,
            autofit_to_first_fixed_width_cell: f_autofit_to_first_fixed_width_cell,
            underline_tab_in_num_list: f_underline_tab_in_num_list,
            display_hangul_fixed_width: f_display_hangul_fixed_width,
            split_pg_break_and_para_mark: f_split_pg_break_and_para_mark,
            do_not_vert_align_cell_with_sp: f_do_not_vert_align_cell_with_sp,
            do_not_break_constrained_forced_table: f_do_not_break_constrained_forced_table,
            do_not_vert_align_in_txbx: f_do_not_vert_align_in_txbx,
            use_ansi_kerning_pairs: f_use_ansi_kerning_pairs,
            cached_col_balance: f_cached_col_balance,
            compat_setting: f_compat_setting,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTCompatSetting {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name = None;
        let mut f_uri = None;
        let mut f_value = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"uri" => {
                    f_uri = Some(val.into_owned());
                }
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name,
            uri: f_uri,
            value: f_value,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTDocVar {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name: Option<STString> = None;
        let mut f_value: Option<STString> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTDocVars {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_doc_var = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"docVar" => {
                                f_doc_var.push(Box::new(CTDocVar::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"docVar" => {
                                f_doc_var.push(Box::new(CTDocVar::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            doc_var: f_doc_var,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTDocRsids {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_rsid_root = None;
        let mut f_rsid = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"rsidRoot" => {
                                f_rsid_root =
                                    Some(Box::new(CTLongHexNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rsid" => {
                                f_rsid
                                    .push(Box::new(CTLongHexNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"rsidRoot" => {
                                f_rsid_root =
                                    Some(Box::new(CTLongHexNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rsid" => {
                                f_rsid.push(Box::new(CTLongHexNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            rsid_root: f_rsid_root,
            rsid: f_rsid,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTCharacterSpacing {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STCharacterSpacing> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTSaveThroughXslt {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_solution_i_d = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"solutionID" => {
                    f_solution_i_d = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            solution_i_d: f_solution_i_d,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTRPrDefault {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_r_pr = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"rPr" => {
                                f_r_pr =
                                    Some(Box::new(RunProperties::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"rPr" => {
                                f_r_pr = Some(Box::new(RunProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r_pr: f_r_pr,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTPPrDefault {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_p_pr = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"pPr" => {
                                f_p_pr = Some(Box::new(CTPPrGeneral::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"pPr" => {
                                f_p_pr = Some(Box::new(CTPPrGeneral::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            p_pr: f_p_pr,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTDocDefaults {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_r_pr_default = None;
        let mut f_p_pr_default = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"rPrDefault" => {
                                f_r_pr_default =
                                    Some(Box::new(CTRPrDefault::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pPrDefault" => {
                                f_p_pr_default =
                                    Some(Box::new(CTPPrDefault::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"rPrDefault" => {
                                f_r_pr_default =
                                    Some(Box::new(CTRPrDefault::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pPrDefault" => {
                                f_p_pr_default =
                                    Some(Box::new(CTPPrDefault::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r_pr_default: f_r_pr_default,
            p_pr_default: f_p_pr_default,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTColorSchemeMapping {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_bg1 = None;
        let mut f_t1 = None;
        let mut f_bg2 = None;
        let mut f_t2 = None;
        let mut f_accent1 = None;
        let mut f_accent2 = None;
        let mut f_accent3 = None;
        let mut f_accent4 = None;
        let mut f_accent5 = None;
        let mut f_accent6 = None;
        let mut f_hyperlink = None;
        let mut f_followed_hyperlink = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"bg1" => {
                    f_bg1 = val.parse().ok();
                }
                b"t1" => {
                    f_t1 = val.parse().ok();
                }
                b"bg2" => {
                    f_bg2 = val.parse().ok();
                }
                b"t2" => {
                    f_t2 = val.parse().ok();
                }
                b"accent1" => {
                    f_accent1 = val.parse().ok();
                }
                b"accent2" => {
                    f_accent2 = val.parse().ok();
                }
                b"accent3" => {
                    f_accent3 = val.parse().ok();
                }
                b"accent4" => {
                    f_accent4 = val.parse().ok();
                }
                b"accent5" => {
                    f_accent5 = val.parse().ok();
                }
                b"accent6" => {
                    f_accent6 = val.parse().ok();
                }
                b"hyperlink" => {
                    f_hyperlink = val.parse().ok();
                }
                b"followedHyperlink" => {
                    f_followed_hyperlink = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            bg1: f_bg1,
            t1: f_t1,
            bg2: f_bg2,
            t2: f_t2,
            accent1: f_accent1,
            accent2: f_accent2,
            accent3: f_accent3,
            accent4: f_accent4,
            accent5: f_accent5,
            accent6: f_accent6,
            hyperlink: f_hyperlink,
            followed_hyperlink: f_followed_hyperlink,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTReadingModeInkLockDown {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_actual_pg: Option<OnOff> = None;
        let mut f_width: Option<STPixelsMeasure> = None;
        let mut f_height: Option<STPixelsMeasure> = None;
        let mut f_font_sz: Option<STDecimalNumberOrPercent> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"actualPg" => {
                    f_actual_pg = Some(val.into_owned());
                }
                b"w" => {
                    f_width = val.parse().ok();
                }
                b"h" => {
                    f_height = val.parse().ok();
                }
                b"fontSz" => {
                    f_font_sz = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            actual_pg: f_actual_pg
                .ok_or_else(|| ParseError::MissingAttribute("actualPg".to_string()))?,
            width: f_width.ok_or_else(|| ParseError::MissingAttribute("w".to_string()))?,
            height: f_height.ok_or_else(|| ParseError::MissingAttribute("h".to_string()))?,
            font_sz: f_font_sz.ok_or_else(|| ParseError::MissingAttribute("fontSz".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTWriteProtection {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_recommended = None;
        let mut f_algorithm_name = None;
        let mut f_hash_value = None;
        let mut f_salt_value = None;
        let mut f_spin_count = None;
        let mut f_crypt_provider_type = None;
        let mut f_crypt_algorithm_class = None;
        let mut f_crypt_algorithm_type = None;
        let mut f_crypt_algorithm_sid = None;
        let mut f_crypt_spin_count = None;
        let mut f_crypt_provider = None;
        let mut f_alg_id_ext = None;
        let mut f_alg_id_ext_source = None;
        let mut f_crypt_provider_type_ext = None;
        let mut f_crypt_provider_type_ext_source = None;
        let mut f_hash = None;
        let mut f_salt = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"recommended" => {
                    f_recommended = Some(val.into_owned());
                }
                b"algorithmName" => {
                    f_algorithm_name = Some(val.into_owned());
                }
                b"hashValue" => {
                    f_hash_value = decode_hex(&val);
                }
                b"saltValue" => {
                    f_salt_value = decode_hex(&val);
                }
                b"spinCount" => {
                    f_spin_count = val.parse().ok();
                }
                b"cryptProviderType" => {
                    f_crypt_provider_type = val.parse().ok();
                }
                b"cryptAlgorithmClass" => {
                    f_crypt_algorithm_class = val.parse().ok();
                }
                b"cryptAlgorithmType" => {
                    f_crypt_algorithm_type = val.parse().ok();
                }
                b"cryptAlgorithmSid" => {
                    f_crypt_algorithm_sid = val.parse().ok();
                }
                b"cryptSpinCount" => {
                    f_crypt_spin_count = val.parse().ok();
                }
                b"cryptProvider" => {
                    f_crypt_provider = Some(val.into_owned());
                }
                b"algIdExt" => {
                    f_alg_id_ext = decode_hex(&val);
                }
                b"algIdExtSource" => {
                    f_alg_id_ext_source = Some(val.into_owned());
                }
                b"cryptProviderTypeExt" => {
                    f_crypt_provider_type_ext = decode_hex(&val);
                }
                b"cryptProviderTypeExtSource" => {
                    f_crypt_provider_type_ext_source = Some(val.into_owned());
                }
                b"hash" => {
                    f_hash = decode_hex(&val);
                }
                b"salt" => {
                    f_salt = decode_hex(&val);
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            recommended: f_recommended,
            algorithm_name: f_algorithm_name,
            hash_value: f_hash_value,
            salt_value: f_salt_value,
            spin_count: f_spin_count,
            crypt_provider_type: f_crypt_provider_type,
            crypt_algorithm_class: f_crypt_algorithm_class,
            crypt_algorithm_type: f_crypt_algorithm_type,
            crypt_algorithm_sid: f_crypt_algorithm_sid,
            crypt_spin_count: f_crypt_spin_count,
            crypt_provider: f_crypt_provider,
            alg_id_ext: f_alg_id_ext,
            alg_id_ext_source: f_alg_id_ext_source,
            crypt_provider_type_ext: f_crypt_provider_type_ext,
            crypt_provider_type_ext_source: f_crypt_provider_type_ext_source,
            hash: f_hash,
            salt: f_salt,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for Settings {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "wml-settings")]
        let mut f_write_protection = None;
        #[cfg(feature = "wml-settings")]
        let mut f_view = None;
        #[cfg(feature = "wml-settings")]
        let mut f_zoom = None;
        let mut f_remove_personal_information = None;
        let mut f_remove_date_and_time = None;
        let mut f_do_not_display_page_boundaries = None;
        let mut f_display_background_shape = None;
        let mut f_print_post_script_over_text = None;
        let mut f_print_fractional_character_width = None;
        let mut f_print_forms_data = None;
        let mut f_embed_true_type_fonts = None;
        let mut f_embed_system_fonts = None;
        let mut f_save_subset_fonts = None;
        let mut f_save_forms_data = None;
        let mut f_mirror_margins = None;
        let mut f_align_borders_and_edges = None;
        let mut f_borders_do_not_surround_header = None;
        let mut f_borders_do_not_surround_footer = None;
        let mut f_gutter_at_top = None;
        let mut f_hide_spelling_errors = None;
        let mut f_hide_grammatical_errors = None;
        let mut f_active_writing_style = Vec::new();
        let mut f_proof_state = None;
        let mut f_forms_design = None;
        #[cfg(feature = "wml-settings")]
        let mut f_attached_template = None;
        let mut f_link_styles = None;
        let mut f_style_pane_format_filter = None;
        let mut f_style_pane_sort_method = None;
        let mut f_document_type = None;
        #[cfg(feature = "wml-settings")]
        let mut f_mail_merge = None;
        #[cfg(feature = "wml-settings")]
        let mut f_revision_view = None;
        #[cfg(feature = "wml-settings")]
        let mut f_track_revisions = None;
        let mut f_do_not_track_moves = None;
        let mut f_do_not_track_formatting = None;
        #[cfg(feature = "wml-settings")]
        let mut f_document_protection = None;
        let mut f_auto_format_override = None;
        let mut f_style_lock_theme = None;
        let mut f_style_lock_q_f_set = None;
        #[cfg(feature = "wml-settings")]
        let mut f_default_tab_stop = None;
        let mut f_auto_hyphenation = None;
        let mut f_consecutive_hyphen_limit = None;
        let mut f_hyphenation_zone = None;
        let mut f_do_not_hyphenate_caps = None;
        let mut f_show_envelope = None;
        let mut f_summary_length = None;
        let mut f_click_and_type_style = None;
        let mut f_default_table_style = None;
        #[cfg(feature = "wml-settings")]
        let mut f_even_and_odd_headers = None;
        let mut f_book_fold_rev_printing = None;
        let mut f_book_fold_printing = None;
        let mut f_book_fold_printing_sheets = None;
        let mut f_drawing_grid_horizontal_spacing = None;
        let mut f_drawing_grid_vertical_spacing = None;
        let mut f_display_horizontal_drawing_grid_every = None;
        let mut f_display_vertical_drawing_grid_every = None;
        let mut f_do_not_use_margins_for_drawing_grid_origin = None;
        let mut f_drawing_grid_horizontal_origin = None;
        let mut f_drawing_grid_vertical_origin = None;
        let mut f_do_not_shade_form_data = None;
        let mut f_no_punctuation_kerning = None;
        let mut f_character_spacing_control = None;
        let mut f_print_two_on_one = None;
        let mut f_strict_first_and_last_chars = None;
        let mut f_no_line_breaks_after = None;
        let mut f_no_line_breaks_before = None;
        let mut f_save_preview_picture = None;
        let mut f_do_not_validate_against_schema = None;
        let mut f_save_invalid_xml = None;
        let mut f_ignore_mixed_content = None;
        let mut f_always_show_placeholder_text = None;
        let mut f_do_not_demarcate_invalid_xml = None;
        let mut f_save_xml_data_only = None;
        let mut f_use_x_s_l_t_when_saving = None;
        let mut f_save_through_xslt = None;
        let mut f_show_x_m_l_tags = None;
        let mut f_always_merge_empty_namespace = None;
        let mut f_update_fields = None;
        let mut f_hdr_shape_defaults = None;
        let mut f_footnote_pr = None;
        let mut f_endnote_pr = None;
        #[cfg(feature = "wml-settings")]
        let mut f_compat = None;
        #[cfg(feature = "wml-settings")]
        let mut f_doc_vars = None;
        #[cfg(feature = "wml-settings")]
        let mut f_rsids = None;
        let mut f_attached_schema = Vec::new();
        let mut f_theme_font_lang = None;
        let mut f_clr_scheme_mapping = None;
        let mut f_do_not_include_subdocs_in_stats = None;
        let mut f_do_not_auto_compress_pictures = None;
        let mut f_force_upgrade = None;
        let mut f_captions = None;
        let mut f_read_mode_ink_lock_down = None;
        let mut f_smart_tag_type = Vec::new();
        let mut f_shape_defaults = None;
        let mut f_do_not_embed_smart_tags = None;
        let mut f_decimal_symbol = None;
        let mut f_list_separator = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "wml-settings")]
                            b"writeProtection" => {
                                f_write_protection =
                                    Some(Box::new(CTWriteProtection::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-settings")]
                            b"view" => {
                                f_view = Some(Box::new(CTView::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-settings")]
                            b"zoom" => {
                                f_zoom = Some(Box::new(CTZoom::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"removePersonalInformation" => {
                                f_remove_personal_information =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"removeDateAndTime" => {
                                f_remove_date_and_time =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotDisplayPageBoundaries" => {
                                f_do_not_display_page_boundaries =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"displayBackgroundShape" => {
                                f_display_background_shape =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"printPostScriptOverText" => {
                                f_print_post_script_over_text =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"printFractionalCharacterWidth" => {
                                f_print_fractional_character_width =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"printFormsData" => {
                                f_print_forms_data =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"embedTrueTypeFonts" => {
                                f_embed_true_type_fonts =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"embedSystemFonts" => {
                                f_embed_system_fonts =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"saveSubsetFonts" => {
                                f_save_subset_fonts =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"saveFormsData" => {
                                f_save_forms_data =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"mirrorMargins" => {
                                f_mirror_margins =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"alignBordersAndEdges" => {
                                f_align_borders_and_edges =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bordersDoNotSurroundHeader" => {
                                f_borders_do_not_surround_header =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bordersDoNotSurroundFooter" => {
                                f_borders_do_not_surround_footer =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"gutterAtTop" => {
                                f_gutter_at_top =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"hideSpellingErrors" => {
                                f_hide_spelling_errors =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"hideGrammaticalErrors" => {
                                f_hide_grammatical_errors =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"activeWritingStyle" => {
                                f_active_writing_style
                                    .push(Box::new(CTWritingStyle::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"proofState" => {
                                f_proof_state =
                                    Some(Box::new(CTProof::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"formsDesign" => {
                                f_forms_design =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-settings")]
                            b"attachedTemplate" => {
                                f_attached_template =
                                    Some(Box::new(CTRel::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"linkStyles" => {
                                f_link_styles =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"stylePaneFormatFilter" => {
                                f_style_pane_format_filter =
                                    Some(Box::new(CTStylePaneFilter::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"stylePaneSortMethod" => {
                                f_style_pane_sort_method =
                                    Some(Box::new(CTStyleSort::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"documentType" => {
                                f_document_type =
                                    Some(Box::new(CTDocType::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-settings")]
                            b"mailMerge" => {
                                f_mail_merge =
                                    Some(Box::new(CTMailMerge::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-settings")]
                            b"revisionView" => {
                                f_revision_view = Some(Box::new(CTTrackChangesView::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-settings")]
                            b"trackRevisions" => {
                                f_track_revisions =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotTrackMoves" => {
                                f_do_not_track_moves =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotTrackFormatting" => {
                                f_do_not_track_formatting =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-settings")]
                            b"documentProtection" => {
                                f_document_protection =
                                    Some(Box::new(CTDocProtect::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"autoFormatOverride" => {
                                f_auto_format_override =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"styleLockTheme" => {
                                f_style_lock_theme =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"styleLockQFSet" => {
                                f_style_lock_q_f_set =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-settings")]
                            b"defaultTabStop" => {
                                f_default_tab_stop =
                                    Some(Box::new(CTTwipsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"autoHyphenation" => {
                                f_auto_hyphenation =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"consecutiveHyphenLimit" => {
                                f_consecutive_hyphen_limit =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"hyphenationZone" => {
                                f_hyphenation_zone =
                                    Some(Box::new(CTTwipsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotHyphenateCaps" => {
                                f_do_not_hyphenate_caps =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"showEnvelope" => {
                                f_show_envelope =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"summaryLength" => {
                                f_summary_length = Some(Box::new(
                                    CTDecimalNumberOrPrecent::from_xml(reader, &e, false)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"clickAndTypeStyle" => {
                                f_click_and_type_style =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"defaultTableStyle" => {
                                f_default_table_style =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-settings")]
                            b"evenAndOddHeaders" => {
                                f_even_and_odd_headers =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bookFoldRevPrinting" => {
                                f_book_fold_rev_printing =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bookFoldPrinting" => {
                                f_book_fold_printing =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bookFoldPrintingSheets" => {
                                f_book_fold_printing_sheets =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"drawingGridHorizontalSpacing" => {
                                f_drawing_grid_horizontal_spacing =
                                    Some(Box::new(CTTwipsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"drawingGridVerticalSpacing" => {
                                f_drawing_grid_vertical_spacing =
                                    Some(Box::new(CTTwipsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"displayHorizontalDrawingGridEvery" => {
                                f_display_horizontal_drawing_grid_every =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"displayVerticalDrawingGridEvery" => {
                                f_display_vertical_drawing_grid_every =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotUseMarginsForDrawingGridOrigin" => {
                                f_do_not_use_margins_for_drawing_grid_origin =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"drawingGridHorizontalOrigin" => {
                                f_drawing_grid_horizontal_origin =
                                    Some(Box::new(CTTwipsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"drawingGridVerticalOrigin" => {
                                f_drawing_grid_vertical_origin =
                                    Some(Box::new(CTTwipsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotShadeFormData" => {
                                f_do_not_shade_form_data =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noPunctuationKerning" => {
                                f_no_punctuation_kerning =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"characterSpacingControl" => {
                                f_character_spacing_control = Some(Box::new(
                                    CTCharacterSpacing::from_xml(reader, &e, false)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"printTwoOnOne" => {
                                f_print_two_on_one =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"strictFirstAndLastChars" => {
                                f_strict_first_and_last_chars =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noLineBreaksAfter" => {
                                f_no_line_breaks_after =
                                    Some(Box::new(CTKinsoku::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noLineBreaksBefore" => {
                                f_no_line_breaks_before =
                                    Some(Box::new(CTKinsoku::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"savePreviewPicture" => {
                                f_save_preview_picture =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotValidateAgainstSchema" => {
                                f_do_not_validate_against_schema =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"saveInvalidXml" => {
                                f_save_invalid_xml =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"ignoreMixedContent" => {
                                f_ignore_mixed_content =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"alwaysShowPlaceholderText" => {
                                f_always_show_placeholder_text =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotDemarcateInvalidXml" => {
                                f_do_not_demarcate_invalid_xml =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"saveXmlDataOnly" => {
                                f_save_xml_data_only =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"useXSLTWhenSaving" => {
                                f_use_x_s_l_t_when_saving =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"saveThroughXslt" => {
                                f_save_through_xslt =
                                    Some(Box::new(CTSaveThroughXslt::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"showXMLTags" => {
                                f_show_x_m_l_tags =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"alwaysMergeEmptyNamespace" => {
                                f_always_merge_empty_namespace =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"updateFields" => {
                                f_update_fields =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"hdrShapeDefaults" => {
                                f_hdr_shape_defaults =
                                    Some(Box::new(CTShapeDefaults::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"footnotePr" => {
                                f_footnote_pr =
                                    Some(Box::new(CTFtnDocProps::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"endnotePr" => {
                                f_endnote_pr =
                                    Some(Box::new(CTEdnDocProps::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-settings")]
                            b"compat" => {
                                f_compat =
                                    Some(Box::new(Compatibility::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-settings")]
                            b"docVars" => {
                                f_doc_vars =
                                    Some(Box::new(CTDocVars::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-settings")]
                            b"rsids" => {
                                f_rsids = Some(Box::new(CTDocRsids::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"attachedSchema" => {
                                f_attached_schema
                                    .push(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"themeFontLang" => {
                                f_theme_font_lang =
                                    Some(Box::new(CTLanguage::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"clrSchemeMapping" => {
                                f_clr_scheme_mapping = Some(Box::new(
                                    CTColorSchemeMapping::from_xml(reader, &e, false)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotIncludeSubdocsInStats" => {
                                f_do_not_include_subdocs_in_stats =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotAutoCompressPictures" => {
                                f_do_not_auto_compress_pictures =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"forceUpgrade" => {
                                f_force_upgrade =
                                    Some(Box::new(CTEmpty::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"captions" => {
                                f_captions =
                                    Some(Box::new(CTCaptions::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"readModeInkLockDown" => {
                                f_read_mode_ink_lock_down = Some(Box::new(
                                    CTReadingModeInkLockDown::from_xml(reader, &e, false)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"smartTagType" => {
                                f_smart_tag_type
                                    .push(Box::new(CTSmartTagType::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shapeDefaults" => {
                                f_shape_defaults =
                                    Some(Box::new(CTShapeDefaults::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotEmbedSmartTags" => {
                                f_do_not_embed_smart_tags =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"decimalSymbol" => {
                                f_decimal_symbol =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"listSeparator" => {
                                f_list_separator =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "wml-settings")]
                            b"writeProtection" => {
                                f_write_protection =
                                    Some(Box::new(CTWriteProtection::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-settings")]
                            b"view" => {
                                f_view = Some(Box::new(CTView::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-settings")]
                            b"zoom" => {
                                f_zoom = Some(Box::new(CTZoom::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"removePersonalInformation" => {
                                f_remove_personal_information =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"removeDateAndTime" => {
                                f_remove_date_and_time =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotDisplayPageBoundaries" => {
                                f_do_not_display_page_boundaries =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"displayBackgroundShape" => {
                                f_display_background_shape =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"printPostScriptOverText" => {
                                f_print_post_script_over_text =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"printFractionalCharacterWidth" => {
                                f_print_fractional_character_width =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"printFormsData" => {
                                f_print_forms_data =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"embedTrueTypeFonts" => {
                                f_embed_true_type_fonts =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"embedSystemFonts" => {
                                f_embed_system_fonts =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"saveSubsetFonts" => {
                                f_save_subset_fonts =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"saveFormsData" => {
                                f_save_forms_data =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"mirrorMargins" => {
                                f_mirror_margins =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"alignBordersAndEdges" => {
                                f_align_borders_and_edges =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bordersDoNotSurroundHeader" => {
                                f_borders_do_not_surround_header =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bordersDoNotSurroundFooter" => {
                                f_borders_do_not_surround_footer =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"gutterAtTop" => {
                                f_gutter_at_top =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"hideSpellingErrors" => {
                                f_hide_spelling_errors =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"hideGrammaticalErrors" => {
                                f_hide_grammatical_errors =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"activeWritingStyle" => {
                                f_active_writing_style
                                    .push(Box::new(CTWritingStyle::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"proofState" => {
                                f_proof_state =
                                    Some(Box::new(CTProof::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"formsDesign" => {
                                f_forms_design =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-settings")]
                            b"attachedTemplate" => {
                                f_attached_template =
                                    Some(Box::new(CTRel::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"linkStyles" => {
                                f_link_styles =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"stylePaneFormatFilter" => {
                                f_style_pane_format_filter =
                                    Some(Box::new(CTStylePaneFilter::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"stylePaneSortMethod" => {
                                f_style_pane_sort_method =
                                    Some(Box::new(CTStyleSort::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"documentType" => {
                                f_document_type =
                                    Some(Box::new(CTDocType::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-settings")]
                            b"mailMerge" => {
                                f_mail_merge =
                                    Some(Box::new(CTMailMerge::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-settings")]
                            b"revisionView" => {
                                f_revision_view =
                                    Some(Box::new(CTTrackChangesView::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-settings")]
                            b"trackRevisions" => {
                                f_track_revisions =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotTrackMoves" => {
                                f_do_not_track_moves =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotTrackFormatting" => {
                                f_do_not_track_formatting =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-settings")]
                            b"documentProtection" => {
                                f_document_protection =
                                    Some(Box::new(CTDocProtect::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"autoFormatOverride" => {
                                f_auto_format_override =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"styleLockTheme" => {
                                f_style_lock_theme =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"styleLockQFSet" => {
                                f_style_lock_q_f_set =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-settings")]
                            b"defaultTabStop" => {
                                f_default_tab_stop =
                                    Some(Box::new(CTTwipsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"autoHyphenation" => {
                                f_auto_hyphenation =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"consecutiveHyphenLimit" => {
                                f_consecutive_hyphen_limit =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"hyphenationZone" => {
                                f_hyphenation_zone =
                                    Some(Box::new(CTTwipsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotHyphenateCaps" => {
                                f_do_not_hyphenate_caps =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"showEnvelope" => {
                                f_show_envelope =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"summaryLength" => {
                                f_summary_length = Some(Box::new(
                                    CTDecimalNumberOrPrecent::from_xml(reader, &e, true)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"clickAndTypeStyle" => {
                                f_click_and_type_style =
                                    Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"defaultTableStyle" => {
                                f_default_table_style =
                                    Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-settings")]
                            b"evenAndOddHeaders" => {
                                f_even_and_odd_headers =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bookFoldRevPrinting" => {
                                f_book_fold_rev_printing =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bookFoldPrinting" => {
                                f_book_fold_printing =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bookFoldPrintingSheets" => {
                                f_book_fold_printing_sheets =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"drawingGridHorizontalSpacing" => {
                                f_drawing_grid_horizontal_spacing =
                                    Some(Box::new(CTTwipsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"drawingGridVerticalSpacing" => {
                                f_drawing_grid_vertical_spacing =
                                    Some(Box::new(CTTwipsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"displayHorizontalDrawingGridEvery" => {
                                f_display_horizontal_drawing_grid_every =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"displayVerticalDrawingGridEvery" => {
                                f_display_vertical_drawing_grid_every =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotUseMarginsForDrawingGridOrigin" => {
                                f_do_not_use_margins_for_drawing_grid_origin =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"drawingGridHorizontalOrigin" => {
                                f_drawing_grid_horizontal_origin =
                                    Some(Box::new(CTTwipsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"drawingGridVerticalOrigin" => {
                                f_drawing_grid_vertical_origin =
                                    Some(Box::new(CTTwipsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotShadeFormData" => {
                                f_do_not_shade_form_data =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noPunctuationKerning" => {
                                f_no_punctuation_kerning =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"characterSpacingControl" => {
                                f_character_spacing_control =
                                    Some(Box::new(CTCharacterSpacing::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"printTwoOnOne" => {
                                f_print_two_on_one =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"strictFirstAndLastChars" => {
                                f_strict_first_and_last_chars =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noLineBreaksAfter" => {
                                f_no_line_breaks_after =
                                    Some(Box::new(CTKinsoku::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noLineBreaksBefore" => {
                                f_no_line_breaks_before =
                                    Some(Box::new(CTKinsoku::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"savePreviewPicture" => {
                                f_save_preview_picture =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotValidateAgainstSchema" => {
                                f_do_not_validate_against_schema =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"saveInvalidXml" => {
                                f_save_invalid_xml =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"ignoreMixedContent" => {
                                f_ignore_mixed_content =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"alwaysShowPlaceholderText" => {
                                f_always_show_placeholder_text =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotDemarcateInvalidXml" => {
                                f_do_not_demarcate_invalid_xml =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"saveXmlDataOnly" => {
                                f_save_xml_data_only =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"useXSLTWhenSaving" => {
                                f_use_x_s_l_t_when_saving =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"saveThroughXslt" => {
                                f_save_through_xslt =
                                    Some(Box::new(CTSaveThroughXslt::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"showXMLTags" => {
                                f_show_x_m_l_tags =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"alwaysMergeEmptyNamespace" => {
                                f_always_merge_empty_namespace =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"updateFields" => {
                                f_update_fields =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"hdrShapeDefaults" => {
                                f_hdr_shape_defaults =
                                    Some(Box::new(CTShapeDefaults::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"footnotePr" => {
                                f_footnote_pr =
                                    Some(Box::new(CTFtnDocProps::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"endnotePr" => {
                                f_endnote_pr =
                                    Some(Box::new(CTEdnDocProps::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-settings")]
                            b"compat" => {
                                f_compat =
                                    Some(Box::new(Compatibility::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-settings")]
                            b"docVars" => {
                                f_doc_vars = Some(Box::new(CTDocVars::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-settings")]
                            b"rsids" => {
                                f_rsids = Some(Box::new(CTDocRsids::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"attachedSchema" => {
                                f_attached_schema
                                    .push(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"themeFontLang" => {
                                f_theme_font_lang =
                                    Some(Box::new(CTLanguage::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"clrSchemeMapping" => {
                                f_clr_scheme_mapping = Some(Box::new(
                                    CTColorSchemeMapping::from_xml(reader, &e, true)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotIncludeSubdocsInStats" => {
                                f_do_not_include_subdocs_in_stats =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotAutoCompressPictures" => {
                                f_do_not_auto_compress_pictures =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"forceUpgrade" => {
                                f_force_upgrade =
                                    Some(Box::new(CTEmpty::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"captions" => {
                                f_captions =
                                    Some(Box::new(CTCaptions::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"readModeInkLockDown" => {
                                f_read_mode_ink_lock_down = Some(Box::new(
                                    CTReadingModeInkLockDown::from_xml(reader, &e, true)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"smartTagType" => {
                                f_smart_tag_type
                                    .push(Box::new(CTSmartTagType::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shapeDefaults" => {
                                f_shape_defaults =
                                    Some(Box::new(CTShapeDefaults::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotEmbedSmartTags" => {
                                f_do_not_embed_smart_tags =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"decimalSymbol" => {
                                f_decimal_symbol =
                                    Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"listSeparator" => {
                                f_list_separator =
                                    Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            #[cfg(feature = "wml-settings")]
            write_protection: f_write_protection,
            #[cfg(feature = "wml-settings")]
            view: f_view,
            #[cfg(feature = "wml-settings")]
            zoom: f_zoom,
            remove_personal_information: f_remove_personal_information,
            remove_date_and_time: f_remove_date_and_time,
            do_not_display_page_boundaries: f_do_not_display_page_boundaries,
            display_background_shape: f_display_background_shape,
            print_post_script_over_text: f_print_post_script_over_text,
            print_fractional_character_width: f_print_fractional_character_width,
            print_forms_data: f_print_forms_data,
            embed_true_type_fonts: f_embed_true_type_fonts,
            embed_system_fonts: f_embed_system_fonts,
            save_subset_fonts: f_save_subset_fonts,
            save_forms_data: f_save_forms_data,
            mirror_margins: f_mirror_margins,
            align_borders_and_edges: f_align_borders_and_edges,
            borders_do_not_surround_header: f_borders_do_not_surround_header,
            borders_do_not_surround_footer: f_borders_do_not_surround_footer,
            gutter_at_top: f_gutter_at_top,
            hide_spelling_errors: f_hide_spelling_errors,
            hide_grammatical_errors: f_hide_grammatical_errors,
            active_writing_style: f_active_writing_style,
            proof_state: f_proof_state,
            forms_design: f_forms_design,
            #[cfg(feature = "wml-settings")]
            attached_template: f_attached_template,
            link_styles: f_link_styles,
            style_pane_format_filter: f_style_pane_format_filter,
            style_pane_sort_method: f_style_pane_sort_method,
            document_type: f_document_type,
            #[cfg(feature = "wml-settings")]
            mail_merge: f_mail_merge,
            #[cfg(feature = "wml-settings")]
            revision_view: f_revision_view,
            #[cfg(feature = "wml-settings")]
            track_revisions: f_track_revisions,
            do_not_track_moves: f_do_not_track_moves,
            do_not_track_formatting: f_do_not_track_formatting,
            #[cfg(feature = "wml-settings")]
            document_protection: f_document_protection,
            auto_format_override: f_auto_format_override,
            style_lock_theme: f_style_lock_theme,
            style_lock_q_f_set: f_style_lock_q_f_set,
            #[cfg(feature = "wml-settings")]
            default_tab_stop: f_default_tab_stop,
            auto_hyphenation: f_auto_hyphenation,
            consecutive_hyphen_limit: f_consecutive_hyphen_limit,
            hyphenation_zone: f_hyphenation_zone,
            do_not_hyphenate_caps: f_do_not_hyphenate_caps,
            show_envelope: f_show_envelope,
            summary_length: f_summary_length,
            click_and_type_style: f_click_and_type_style,
            default_table_style: f_default_table_style,
            #[cfg(feature = "wml-settings")]
            even_and_odd_headers: f_even_and_odd_headers,
            book_fold_rev_printing: f_book_fold_rev_printing,
            book_fold_printing: f_book_fold_printing,
            book_fold_printing_sheets: f_book_fold_printing_sheets,
            drawing_grid_horizontal_spacing: f_drawing_grid_horizontal_spacing,
            drawing_grid_vertical_spacing: f_drawing_grid_vertical_spacing,
            display_horizontal_drawing_grid_every: f_display_horizontal_drawing_grid_every,
            display_vertical_drawing_grid_every: f_display_vertical_drawing_grid_every,
            do_not_use_margins_for_drawing_grid_origin:
                f_do_not_use_margins_for_drawing_grid_origin,
            drawing_grid_horizontal_origin: f_drawing_grid_horizontal_origin,
            drawing_grid_vertical_origin: f_drawing_grid_vertical_origin,
            do_not_shade_form_data: f_do_not_shade_form_data,
            no_punctuation_kerning: f_no_punctuation_kerning,
            character_spacing_control: f_character_spacing_control,
            print_two_on_one: f_print_two_on_one,
            strict_first_and_last_chars: f_strict_first_and_last_chars,
            no_line_breaks_after: f_no_line_breaks_after,
            no_line_breaks_before: f_no_line_breaks_before,
            save_preview_picture: f_save_preview_picture,
            do_not_validate_against_schema: f_do_not_validate_against_schema,
            save_invalid_xml: f_save_invalid_xml,
            ignore_mixed_content: f_ignore_mixed_content,
            always_show_placeholder_text: f_always_show_placeholder_text,
            do_not_demarcate_invalid_xml: f_do_not_demarcate_invalid_xml,
            save_xml_data_only: f_save_xml_data_only,
            use_x_s_l_t_when_saving: f_use_x_s_l_t_when_saving,
            save_through_xslt: f_save_through_xslt,
            show_x_m_l_tags: f_show_x_m_l_tags,
            always_merge_empty_namespace: f_always_merge_empty_namespace,
            update_fields: f_update_fields,
            hdr_shape_defaults: f_hdr_shape_defaults,
            footnote_pr: f_footnote_pr,
            endnote_pr: f_endnote_pr,
            #[cfg(feature = "wml-settings")]
            compat: f_compat,
            #[cfg(feature = "wml-settings")]
            doc_vars: f_doc_vars,
            #[cfg(feature = "wml-settings")]
            rsids: f_rsids,
            attached_schema: f_attached_schema,
            theme_font_lang: f_theme_font_lang,
            clr_scheme_mapping: f_clr_scheme_mapping,
            do_not_include_subdocs_in_stats: f_do_not_include_subdocs_in_stats,
            do_not_auto_compress_pictures: f_do_not_auto_compress_pictures,
            force_upgrade: f_force_upgrade,
            captions: f_captions,
            read_mode_ink_lock_down: f_read_mode_ink_lock_down,
            smart_tag_type: f_smart_tag_type,
            shape_defaults: f_shape_defaults,
            do_not_embed_smart_tags: f_do_not_embed_smart_tags,
            decimal_symbol: f_decimal_symbol,
            list_separator: f_list_separator,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTStyleSort {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STStyleSort> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTStylePaneFilter {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_all_styles = None;
        let mut f_custom_styles = None;
        let mut f_latent_styles = None;
        let mut f_styles_in_use = None;
        let mut f_heading_styles = None;
        let mut f_numbering_styles = None;
        let mut f_table_styles = None;
        let mut f_direct_formatting_on_runs = None;
        let mut f_direct_formatting_on_paragraphs = None;
        let mut f_direct_formatting_on_numbering = None;
        let mut f_direct_formatting_on_tables = None;
        let mut f_clear_formatting = None;
        let mut f_top3_heading_styles = None;
        let mut f_visible_styles = None;
        let mut f_alternate_style_names = None;
        let mut f_value = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"allStyles" => {
                    f_all_styles = Some(val.into_owned());
                }
                b"customStyles" => {
                    f_custom_styles = Some(val.into_owned());
                }
                b"latentStyles" => {
                    f_latent_styles = Some(val.into_owned());
                }
                b"stylesInUse" => {
                    f_styles_in_use = Some(val.into_owned());
                }
                b"headingStyles" => {
                    f_heading_styles = Some(val.into_owned());
                }
                b"numberingStyles" => {
                    f_numbering_styles = Some(val.into_owned());
                }
                b"tableStyles" => {
                    f_table_styles = Some(val.into_owned());
                }
                b"directFormattingOnRuns" => {
                    f_direct_formatting_on_runs = Some(val.into_owned());
                }
                b"directFormattingOnParagraphs" => {
                    f_direct_formatting_on_paragraphs = Some(val.into_owned());
                }
                b"directFormattingOnNumbering" => {
                    f_direct_formatting_on_numbering = Some(val.into_owned());
                }
                b"directFormattingOnTables" => {
                    f_direct_formatting_on_tables = Some(val.into_owned());
                }
                b"clearFormatting" => {
                    f_clear_formatting = Some(val.into_owned());
                }
                b"top3HeadingStyles" => {
                    f_top3_heading_styles = Some(val.into_owned());
                }
                b"visibleStyles" => {
                    f_visible_styles = Some(val.into_owned());
                }
                b"alternateStyleNames" => {
                    f_alternate_style_names = Some(val.into_owned());
                }
                b"val" => {
                    f_value = decode_hex(&val);
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            all_styles: f_all_styles,
            custom_styles: f_custom_styles,
            latent_styles: f_latent_styles,
            styles_in_use: f_styles_in_use,
            heading_styles: f_heading_styles,
            numbering_styles: f_numbering_styles,
            table_styles: f_table_styles,
            direct_formatting_on_runs: f_direct_formatting_on_runs,
            direct_formatting_on_paragraphs: f_direct_formatting_on_paragraphs,
            direct_formatting_on_numbering: f_direct_formatting_on_numbering,
            direct_formatting_on_tables: f_direct_formatting_on_tables,
            clear_formatting: f_clear_formatting,
            top3_heading_styles: f_top3_heading_styles,
            visible_styles: f_visible_styles,
            alternate_style_names: f_alternate_style_names,
            value: f_value,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTWebSettings {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_frameset = None;
        let mut f_divs = None;
        let mut f_encoding = None;
        let mut f_optimize_for_browser = None;
        let mut f_rely_on_v_m_l = None;
        let mut f_allow_p_n_g = None;
        let mut f_do_not_rely_on_c_s_s = None;
        let mut f_do_not_save_as_single_file = None;
        let mut f_do_not_organize_in_folder = None;
        let mut f_do_not_use_long_file_names = None;
        let mut f_pixels_per_inch = None;
        let mut f_target_screen_sz = None;
        let mut f_save_smart_tags_as_xml = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"frameset" => {
                                f_frameset =
                                    Some(Box::new(CTFrameset::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"divs" => {
                                f_divs = Some(Box::new(CTDivs::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"encoding" => {
                                f_encoding = Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"optimizeForBrowser" => {
                                f_optimize_for_browser = Some(Box::new(
                                    CTOptimizeForBrowser::from_xml(reader, &e, false)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"relyOnVML" => {
                                f_rely_on_v_m_l =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"allowPNG" => {
                                f_allow_p_n_g =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotRelyOnCSS" => {
                                f_do_not_rely_on_c_s_s =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotSaveAsSingleFile" => {
                                f_do_not_save_as_single_file =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotOrganizeInFolder" => {
                                f_do_not_organize_in_folder =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotUseLongFileNames" => {
                                f_do_not_use_long_file_names =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pixelsPerInch" => {
                                f_pixels_per_inch =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"targetScreenSz" => {
                                f_target_screen_sz =
                                    Some(Box::new(CTTargetScreenSz::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"saveSmartTagsAsXml" => {
                                f_save_smart_tags_as_xml =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"frameset" => {
                                f_frameset =
                                    Some(Box::new(CTFrameset::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"divs" => {
                                f_divs = Some(Box::new(CTDivs::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"encoding" => {
                                f_encoding = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"optimizeForBrowser" => {
                                f_optimize_for_browser = Some(Box::new(
                                    CTOptimizeForBrowser::from_xml(reader, &e, true)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"relyOnVML" => {
                                f_rely_on_v_m_l =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"allowPNG" => {
                                f_allow_p_n_g =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotRelyOnCSS" => {
                                f_do_not_rely_on_c_s_s =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotSaveAsSingleFile" => {
                                f_do_not_save_as_single_file =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotOrganizeInFolder" => {
                                f_do_not_organize_in_folder =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"doNotUseLongFileNames" => {
                                f_do_not_use_long_file_names =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pixelsPerInch" => {
                                f_pixels_per_inch =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"targetScreenSz" => {
                                f_target_screen_sz =
                                    Some(Box::new(CTTargetScreenSz::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"saveSmartTagsAsXml" => {
                                f_save_smart_tags_as_xml =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            frameset: f_frameset,
            divs: f_divs,
            encoding: f_encoding,
            optimize_for_browser: f_optimize_for_browser,
            rely_on_v_m_l: f_rely_on_v_m_l,
            allow_p_n_g: f_allow_p_n_g,
            do_not_rely_on_c_s_s: f_do_not_rely_on_c_s_s,
            do_not_save_as_single_file: f_do_not_save_as_single_file,
            do_not_organize_in_folder: f_do_not_organize_in_folder,
            do_not_use_long_file_names: f_do_not_use_long_file_names,
            pixels_per_inch: f_pixels_per_inch,
            target_screen_sz: f_target_screen_sz,
            save_smart_tags_as_xml: f_save_smart_tags_as_xml,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTFrameScrollbar {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STFrameScrollbar> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTOptimizeForBrowser {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value = None;
        let mut f_target = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                b"target" => {
                    f_target = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value,
            target: f_target,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTFrame {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_size = None;
        let mut f_name = None;
        let mut f_title = None;
        let mut f_long_desc = None;
        let mut f_source_file_name = None;
        let mut f_mar_w = None;
        let mut f_mar_h = None;
        let mut f_scrollbar = None;
        let mut f_no_resize_allowed = None;
        let mut f_linked_to_file = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"sz" => {
                                f_size = Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"name" => {
                                f_name = Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"title" => {
                                f_title = Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"longDesc" => {
                                f_long_desc = Some(Box::new(CTRel::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sourceFileName" => {
                                f_source_file_name =
                                    Some(Box::new(CTRel::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"marW" => {
                                f_mar_w =
                                    Some(Box::new(CTPixelsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"marH" => {
                                f_mar_h =
                                    Some(Box::new(CTPixelsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"scrollbar" => {
                                f_scrollbar =
                                    Some(Box::new(CTFrameScrollbar::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noResizeAllowed" => {
                                f_no_resize_allowed =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"linkedToFile" => {
                                f_linked_to_file =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"sz" => {
                                f_size = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"name" => {
                                f_name = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"title" => {
                                f_title = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"longDesc" => {
                                f_long_desc = Some(Box::new(CTRel::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sourceFileName" => {
                                f_source_file_name =
                                    Some(Box::new(CTRel::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"marW" => {
                                f_mar_w =
                                    Some(Box::new(CTPixelsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"marH" => {
                                f_mar_h =
                                    Some(Box::new(CTPixelsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"scrollbar" => {
                                f_scrollbar =
                                    Some(Box::new(CTFrameScrollbar::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noResizeAllowed" => {
                                f_no_resize_allowed =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"linkedToFile" => {
                                f_linked_to_file =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            size: f_size,
            name: f_name,
            title: f_title,
            long_desc: f_long_desc,
            source_file_name: f_source_file_name,
            mar_w: f_mar_w,
            mar_h: f_mar_h,
            scrollbar: f_scrollbar,
            no_resize_allowed: f_no_resize_allowed,
            linked_to_file: f_linked_to_file,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTFrameLayout {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STFrameLayout> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTFramesetSplitbar {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_width = None;
        let mut f_color = None;
        let mut f_no_border = None;
        let mut f_flat_borders = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"w" => {
                                f_width =
                                    Some(Box::new(CTTwipsMeasure::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"color" => {
                                f_color = Some(Box::new(CTColor::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noBorder" => {
                                f_no_border = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"flatBorders" => {
                                f_flat_borders =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"w" => {
                                f_width =
                                    Some(Box::new(CTTwipsMeasure::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"color" => {
                                f_color = Some(Box::new(CTColor::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"noBorder" => {
                                f_no_border = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"flatBorders" => {
                                f_flat_borders =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            width: f_width,
            color: f_color,
            no_border: f_no_border,
            flat_borders: f_flat_borders,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTFrameset {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_size = None;
        let mut f_frameset_splitbar = None;
        let mut f_frame_layout = None;
        let mut f_title = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"sz" => {
                                f_size = Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"framesetSplitbar" => {
                                f_frameset_splitbar = Some(Box::new(CTFramesetSplitbar::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"frameLayout" => {
                                f_frame_layout =
                                    Some(Box::new(CTFrameLayout::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"title" => {
                                f_title = Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"sz" => {
                                f_size = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"framesetSplitbar" => {
                                f_frameset_splitbar =
                                    Some(Box::new(CTFramesetSplitbar::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"frameLayout" => {
                                f_frame_layout =
                                    Some(Box::new(CTFrameLayout::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"title" => {
                                f_title = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            size: f_size,
            frameset_splitbar: f_frameset_splitbar,
            frame_layout: f_frame_layout,
            title: f_title,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTNumPicBullet {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_num_pic_bullet_id: Option<STDecimalNumber> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"numPicBulletId" => {
                    f_num_pic_bullet_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            num_pic_bullet_id: f_num_pic_bullet_id
                .ok_or_else(|| ParseError::MissingAttribute("numPicBulletId".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTLevelSuffix {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STLevelSuffix> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTLevelText {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value = None;
        let mut f_null = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                b"null" => {
                    f_null = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value,
            null: f_null,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTLvlLegacy {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_legacy = None;
        let mut f_legacy_space = None;
        let mut f_legacy_indent = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"legacy" => {
                    f_legacy = Some(val.into_owned());
                }
                b"legacySpace" => {
                    f_legacy_space = Some(val.into_owned());
                }
                b"legacyIndent" => {
                    f_legacy_indent = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            legacy: f_legacy,
            legacy_space: f_legacy_space,
            legacy_indent: f_legacy_indent,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for Level {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_ilvl: Option<STDecimalNumber> = None;
        let mut f_tplc = None;
        let mut f_tentative = None;
        let mut f_start = None;
        let mut f_num_fmt = None;
        let mut f_lvl_restart = None;
        let mut f_paragraph_style = None;
        let mut f_is_lgl = None;
        let mut f_suff = None;
        let mut f_lvl_text = None;
        let mut f_lvl_pic_bullet_id = None;
        let mut f_legacy = None;
        let mut f_lvl_jc = None;
        let mut f_p_pr = None;
        let mut f_r_pr = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"ilvl" => {
                    f_ilvl = val.parse().ok();
                }
                b"tplc" => {
                    f_tplc = decode_hex(&val);
                }
                b"tentative" => {
                    f_tentative = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"start" => {
                                f_start =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numFmt" => {
                                f_num_fmt = Some(Box::new(CTNumFmt::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lvlRestart" => {
                                f_lvl_restart =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pStyle" => {
                                f_paragraph_style =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"isLgl" => {
                                f_is_lgl = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"suff" => {
                                f_suff =
                                    Some(Box::new(CTLevelSuffix::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lvlText" => {
                                f_lvl_text =
                                    Some(Box::new(CTLevelText::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lvlPicBulletId" => {
                                f_lvl_pic_bullet_id =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"legacy" => {
                                f_legacy =
                                    Some(Box::new(CTLvlLegacy::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lvlJc" => {
                                f_lvl_jc = Some(Box::new(CTJc::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pPr" => {
                                f_p_pr = Some(Box::new(CTPPrGeneral::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rPr" => {
                                f_r_pr =
                                    Some(Box::new(RunProperties::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"start" => {
                                f_start =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numFmt" => {
                                f_num_fmt = Some(Box::new(CTNumFmt::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lvlRestart" => {
                                f_lvl_restart =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pStyle" => {
                                f_paragraph_style =
                                    Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"isLgl" => {
                                f_is_lgl = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"suff" => {
                                f_suff = Some(Box::new(CTLevelSuffix::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lvlText" => {
                                f_lvl_text =
                                    Some(Box::new(CTLevelText::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lvlPicBulletId" => {
                                f_lvl_pic_bullet_id =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"legacy" => {
                                f_legacy = Some(Box::new(CTLvlLegacy::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lvlJc" => {
                                f_lvl_jc = Some(Box::new(CTJc::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pPr" => {
                                f_p_pr = Some(Box::new(CTPPrGeneral::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rPr" => {
                                f_r_pr = Some(Box::new(RunProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            ilvl: f_ilvl.ok_or_else(|| ParseError::MissingAttribute("ilvl".to_string()))?,
            tplc: f_tplc,
            tentative: f_tentative,
            start: f_start,
            num_fmt: f_num_fmt,
            lvl_restart: f_lvl_restart,
            paragraph_style: f_paragraph_style,
            is_lgl: f_is_lgl,
            suff: f_suff,
            lvl_text: f_lvl_text,
            lvl_pic_bullet_id: f_lvl_pic_bullet_id,
            legacy: f_legacy,
            lvl_jc: f_lvl_jc,
            p_pr: f_p_pr,
            r_pr: f_r_pr,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTMultiLevelType {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STMultiLevelType> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for AbstractNumbering {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_abstract_num_id: Option<STDecimalNumber> = None;
        let mut f_nsid = None;
        let mut f_multi_level_type = None;
        let mut f_tmpl = None;
        let mut f_name = None;
        let mut f_style_link = None;
        let mut f_num_style_link = None;
        let mut f_lvl = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"abstractNumId" => {
                    f_abstract_num_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"nsid" => {
                                f_nsid =
                                    Some(Box::new(CTLongHexNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"multiLevelType" => {
                                f_multi_level_type =
                                    Some(Box::new(CTMultiLevelType::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tmpl" => {
                                f_tmpl =
                                    Some(Box::new(CTLongHexNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"name" => {
                                f_name = Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"styleLink" => {
                                f_style_link =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numStyleLink" => {
                                f_num_style_link =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lvl" => {
                                f_lvl.push(Box::new(Level::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"nsid" => {
                                f_nsid =
                                    Some(Box::new(CTLongHexNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"multiLevelType" => {
                                f_multi_level_type =
                                    Some(Box::new(CTMultiLevelType::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tmpl" => {
                                f_tmpl =
                                    Some(Box::new(CTLongHexNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"name" => {
                                f_name = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"styleLink" => {
                                f_style_link =
                                    Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numStyleLink" => {
                                f_num_style_link =
                                    Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lvl" => {
                                f_lvl.push(Box::new(Level::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            abstract_num_id: f_abstract_num_id
                .ok_or_else(|| ParseError::MissingAttribute("abstractNumId".to_string()))?,
            nsid: f_nsid,
            multi_level_type: f_multi_level_type,
            tmpl: f_tmpl,
            name: f_name,
            style_link: f_style_link,
            num_style_link: f_num_style_link,
            lvl: f_lvl,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTNumLvl {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_ilvl: Option<STDecimalNumber> = None;
        let mut f_start_override = None;
        let mut f_lvl = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"ilvl" => {
                    f_ilvl = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"startOverride" => {
                                f_start_override =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lvl" => {
                                f_lvl = Some(Box::new(Level::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"startOverride" => {
                                f_start_override =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lvl" => {
                                f_lvl = Some(Box::new(Level::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            ilvl: f_ilvl.ok_or_else(|| ParseError::MissingAttribute("ilvl".to_string()))?,
            start_override: f_start_override,
            lvl: f_lvl,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for NumberingInstance {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_num_id: Option<STDecimalNumber> = None;
        let mut f_abstract_num_id: Option<Box<CTDecimalNumber>> = None;
        let mut f_lvl_override = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"numId" => {
                    f_num_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"abstractNumId" => {
                                f_abstract_num_id =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lvlOverride" => {
                                f_lvl_override
                                    .push(Box::new(CTNumLvl::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"abstractNumId" => {
                                f_abstract_num_id =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"lvlOverride" => {
                                f_lvl_override
                                    .push(Box::new(CTNumLvl::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            num_id: f_num_id.ok_or_else(|| ParseError::MissingAttribute("numId".to_string()))?,
            abstract_num_id: f_abstract_num_id
                .ok_or_else(|| ParseError::MissingAttribute("abstractNumId".to_string()))?,
            lvl_override: f_lvl_override,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Numbering {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "wml-numbering")]
        let mut f_num_pic_bullet = Vec::new();
        let mut f_abstract_num = Vec::new();
        let mut f_num = Vec::new();
        #[cfg(feature = "wml-numbering")]
        let mut f_num_id_mac_at_cleanup = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "wml-numbering")]
                            b"numPicBullet" => {
                                f_num_pic_bullet
                                    .push(Box::new(CTNumPicBullet::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"abstractNum" => {
                                f_abstract_num.push(Box::new(AbstractNumbering::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"num" => {
                                f_num.push(Box::new(NumberingInstance::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-numbering")]
                            b"numIdMacAtCleanup" => {
                                f_num_id_mac_at_cleanup =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "wml-numbering")]
                            b"numPicBullet" => {
                                f_num_pic_bullet
                                    .push(Box::new(CTNumPicBullet::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"abstractNum" => {
                                f_abstract_num
                                    .push(Box::new(AbstractNumbering::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"num" => {
                                f_num
                                    .push(Box::new(NumberingInstance::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-numbering")]
                            b"numIdMacAtCleanup" => {
                                f_num_id_mac_at_cleanup =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            #[cfg(feature = "wml-numbering")]
            num_pic_bullet: f_num_pic_bullet,
            abstract_num: f_abstract_num,
            num: f_num,
            #[cfg(feature = "wml-numbering")]
            num_id_mac_at_cleanup: f_num_id_mac_at_cleanup,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTTblStylePr {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_type: Option<STTblStyleOverrideType> = None;
        let mut f_p_pr = None;
        let mut f_r_pr = None;
        let mut f_table_properties = None;
        let mut f_row_properties = None;
        let mut f_cell_properties = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"type" => {
                    f_type = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"pPr" => {
                                f_p_pr = Some(Box::new(CTPPrGeneral::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rPr" => {
                                f_r_pr =
                                    Some(Box::new(RunProperties::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblPr" => {
                                f_table_properties =
                                    Some(Box::new(CTTblPrBase::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"trPr" => {
                                f_row_properties = Some(Box::new(TableRowProperties::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tcPr" => {
                                f_cell_properties = Some(Box::new(TableCellProperties::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"pPr" => {
                                f_p_pr = Some(Box::new(CTPPrGeneral::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rPr" => {
                                f_r_pr = Some(Box::new(RunProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tblPr" => {
                                f_table_properties =
                                    Some(Box::new(CTTblPrBase::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"trPr" => {
                                f_row_properties =
                                    Some(Box::new(TableRowProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tcPr" => {
                                f_cell_properties = Some(Box::new(TableCellProperties::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r#type: f_type.ok_or_else(|| ParseError::MissingAttribute("type".to_string()))?,
            p_pr: f_p_pr,
            r_pr: f_r_pr,
            table_properties: f_table_properties,
            row_properties: f_row_properties,
            cell_properties: f_cell_properties,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Style {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_type = None;
        let mut f_style_id = None;
        let mut f_default = None;
        let mut f_custom_style = None;
        let mut f_name = None;
        let mut f_aliases = None;
        let mut f_based_on = None;
        #[cfg(feature = "wml-styling")]
        let mut f_next = None;
        #[cfg(feature = "wml-styling")]
        let mut f_link = None;
        #[cfg(feature = "wml-styling")]
        let mut f_auto_redefine = None;
        #[cfg(feature = "wml-styling")]
        let mut f_hidden = None;
        #[cfg(feature = "wml-styling")]
        let mut f_ui_priority = None;
        #[cfg(feature = "wml-styling")]
        let mut f_semi_hidden = None;
        #[cfg(feature = "wml-styling")]
        let mut f_unhide_when_used = None;
        #[cfg(feature = "wml-styling")]
        let mut f_q_format = None;
        let mut f_locked = None;
        let mut f_personal = None;
        let mut f_personal_compose = None;
        let mut f_personal_reply = None;
        let mut f_rsid = None;
        #[cfg(feature = "wml-styling")]
        let mut f_p_pr = None;
        #[cfg(feature = "wml-styling")]
        let mut f_r_pr = None;
        #[cfg(feature = "wml-styling")]
        let mut f_table_properties = None;
        #[cfg(feature = "wml-styling")]
        let mut f_row_properties = None;
        #[cfg(feature = "wml-styling")]
        let mut f_cell_properties = None;
        #[cfg(feature = "wml-styling")]
        let mut f_tbl_style_pr = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"type" => {
                    f_type = val.parse().ok();
                }
                b"styleId" => {
                    f_style_id = Some(val.into_owned());
                }
                b"default" => {
                    f_default = Some(val.into_owned());
                }
                b"customStyle" => {
                    f_custom_style = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"name" => {
                                f_name = Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"aliases" => {
                                f_aliases = Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"basedOn" => {
                                f_based_on = Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"next" => {
                                f_next = Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"link" => {
                                f_link = Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"autoRedefine" => {
                                f_auto_redefine =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"hidden" => {
                                f_hidden = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"uiPriority" => {
                                f_ui_priority =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"semiHidden" => {
                                f_semi_hidden =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"unhideWhenUsed" => {
                                f_unhide_when_used =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"qFormat" => {
                                f_q_format = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"locked" => {
                                f_locked = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"personal" => {
                                f_personal = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"personalCompose" => {
                                f_personal_compose =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"personalReply" => {
                                f_personal_reply =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rsid" => {
                                f_rsid =
                                    Some(Box::new(CTLongHexNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"pPr" => {
                                f_p_pr = Some(Box::new(CTPPrGeneral::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"rPr" => {
                                f_r_pr =
                                    Some(Box::new(RunProperties::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"tblPr" => {
                                f_table_properties =
                                    Some(Box::new(CTTblPrBase::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"trPr" => {
                                f_row_properties = Some(Box::new(TableRowProperties::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"tcPr" => {
                                f_cell_properties = Some(Box::new(TableCellProperties::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"tblStylePr" => {
                                f_tbl_style_pr
                                    .push(Box::new(CTTblStylePr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"name" => {
                                f_name = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"aliases" => {
                                f_aliases = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"basedOn" => {
                                f_based_on = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"next" => {
                                f_next = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"link" => {
                                f_link = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"autoRedefine" => {
                                f_auto_redefine =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"hidden" => {
                                f_hidden = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"uiPriority" => {
                                f_ui_priority =
                                    Some(Box::new(CTDecimalNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"semiHidden" => {
                                f_semi_hidden =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"unhideWhenUsed" => {
                                f_unhide_when_used =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"qFormat" => {
                                f_q_format = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"locked" => {
                                f_locked = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"personal" => {
                                f_personal = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"personalCompose" => {
                                f_personal_compose =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"personalReply" => {
                                f_personal_reply =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rsid" => {
                                f_rsid =
                                    Some(Box::new(CTLongHexNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"pPr" => {
                                f_p_pr = Some(Box::new(CTPPrGeneral::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"rPr" => {
                                f_r_pr = Some(Box::new(RunProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"tblPr" => {
                                f_table_properties =
                                    Some(Box::new(CTTblPrBase::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"trPr" => {
                                f_row_properties =
                                    Some(Box::new(TableRowProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"tcPr" => {
                                f_cell_properties = Some(Box::new(TableCellProperties::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-styling")]
                            b"tblStylePr" => {
                                f_tbl_style_pr
                                    .push(Box::new(CTTblStylePr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r#type: f_type,
            style_id: f_style_id,
            default: f_default,
            custom_style: f_custom_style,
            name: f_name,
            aliases: f_aliases,
            based_on: f_based_on,
            #[cfg(feature = "wml-styling")]
            next: f_next,
            #[cfg(feature = "wml-styling")]
            link: f_link,
            #[cfg(feature = "wml-styling")]
            auto_redefine: f_auto_redefine,
            #[cfg(feature = "wml-styling")]
            hidden: f_hidden,
            #[cfg(feature = "wml-styling")]
            ui_priority: f_ui_priority,
            #[cfg(feature = "wml-styling")]
            semi_hidden: f_semi_hidden,
            #[cfg(feature = "wml-styling")]
            unhide_when_used: f_unhide_when_used,
            #[cfg(feature = "wml-styling")]
            q_format: f_q_format,
            locked: f_locked,
            personal: f_personal,
            personal_compose: f_personal_compose,
            personal_reply: f_personal_reply,
            rsid: f_rsid,
            #[cfg(feature = "wml-styling")]
            p_pr: f_p_pr,
            #[cfg(feature = "wml-styling")]
            r_pr: f_r_pr,
            #[cfg(feature = "wml-styling")]
            table_properties: f_table_properties,
            #[cfg(feature = "wml-styling")]
            row_properties: f_row_properties,
            #[cfg(feature = "wml-styling")]
            cell_properties: f_cell_properties,
            #[cfg(feature = "wml-styling")]
            tbl_style_pr: f_tbl_style_pr,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTLsdException {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name: Option<STString> = None;
        let mut f_locked = None;
        let mut f_ui_priority = None;
        let mut f_semi_hidden = None;
        let mut f_unhide_when_used = None;
        let mut f_q_format = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"locked" => {
                    f_locked = Some(val.into_owned());
                }
                b"uiPriority" => {
                    f_ui_priority = val.parse().ok();
                }
                b"semiHidden" => {
                    f_semi_hidden = Some(val.into_owned());
                }
                b"unhideWhenUsed" => {
                    f_unhide_when_used = Some(val.into_owned());
                }
                b"qFormat" => {
                    f_q_format = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            locked: f_locked,
            ui_priority: f_ui_priority,
            semi_hidden: f_semi_hidden,
            unhide_when_used: f_unhide_when_used,
            q_format: f_q_format,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTLatentStyles {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_def_locked_state = None;
        let mut f_def_u_i_priority = None;
        let mut f_def_semi_hidden = None;
        let mut f_def_unhide_when_used = None;
        let mut f_def_q_format = None;
        let mut f_count = None;
        let mut f_lsd_exception = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"defLockedState" => {
                    f_def_locked_state = Some(val.into_owned());
                }
                b"defUIPriority" => {
                    f_def_u_i_priority = val.parse().ok();
                }
                b"defSemiHidden" => {
                    f_def_semi_hidden = Some(val.into_owned());
                }
                b"defUnhideWhenUsed" => {
                    f_def_unhide_when_used = Some(val.into_owned());
                }
                b"defQFormat" => {
                    f_def_q_format = Some(val.into_owned());
                }
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"lsdException" => {
                                f_lsd_exception
                                    .push(Box::new(CTLsdException::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"lsdException" => {
                                f_lsd_exception
                                    .push(Box::new(CTLsdException::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            def_locked_state: f_def_locked_state,
            def_u_i_priority: f_def_u_i_priority,
            def_semi_hidden: f_def_semi_hidden,
            def_unhide_when_used: f_def_unhide_when_used,
            def_q_format: f_def_q_format,
            count: f_count,
            lsd_exception: f_lsd_exception,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Styles {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_doc_defaults = None;
        let mut f_latent_styles = None;
        let mut f_style = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"docDefaults" => {
                                f_doc_defaults =
                                    Some(Box::new(CTDocDefaults::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"latentStyles" => {
                                f_latent_styles =
                                    Some(Box::new(CTLatentStyles::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"style" => {
                                f_style.push(Box::new(Style::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"docDefaults" => {
                                f_doc_defaults =
                                    Some(Box::new(CTDocDefaults::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"latentStyles" => {
                                f_latent_styles =
                                    Some(Box::new(CTLatentStyles::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"style" => {
                                f_style.push(Box::new(Style::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            doc_defaults: f_doc_defaults,
            latent_styles: f_latent_styles,
            style: f_style,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTPanose {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<Panose> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = decode_hex(&val);
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTFontFamily {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STFontFamily> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTPitch {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STPitch> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTFontSig {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_usb0: Option<STLongHexNumber> = None;
        let mut f_usb1: Option<STLongHexNumber> = None;
        let mut f_usb2: Option<STLongHexNumber> = None;
        let mut f_usb3: Option<STLongHexNumber> = None;
        let mut f_csb0: Option<STLongHexNumber> = None;
        let mut f_csb1: Option<STLongHexNumber> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"usb0" => {
                    f_usb0 = decode_hex(&val);
                }
                b"usb1" => {
                    f_usb1 = decode_hex(&val);
                }
                b"usb2" => {
                    f_usb2 = decode_hex(&val);
                }
                b"usb3" => {
                    f_usb3 = decode_hex(&val);
                }
                b"csb0" => {
                    f_csb0 = decode_hex(&val);
                }
                b"csb1" => {
                    f_csb1 = decode_hex(&val);
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            usb0: f_usb0.ok_or_else(|| ParseError::MissingAttribute("usb0".to_string()))?,
            usb1: f_usb1.ok_or_else(|| ParseError::MissingAttribute("usb1".to_string()))?,
            usb2: f_usb2.ok_or_else(|| ParseError::MissingAttribute("usb2".to_string()))?,
            usb3: f_usb3.ok_or_else(|| ParseError::MissingAttribute("usb3".to_string()))?,
            csb0: f_csb0.ok_or_else(|| ParseError::MissingAttribute("csb0".to_string()))?,
            csb1: f_csb1.ok_or_else(|| ParseError::MissingAttribute("csb1".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTFontRel {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_font_key = None;
        let mut f_subsetted = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"fontKey" => {
                    f_font_key = Some(val.into_owned());
                }
                b"subsetted" => {
                    f_subsetted = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            font_key: f_font_key,
            subsetted: f_subsetted,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for Font {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name: Option<STString> = None;
        let mut f_alt_name = None;
        let mut f_panose1 = None;
        let mut f_charset = None;
        let mut f_family = None;
        let mut f_not_true_type = None;
        let mut f_pitch = None;
        let mut f_sig = None;
        let mut f_embed_regular = None;
        let mut f_embed_bold = None;
        let mut f_embed_italic = None;
        let mut f_embed_bold_italic = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"altName" => {
                                f_alt_name = Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"panose1" => {
                                f_panose1 = Some(Box::new(CTPanose::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"charset" => {
                                f_charset = Some(Box::new(CTCharset::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"family" => {
                                f_family =
                                    Some(Box::new(CTFontFamily::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"notTrueType" => {
                                f_not_true_type =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pitch" => {
                                f_pitch = Some(Box::new(CTPitch::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sig" => {
                                f_sig = Some(Box::new(CTFontSig::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"embedRegular" => {
                                f_embed_regular =
                                    Some(Box::new(CTFontRel::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"embedBold" => {
                                f_embed_bold =
                                    Some(Box::new(CTFontRel::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"embedItalic" => {
                                f_embed_italic =
                                    Some(Box::new(CTFontRel::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"embedBoldItalic" => {
                                f_embed_bold_italic =
                                    Some(Box::new(CTFontRel::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"altName" => {
                                f_alt_name = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"panose1" => {
                                f_panose1 = Some(Box::new(CTPanose::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"charset" => {
                                f_charset = Some(Box::new(CTCharset::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"family" => {
                                f_family =
                                    Some(Box::new(CTFontFamily::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"notTrueType" => {
                                f_not_true_type =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pitch" => {
                                f_pitch = Some(Box::new(CTPitch::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sig" => {
                                f_sig = Some(Box::new(CTFontSig::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"embedRegular" => {
                                f_embed_regular =
                                    Some(Box::new(CTFontRel::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"embedBold" => {
                                f_embed_bold =
                                    Some(Box::new(CTFontRel::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"embedItalic" => {
                                f_embed_italic =
                                    Some(Box::new(CTFontRel::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"embedBoldItalic" => {
                                f_embed_bold_italic =
                                    Some(Box::new(CTFontRel::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            alt_name: f_alt_name,
            panose1: f_panose1,
            charset: f_charset,
            family: f_family,
            not_true_type: f_not_true_type,
            pitch: f_pitch,
            sig: f_sig,
            embed_regular: f_embed_regular,
            embed_bold: f_embed_bold,
            embed_italic: f_embed_italic,
            embed_bold_italic: f_embed_bold_italic,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTFontsList {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_font = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"font" => {
                                f_font.push(Box::new(Font::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"font" => {
                                f_font.push(Box::new(Font::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            font: f_font,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTDivBdr {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_top = None;
        let mut f_left = None;
        let mut f_bottom = None;
        let mut f_right = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"top" => {
                                f_top = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"left" => {
                                f_left = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bottom" => {
                                f_bottom = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"right" => {
                                f_right = Some(Box::new(CTBorder::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"top" => {
                                f_top = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"left" => {
                                f_left = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bottom" => {
                                f_bottom = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"right" => {
                                f_right = Some(Box::new(CTBorder::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            top: f_top,
            left: f_left,
            bottom: f_bottom,
            right: f_right,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTDiv {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STDecimalNumber> = None;
        let mut f_block_quote = None;
        let mut f_body_div = None;
        let mut f_mar_left: Option<Box<CTSignedTwipsMeasure>> = None;
        let mut f_mar_right: Option<Box<CTSignedTwipsMeasure>> = None;
        let mut f_mar_top: Option<Box<CTSignedTwipsMeasure>> = None;
        let mut f_mar_bottom: Option<Box<CTSignedTwipsMeasure>> = None;
        let mut f_div_bdr = None;
        let mut f_divs_child = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"blockQuote" => {
                                f_block_quote =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bodyDiv" => {
                                f_body_div = Some(Box::new(CTOnOff::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"marLeft" => {
                                f_mar_left = Some(Box::new(CTSignedTwipsMeasure::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"marRight" => {
                                f_mar_right = Some(Box::new(CTSignedTwipsMeasure::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"marTop" => {
                                f_mar_top = Some(Box::new(CTSignedTwipsMeasure::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"marBottom" => {
                                f_mar_bottom = Some(Box::new(CTSignedTwipsMeasure::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"divBdr" => {
                                f_div_bdr = Some(Box::new(CTDivBdr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"divsChild" => {
                                f_divs_child.push(Box::new(CTDivs::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"blockQuote" => {
                                f_block_quote =
                                    Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bodyDiv" => {
                                f_body_div = Some(Box::new(CTOnOff::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"marLeft" => {
                                f_mar_left = Some(Box::new(CTSignedTwipsMeasure::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"marRight" => {
                                f_mar_right = Some(Box::new(CTSignedTwipsMeasure::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"marTop" => {
                                f_mar_top = Some(Box::new(CTSignedTwipsMeasure::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"marBottom" => {
                                f_mar_bottom = Some(Box::new(CTSignedTwipsMeasure::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"divBdr" => {
                                f_div_bdr = Some(Box::new(CTDivBdr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"divsChild" => {
                                f_divs_child.push(Box::new(CTDivs::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            block_quote: f_block_quote,
            body_div: f_body_div,
            mar_left: f_mar_left
                .ok_or_else(|| ParseError::MissingAttribute("marLeft".to_string()))?,
            mar_right: f_mar_right
                .ok_or_else(|| ParseError::MissingAttribute("marRight".to_string()))?,
            mar_top: f_mar_top.ok_or_else(|| ParseError::MissingAttribute("marTop".to_string()))?,
            mar_bottom: f_mar_bottom
                .ok_or_else(|| ParseError::MissingAttribute("marBottom".to_string()))?,
            div_bdr: f_div_bdr,
            divs_child: f_divs_child,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTDivs {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_div = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"div" => {
                                f_div.push(Box::new(CTDiv::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"div" => {
                                f_div.push(Box::new(CTDiv::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            div: f_div,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTTxbxContent {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_block_content = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"customXml"
                            | b"sdt"
                            | b"p"
                            | b"tbl"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo"
                            | b"altChunk" => {
                                f_block_content
                                    .push(Box::new(BlockContent::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"customXml"
                            | b"sdt"
                            | b"p"
                            | b"tbl"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo"
                            | b"altChunk" => {
                                f_block_content
                                    .push(Box::new(BlockContent::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            block_content: f_block_content,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for EGMathContent {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    #[cfg(feature = "extra-children")]
                    Event::Start(e) => {
                        let elem = RawXmlElement::from_reader(reader, &e)?;
                        extra_children
                            .push(PositionedNode::new(child_idx, RawXmlNode::Element(elem)));
                        child_idx += 1;
                    }
                    #[cfg(not(feature = "extra-children"))]
                    Event::Start(_) => {
                        skip_element(reader)?;
                    }
                    #[cfg(feature = "extra-children")]
                    Event::Empty(e) => {
                        let elem = RawXmlElement::from_empty(&e);
                        extra_children
                            .push(PositionedNode::new(child_idx, RawXmlNode::Element(elem)));
                        child_idx += 1;
                    }
                    #[cfg(not(feature = "extra-children"))]
                    Event::Empty(_) => {}
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }
        Ok(Self {
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for EGBlockLevelChunkElts {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_block_content = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"customXml"
                            | b"sdt"
                            | b"p"
                            | b"tbl"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo" => {
                                f_block_content.push(Box::new(BlockContentChoice::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"customXml"
                            | b"sdt"
                            | b"p"
                            | b"tbl"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo" => {
                                f_block_content.push(Box::new(BlockContentChoice::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            block_content: f_block_content,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for BlockContent {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let tag = start_tag.local_name();
        match tag.as_ref() {
            b"customXml" => {
                let inner = CTCustomXmlBlock::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXml(Box::new(inner)))
            }
            b"sdt" => {
                let inner = CTSdtBlock::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Sdt(Box::new(inner)))
            }
            b"p" => {
                let inner = Paragraph::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::P(Box::new(inner)))
            }
            b"tbl" => {
                let inner = Table::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Tbl(Box::new(inner)))
            }
            b"proofErr" => {
                let inner = CTProofErr::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::ProofErr(Box::new(inner)))
            }
            b"permStart" => {
                let inner = CTPermStart::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::PermStart(Box::new(inner)))
            }
            b"permEnd" => {
                let inner = CTPerm::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::PermEnd(Box::new(inner)))
            }
            b"bookmarkStart" => {
                let inner = Bookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::BookmarkStart(Box::new(inner)))
            }
            b"bookmarkEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::BookmarkEnd(Box::new(inner)))
            }
            b"moveFromRangeStart" => {
                let inner = CTMoveBookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveFromRangeStart(Box::new(inner)))
            }
            b"moveFromRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveFromRangeEnd(Box::new(inner)))
            }
            b"moveToRangeStart" => {
                let inner = CTMoveBookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveToRangeStart(Box::new(inner)))
            }
            b"moveToRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveToRangeEnd(Box::new(inner)))
            }
            b"commentRangeStart" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CommentRangeStart(Box::new(inner)))
            }
            b"commentRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CommentRangeEnd(Box::new(inner)))
            }
            b"customXmlInsRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlInsRangeStart(Box::new(inner)))
            }
            b"customXmlInsRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlInsRangeEnd(Box::new(inner)))
            }
            b"customXmlDelRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlDelRangeStart(Box::new(inner)))
            }
            b"customXmlDelRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlDelRangeEnd(Box::new(inner)))
            }
            b"customXmlMoveFromRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveFromRangeStart(Box::new(inner)))
            }
            b"customXmlMoveFromRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveFromRangeEnd(Box::new(inner)))
            }
            b"customXmlMoveToRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveToRangeStart(Box::new(inner)))
            }
            b"customXmlMoveToRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveToRangeEnd(Box::new(inner)))
            }
            b"ins" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Ins(Box::new(inner)))
            }
            b"del" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Del(Box::new(inner)))
            }
            b"moveFrom" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveFrom(Box::new(inner)))
            }
            b"moveTo" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveTo(Box::new(inner)))
            }
            b"altChunk" => {
                let inner = CTAltChunk::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::AltChunk(Box::new(inner)))
            }
            _ => Err(ParseError::UnexpectedElement(
                String::from_utf8_lossy(start_tag.name().as_ref()).into_owned(),
            )),
        }
    }
}

impl FromXml for RunLevelContent {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let tag = start_tag.local_name();
        match tag.as_ref() {
            b"proofErr" => {
                let inner = CTProofErr::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::ProofErr(Box::new(inner)))
            }
            b"permStart" => {
                let inner = CTPermStart::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::PermStart(Box::new(inner)))
            }
            b"permEnd" => {
                let inner = CTPerm::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::PermEnd(Box::new(inner)))
            }
            b"bookmarkStart" => {
                let inner = Bookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::BookmarkStart(Box::new(inner)))
            }
            b"bookmarkEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::BookmarkEnd(Box::new(inner)))
            }
            b"moveFromRangeStart" => {
                let inner = CTMoveBookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveFromRangeStart(Box::new(inner)))
            }
            b"moveFromRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveFromRangeEnd(Box::new(inner)))
            }
            b"moveToRangeStart" => {
                let inner = CTMoveBookmark::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveToRangeStart(Box::new(inner)))
            }
            b"moveToRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveToRangeEnd(Box::new(inner)))
            }
            b"commentRangeStart" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CommentRangeStart(Box::new(inner)))
            }
            b"commentRangeEnd" => {
                let inner = CTMarkupRange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CommentRangeEnd(Box::new(inner)))
            }
            b"customXmlInsRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlInsRangeStart(Box::new(inner)))
            }
            b"customXmlInsRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlInsRangeEnd(Box::new(inner)))
            }
            b"customXmlDelRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlDelRangeStart(Box::new(inner)))
            }
            b"customXmlDelRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlDelRangeEnd(Box::new(inner)))
            }
            b"customXmlMoveFromRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveFromRangeStart(Box::new(inner)))
            }
            b"customXmlMoveFromRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveFromRangeEnd(Box::new(inner)))
            }
            b"customXmlMoveToRangeStart" => {
                let inner = CTTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveToRangeStart(Box::new(inner)))
            }
            b"customXmlMoveToRangeEnd" => {
                let inner = CTMarkup::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::CustomXmlMoveToRangeEnd(Box::new(inner)))
            }
            b"ins" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Ins(Box::new(inner)))
            }
            b"del" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::Del(Box::new(inner)))
            }
            b"moveFrom" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveFrom(Box::new(inner)))
            }
            b"moveTo" => {
                let inner = CTRunTrackChange::from_xml(reader, start_tag, is_empty)?;
                Ok(Self::MoveTo(Box::new(inner)))
            }
            _ => Err(ParseError::UnexpectedElement(
                String::from_utf8_lossy(start_tag.name().as_ref()).into_owned(),
            )),
        }
    }
}

impl FromXml for Body {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_block_content = Vec::new();
        #[cfg(feature = "wml-layout")]
        let mut f_sect_pr = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"customXml"
                            | b"sdt"
                            | b"p"
                            | b"tbl"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo"
                            | b"altChunk" => {
                                f_block_content
                                    .push(Box::new(BlockContent::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"sectPr" => {
                                f_sect_pr =
                                    Some(Box::new(SectionProperties::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"customXml"
                            | b"sdt"
                            | b"p"
                            | b"tbl"
                            | b"proofErr"
                            | b"permStart"
                            | b"permEnd"
                            | b"bookmarkStart"
                            | b"bookmarkEnd"
                            | b"moveFromRangeStart"
                            | b"moveFromRangeEnd"
                            | b"moveToRangeStart"
                            | b"moveToRangeEnd"
                            | b"commentRangeStart"
                            | b"commentRangeEnd"
                            | b"customXmlInsRangeStart"
                            | b"customXmlInsRangeEnd"
                            | b"customXmlDelRangeStart"
                            | b"customXmlDelRangeEnd"
                            | b"customXmlMoveFromRangeStart"
                            | b"customXmlMoveFromRangeEnd"
                            | b"customXmlMoveToRangeStart"
                            | b"customXmlMoveToRangeEnd"
                            | b"ins"
                            | b"del"
                            | b"moveFrom"
                            | b"moveTo"
                            | b"altChunk" => {
                                f_block_content
                                    .push(Box::new(BlockContent::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "wml-layout")]
                            b"sectPr" => {
                                f_sect_pr =
                                    Some(Box::new(SectionProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            block_content: f_block_content,
            #[cfg(feature = "wml-layout")]
            sect_pr: f_sect_pr,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTShapeDefaults {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    #[cfg(feature = "extra-children")]
                    Event::Start(e) => {
                        let elem = RawXmlElement::from_reader(reader, &e)?;
                        extra_children
                            .push(PositionedNode::new(child_idx, RawXmlNode::Element(elem)));
                        child_idx += 1;
                    }
                    #[cfg(not(feature = "extra-children"))]
                    Event::Start(_) => {
                        skip_element(reader)?;
                    }
                    #[cfg(feature = "extra-children")]
                    Event::Empty(e) => {
                        let elem = RawXmlElement::from_empty(&e);
                        extra_children
                            .push(PositionedNode::new(child_idx, RawXmlNode::Element(elem)));
                        child_idx += 1;
                    }
                    #[cfg(not(feature = "extra-children"))]
                    Event::Empty(_) => {}
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }
        Ok(Self {
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Comments {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_comment = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"comment" => {
                                f_comment.push(Box::new(Comment::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"comment" => {
                                f_comment.push(Box::new(Comment::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            comment: f_comment,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Footnotes {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_footnote = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"footnote" => {
                                f_footnote
                                    .push(Box::new(FootnoteEndnote::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"footnote" => {
                                f_footnote
                                    .push(Box::new(FootnoteEndnote::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            footnote: f_footnote,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Endnotes {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_endnote = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"endnote" => {
                                f_endnote
                                    .push(Box::new(FootnoteEndnote::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"endnote" => {
                                f_endnote
                                    .push(Box::new(FootnoteEndnote::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            endnote: f_endnote,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTSmartTagType {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_namespaceuri = None;
        let mut f_name = None;
        let mut f_url = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"namespaceuri" => {
                    f_namespaceuri = Some(val.into_owned());
                }
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"url" => {
                    f_url = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            namespaceuri: f_namespaceuri,
            name: f_name,
            url: f_url,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTDocPartBehavior {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STDocPartBehavior> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTDocPartBehaviors {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_behavior = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"behavior" => {
                                f_behavior.push(Box::new(CTDocPartBehavior::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"behavior" => {
                                f_behavior
                                    .push(Box::new(CTDocPartBehavior::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            behavior: f_behavior,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTDocPartType {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STDocPartType> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTDocPartTypes {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_all = None;
        let mut f_type = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"all" => {
                    f_all = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"type" => {
                                f_type.push(Box::new(CTDocPartType::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"type" => {
                                f_type.push(Box::new(CTDocPartType::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            all: f_all,
            r#type: f_type,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTDocPartGallery {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STDocPartGallery> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTDocPartCategory {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name: Option<Box<CTString>> = None;
        let mut f_gallery: Option<Box<CTDocPartGallery>> = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"name" => {
                                f_name = Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"gallery" => {
                                f_gallery =
                                    Some(Box::new(CTDocPartGallery::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"name" => {
                                f_name = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"gallery" => {
                                f_gallery =
                                    Some(Box::new(CTDocPartGallery::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            gallery: f_gallery
                .ok_or_else(|| ParseError::MissingAttribute("gallery".to_string()))?,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTDocPartName {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STString> = None;
        let mut f_decorated = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                b"decorated" => {
                    f_decorated = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            decorated: f_decorated,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTDocPartPr {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name: Option<Box<CTDocPartName>> = None;
        let mut f_style = None;
        let mut f_category = None;
        let mut f_types = None;
        let mut f_behaviors = None;
        let mut f_description = None;
        let mut f_guid = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"name" => {
                                f_name =
                                    Some(Box::new(CTDocPartName::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"style" => {
                                f_style = Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"category" => {
                                f_category =
                                    Some(Box::new(CTDocPartCategory::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"types" => {
                                f_types =
                                    Some(Box::new(CTDocPartTypes::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"behaviors" => {
                                f_behaviors = Some(Box::new(CTDocPartBehaviors::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"description" => {
                                f_description =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"guid" => {
                                f_guid = Some(Box::new(CTGuid::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"name" => {
                                f_name = Some(Box::new(CTDocPartName::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"style" => {
                                f_style = Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"category" => {
                                f_category =
                                    Some(Box::new(CTDocPartCategory::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"types" => {
                                f_types =
                                    Some(Box::new(CTDocPartTypes::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"behaviors" => {
                                f_behaviors =
                                    Some(Box::new(CTDocPartBehaviors::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"description" => {
                                f_description =
                                    Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"guid" => {
                                f_guid = Some(Box::new(CTGuid::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            style: f_style,
            category: f_category,
            types: f_types,
            behaviors: f_behaviors,
            description: f_description,
            guid: f_guid,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTDocPart {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_doc_part_pr = None;
        let mut f_doc_part_body = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"docPartPr" => {
                                f_doc_part_pr =
                                    Some(Box::new(CTDocPartPr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"docPartBody" => {
                                f_doc_part_body =
                                    Some(Box::new(Body::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"docPartPr" => {
                                f_doc_part_pr =
                                    Some(Box::new(CTDocPartPr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"docPartBody" => {
                                f_doc_part_body = Some(Box::new(Body::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            doc_part_pr: f_doc_part_pr,
            doc_part_body: f_doc_part_body,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTDocParts {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_doc_part = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"docPart" => {
                                f_doc_part.push(Box::new(CTDocPart::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"docPart" => {
                                f_doc_part.push(Box::new(CTDocPart::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            doc_part: f_doc_part,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTCaption {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name: Option<STString> = None;
        let mut f_pos = None;
        let mut f_chap_num = None;
        let mut f_heading = None;
        let mut f_no_label = None;
        let mut f_num_fmt = None;
        let mut f_sep = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"pos" => {
                    f_pos = val.parse().ok();
                }
                b"chapNum" => {
                    f_chap_num = Some(val.into_owned());
                }
                b"heading" => {
                    f_heading = val.parse().ok();
                }
                b"noLabel" => {
                    f_no_label = Some(val.into_owned());
                }
                b"numFmt" => {
                    f_num_fmt = val.parse().ok();
                }
                b"sep" => {
                    f_sep = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            pos: f_pos,
            chap_num: f_chap_num,
            heading: f_heading,
            no_label: f_no_label,
            num_fmt: f_num_fmt,
            sep: f_sep,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTAutoCaption {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name: Option<STString> = None;
        let mut f_caption: Option<STString> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"caption" => {
                    f_caption = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            caption: f_caption
                .ok_or_else(|| ParseError::MissingAttribute("caption".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTAutoCaptions {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_auto_caption = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"autoCaption" => {
                                f_auto_caption
                                    .push(Box::new(CTAutoCaption::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"autoCaption" => {
                                f_auto_caption
                                    .push(Box::new(CTAutoCaption::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            auto_caption: f_auto_caption,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTCaptions {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_caption = Vec::new();
        let mut f_auto_captions = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"caption" => {
                                f_caption.push(Box::new(CTCaption::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"autoCaptions" => {
                                f_auto_captions =
                                    Some(Box::new(CTAutoCaptions::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"caption" => {
                                f_caption.push(Box::new(CTCaption::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"autoCaptions" => {
                                f_auto_captions =
                                    Some(Box::new(CTAutoCaptions::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            caption: f_caption,
            auto_captions: f_auto_captions,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTDocumentBase {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_background = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"background" => {
                                f_background =
                                    Some(Box::new(CTBackground::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"background" => {
                                f_background =
                                    Some(Box::new(CTBackground::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            background: f_background,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Document {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "wml-styling")]
        let mut f_background = None;
        let mut f_body = None;
        let mut f_conformance = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"conformance" => {
                    f_conformance = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "wml-styling")]
                            b"background" => {
                                f_background =
                                    Some(Box::new(CTBackground::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"body" => {
                                f_body = Some(Box::new(Body::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "wml-styling")]
                            b"background" => {
                                f_background =
                                    Some(Box::new(CTBackground::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"body" => {
                                f_body = Some(Box::new(Body::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            #[cfg(feature = "wml-styling")]
            background: f_background,
            body: f_body,
            conformance: f_conformance,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTGlossaryDocument {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_background = None;
        let mut f_doc_parts = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"background" => {
                                f_background =
                                    Some(Box::new(CTBackground::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"docParts" => {
                                f_doc_parts =
                                    Some(Box::new(CTDocParts::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"background" => {
                                f_background =
                                    Some(Box::new(CTBackground::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"docParts" => {
                                f_doc_parts =
                                    Some(Box::new(CTDocParts::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            background: f_background,
            doc_parts: f_doc_parts,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for WAnyVmlOffice {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    #[cfg(feature = "extra-children")]
                    Event::Start(e) => {
                        let elem = RawXmlElement::from_reader(reader, &e)?;
                        extra_children
                            .push(PositionedNode::new(child_idx, RawXmlNode::Element(elem)));
                        child_idx += 1;
                    }
                    #[cfg(not(feature = "extra-children"))]
                    Event::Start(_) => {
                        skip_element(reader)?;
                    }
                    #[cfg(feature = "extra-children")]
                    Event::Empty(e) => {
                        let elem = RawXmlElement::from_empty(&e);
                        extra_children
                            .push(PositionedNode::new(child_idx, RawXmlNode::Element(elem)));
                        child_idx += 1;
                    }
                    #[cfg(not(feature = "extra-children"))]
                    Event::Empty(_) => {}
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }
        Ok(Self {
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for WAnyVmlVml {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    #[cfg(feature = "extra-children")]
                    Event::Start(e) => {
                        let elem = RawXmlElement::from_reader(reader, &e)?;
                        extra_children
                            .push(PositionedNode::new(child_idx, RawXmlNode::Element(elem)));
                        child_idx += 1;
                    }
                    #[cfg(not(feature = "extra-children"))]
                    Event::Start(_) => {
                        skip_element(reader)?;
                    }
                    #[cfg(feature = "extra-children")]
                    Event::Empty(e) => {
                        let elem = RawXmlElement::from_empty(&e);
                        extra_children
                            .push(PositionedNode::new(child_idx, RawXmlNode::Element(elem)));
                        child_idx += 1;
                    }
                    #[cfg(not(feature = "extra-children"))]
                    Event::Empty(_) => {}
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }
        Ok(Self {
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}
