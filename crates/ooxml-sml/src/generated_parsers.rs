// Event-based parsers for generated types.
// ~3x faster than serde-based deserialization.

#![allow(unused_variables)]
#![allow(unused_imports)]
#![allow(clippy::single_match)]
#![allow(clippy::match_single_binding)]
#![allow(clippy::manual_is_multiple_of)]

use super::generated::*;
pub use ooxml_xml::{FromXml, ParseError};
#[cfg(feature = "extra-children")]
use ooxml_xml::{PositionedNode, RawXmlElement, RawXmlNode};
use quick_xml::Reader;
use quick_xml::events::{BytesStart, Event};
use std::io::BufRead;

#[allow(dead_code)]
/// Skip an element and all its children.
fn skip_element<R: BufRead>(reader: &mut Reader<R>) -> Result<(), ParseError> {
    let mut depth = 1u32;
    let mut buf = Vec::new();
    loop {
        match reader.read_event_into(&mut buf)? {
            Event::Start(_) => depth += 1,
            Event::End(_) => {
                depth -= 1;
                if depth == 0 {
                    break;
                }
            }
            Event::Eof => break,
            _ => {}
        }
        buf.clear();
    }
    Ok(())
}

#[allow(dead_code)]
/// Read the text content of an element until its end tag.
fn read_text_content<R: BufRead>(reader: &mut Reader<R>) -> Result<String, ParseError> {
    let mut text = String::new();
    let mut buf = Vec::new();
    loop {
        match reader.read_event_into(&mut buf)? {
            Event::Text(e) => text.push_str(&e.decode().unwrap_or_default()),
            Event::CData(e) => text.push_str(&e.decode().unwrap_or_default()),
            Event::End(_) => break,
            Event::Eof => break,
            _ => {}
        }
        buf.clear();
    }
    Ok(text)
}

#[allow(dead_code)]
/// Decode a hex string to bytes.
fn decode_hex(s: &str) -> Option<Vec<u8>> {
    let s = s.trim();
    if s.len() % 2 != 0 {
        return None;
    }
    (0..s.len())
        .step_by(2)
        .map(|i| u8::from_str_radix(&s[i..i + 2], 16).ok())
        .collect()
}

impl FromXml for AutoFilter {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "sml-filtering")]
        let mut f_reference = None;
        #[cfg(feature = "sml-filtering")]
        let mut f_filter_column = Vec::new();
        #[cfg(feature = "sml-filtering")]
        let mut f_sort_state = None;
        #[cfg(feature = "sml-extensions")]
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                #[cfg(feature = "sml-filtering")]
                b"ref" => {
                    f_reference = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "sml-filtering")]
                            b"filterColumn" => {
                                f_filter_column.push(FilterColumn::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-filtering")]
                            b"sortState" => {
                                f_sort_state =
                                    Some(Box::new(SortState::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-extensions")]
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "sml-filtering")]
                            b"filterColumn" => {
                                f_filter_column.push(FilterColumn::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-filtering")]
                            b"sortState" => {
                                f_sort_state =
                                    Some(Box::new(SortState::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-extensions")]
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            #[cfg(feature = "sml-filtering")]
            reference: f_reference,
            #[cfg(feature = "sml-filtering")]
            filter_column: f_filter_column,
            #[cfg(feature = "sml-filtering")]
            sort_state: f_sort_state,
            #[cfg(feature = "sml-extensions")]
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for FilterColumn {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "sml-filtering")]
        let mut f_column_id: Option<u32> = None;
        #[cfg(feature = "sml-filtering")]
        let mut f_hidden_button = None;
        #[cfg(feature = "sml-filtering")]
        let mut f_show_button = None;
        #[cfg(feature = "sml-filtering")]
        let mut f_filters = None;
        #[cfg(feature = "sml-filtering")]
        let mut f_top10 = None;
        #[cfg(feature = "sml-filtering")]
        let mut f_custom_filters = None;
        #[cfg(feature = "sml-filtering")]
        let mut f_dynamic_filter = None;
        #[cfg(feature = "sml-filtering")]
        let mut f_color_filter = None;
        #[cfg(feature = "sml-filtering")]
        let mut f_icon_filter = None;
        #[cfg(feature = "sml-extensions")]
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                #[cfg(feature = "sml-filtering")]
                b"colId" => {
                    f_column_id = val.parse().ok();
                }
                #[cfg(feature = "sml-filtering")]
                b"hiddenButton" => {
                    f_hidden_button = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-filtering")]
                b"showButton" => {
                    f_show_button = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "sml-filtering")]
                            b"filters" => {
                                f_filters = Some(Box::new(Filters::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-filtering")]
                            b"top10" => {
                                f_top10 = Some(Box::new(Top10Filter::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-filtering")]
                            b"customFilters" => {
                                f_custom_filters =
                                    Some(Box::new(CustomFilters::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-filtering")]
                            b"dynamicFilter" => {
                                f_dynamic_filter =
                                    Some(Box::new(DynamicFilter::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-filtering")]
                            b"colorFilter" => {
                                f_color_filter =
                                    Some(Box::new(ColorFilter::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-filtering")]
                            b"iconFilter" => {
                                f_icon_filter =
                                    Some(Box::new(IconFilter::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-extensions")]
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "sml-filtering")]
                            b"filters" => {
                                f_filters = Some(Box::new(Filters::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-filtering")]
                            b"top10" => {
                                f_top10 = Some(Box::new(Top10Filter::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-filtering")]
                            b"customFilters" => {
                                f_custom_filters =
                                    Some(Box::new(CustomFilters::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-filtering")]
                            b"dynamicFilter" => {
                                f_dynamic_filter =
                                    Some(Box::new(DynamicFilter::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-filtering")]
                            b"colorFilter" => {
                                f_color_filter =
                                    Some(Box::new(ColorFilter::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-filtering")]
                            b"iconFilter" => {
                                f_icon_filter =
                                    Some(Box::new(IconFilter::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-extensions")]
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            #[cfg(feature = "sml-filtering")]
            column_id: f_column_id
                .ok_or_else(|| ParseError::MissingAttribute("colId".to_string()))?,
            #[cfg(feature = "sml-filtering")]
            hidden_button: f_hidden_button,
            #[cfg(feature = "sml-filtering")]
            show_button: f_show_button,
            #[cfg(feature = "sml-filtering")]
            filters: f_filters,
            #[cfg(feature = "sml-filtering")]
            top10: f_top10,
            #[cfg(feature = "sml-filtering")]
            custom_filters: f_custom_filters,
            #[cfg(feature = "sml-filtering")]
            dynamic_filter: f_dynamic_filter,
            #[cfg(feature = "sml-filtering")]
            color_filter: f_color_filter,
            #[cfg(feature = "sml-filtering")]
            icon_filter: f_icon_filter,
            #[cfg(feature = "sml-extensions")]
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Filters {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_blank = None;
        let mut f_calendar_type = None;
        let mut f_filter = Vec::new();
        let mut f_date_group_item = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"blank" => {
                    f_blank = Some(val == "true" || val == "1");
                }
                b"calendarType" => {
                    f_calendar_type = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"filter" => {
                                f_filter.push(Filter::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dateGroupItem" => {
                                f_date_group_item.push(DateGroupItem::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"filter" => {
                                f_filter.push(Filter::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dateGroupItem" => {
                                f_date_group_item.push(DateGroupItem::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            blank: f_blank,
            calendar_type: f_calendar_type,
            filter: f_filter,
            date_group_item: f_date_group_item,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Filter {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CustomFilters {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_and = None;
        let mut f_custom_filter = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"and" => {
                    f_and = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"customFilter" => {
                                f_custom_filter.push(CustomFilter::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"customFilter" => {
                                f_custom_filter.push(CustomFilter::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            and: f_and,
            custom_filter: f_custom_filter,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CustomFilter {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_operator = None;
        let mut f_value = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"operator" => {
                    f_operator = val.parse().ok();
                }
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            operator: f_operator,
            value: f_value,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for Top10Filter {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_top = None;
        let mut f_percent = None;
        let mut f_value: Option<f64> = None;
        let mut f_filter_val = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"top" => {
                    f_top = Some(val == "true" || val == "1");
                }
                b"percent" => {
                    f_percent = Some(val == "true" || val == "1");
                }
                b"val" => {
                    f_value = val.parse().ok();
                }
                b"filterVal" => {
                    f_filter_val = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            top: f_top,
            percent: f_percent,
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            filter_val: f_filter_val,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for ColorFilter {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_dxf_id = None;
        let mut f_cell_color = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"dxfId" => {
                    f_dxf_id = val.parse().ok();
                }
                b"cellColor" => {
                    f_cell_color = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            dxf_id: f_dxf_id,
            cell_color: f_cell_color,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for IconFilter {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_icon_set: Option<IconSetType> = None;
        let mut f_icon_id = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"iconSet" => {
                    f_icon_set = val.parse().ok();
                }
                b"iconId" => {
                    f_icon_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            icon_set: f_icon_set
                .ok_or_else(|| ParseError::MissingAttribute("iconSet".to_string()))?,
            icon_id: f_icon_id,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for DynamicFilter {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_type: Option<DynamicFilterType> = None;
        let mut f_value = None;
        let mut f_val_iso = None;
        let mut f_max_val = None;
        let mut f_max_val_iso = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"type" => {
                    f_type = val.parse().ok();
                }
                b"val" => {
                    f_value = val.parse().ok();
                }
                b"valIso" => {
                    f_val_iso = Some(val.into_owned());
                }
                b"maxVal" => {
                    f_max_val = val.parse().ok();
                }
                b"maxValIso" => {
                    f_max_val_iso = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r#type: f_type.ok_or_else(|| ParseError::MissingAttribute("type".to_string()))?,
            value: f_value,
            val_iso: f_val_iso,
            max_val: f_max_val,
            max_val_iso: f_max_val_iso,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for SortState {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_column_sort = None;
        let mut f_case_sensitive = None;
        let mut f_sort_method = None;
        let mut f_reference: Option<Reference> = None;
        let mut f_sort_condition = Vec::new();
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"columnSort" => {
                    f_column_sort = Some(val == "true" || val == "1");
                }
                b"caseSensitive" => {
                    f_case_sensitive = Some(val == "true" || val == "1");
                }
                b"sortMethod" => {
                    f_sort_method = val.parse().ok();
                }
                b"ref" => {
                    f_reference = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"sortCondition" => {
                                f_sort_condition.push(SortCondition::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"sortCondition" => {
                                f_sort_condition.push(SortCondition::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            column_sort: f_column_sort,
            case_sensitive: f_case_sensitive,
            sort_method: f_sort_method,
            reference: f_reference
                .ok_or_else(|| ParseError::MissingAttribute("ref".to_string()))?,
            sort_condition: f_sort_condition,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for SortCondition {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_descending = None;
        let mut f_sort_by = None;
        let mut f_reference: Option<Reference> = None;
        let mut f_custom_list = None;
        let mut f_dxf_id = None;
        let mut f_icon_set = None;
        let mut f_icon_id = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"descending" => {
                    f_descending = Some(val == "true" || val == "1");
                }
                b"sortBy" => {
                    f_sort_by = val.parse().ok();
                }
                b"ref" => {
                    f_reference = Some(val.into_owned());
                }
                b"customList" => {
                    f_custom_list = Some(val.into_owned());
                }
                b"dxfId" => {
                    f_dxf_id = val.parse().ok();
                }
                b"iconSet" => {
                    f_icon_set = val.parse().ok();
                }
                b"iconId" => {
                    f_icon_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            descending: f_descending,
            sort_by: f_sort_by,
            reference: f_reference
                .ok_or_else(|| ParseError::MissingAttribute("ref".to_string()))?,
            custom_list: f_custom_list,
            dxf_id: f_dxf_id,
            icon_set: f_icon_set,
            icon_id: f_icon_id,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for DateGroupItem {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_year: Option<u16> = None;
        let mut f_month = None;
        let mut f_day = None;
        let mut f_hour = None;
        let mut f_minute = None;
        let mut f_second = None;
        let mut f_date_time_grouping: Option<STDateTimeGrouping> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"year" => {
                    f_year = val.parse().ok();
                }
                b"month" => {
                    f_month = val.parse().ok();
                }
                b"day" => {
                    f_day = val.parse().ok();
                }
                b"hour" => {
                    f_hour = val.parse().ok();
                }
                b"minute" => {
                    f_minute = val.parse().ok();
                }
                b"second" => {
                    f_second = val.parse().ok();
                }
                b"dateTimeGrouping" => {
                    f_date_time_grouping = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            year: f_year.ok_or_else(|| ParseError::MissingAttribute("year".to_string()))?,
            month: f_month,
            day: f_day,
            hour: f_hour,
            minute: f_minute,
            second: f_second,
            date_time_grouping: f_date_time_grouping
                .ok_or_else(|| ParseError::MissingAttribute("dateTimeGrouping".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTXStringElement {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<XmlString> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"v" => {
                    f_value = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("v".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for Extension {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_uri = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"uri" => {
                    f_uri = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            uri: f_uri,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for ObjectAnchor {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_move_with_cells = None;
        let mut f_size_with_cells = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"moveWithCells" => {
                    f_move_with_cells = Some(val == "true" || val == "1");
                }
                b"sizeWithCells" => {
                    f_size_with_cells = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            move_with_cells: f_move_with_cells,
            size_with_cells: f_size_with_cells,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for EGExtensionList {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_ext = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"ext" => {
                                f_ext.push(Extension::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"ext" => {
                                f_ext.push(Extension::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            ext: f_ext,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for ExtensionList {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_ext = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"ext" => {
                                f_ext.push(Extension::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"ext" => {
                                f_ext.push(Extension::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            ext: f_ext,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CalcChain {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_cells = Vec::new();
        let mut f_extension_list = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"c" => {
                                f_cells.push(CalcCell::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"c" => {
                                f_cells.push(CalcCell::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            cells: f_cells,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CalcCell {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_any: Option<CellRef> = None;
        let mut f_i = None;
        let mut f_style_index = None;
        let mut f_l = None;
        let mut f_cell_type = None;
        let mut f_a = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"_any" => {
                    f_any = Some(val.into_owned());
                }
                b"i" => {
                    f_i = val.parse().ok();
                }
                b"s" => {
                    f_style_index = Some(val == "true" || val == "1");
                }
                b"l" => {
                    f_l = Some(val == "true" || val == "1");
                }
                b"t" => {
                    f_cell_type = Some(val == "true" || val == "1");
                }
                b"a" => {
                    f_a = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            _any: f_any.ok_or_else(|| ParseError::MissingAttribute("_any".to_string()))?,
            i: f_i,
            style_index: f_style_index,
            l: f_l,
            cell_type: f_cell_type,
            a: f_a,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for Comments {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_authors: Option<Box<Authors>> = None;
        let mut f_comment_list: Option<Box<CommentList>> = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"authors" => {
                                f_authors = Some(Box::new(Authors::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"commentList" => {
                                f_comment_list =
                                    Some(Box::new(CommentList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"authors" => {
                                f_authors = Some(Box::new(Authors::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"commentList" => {
                                f_comment_list =
                                    Some(Box::new(CommentList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            authors: f_authors
                .ok_or_else(|| ParseError::MissingAttribute("authors".to_string()))?,
            comment_list: f_comment_list
                .ok_or_else(|| ParseError::MissingAttribute("commentList".to_string()))?,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Authors {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_author = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"author" => {
                                f_author.push(read_text_content(reader)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"author" => {
                                f_author.push(String::new());
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            author: f_author,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CommentList {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_comment = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"comment" => {
                                f_comment.push(Comment::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"comment" => {
                                f_comment.push(Comment::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            comment: f_comment,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Comment {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "sml-comments")]
        let mut f_reference: Option<Reference> = None;
        #[cfg(feature = "sml-comments")]
        let mut f_author_id: Option<u32> = None;
        #[cfg(feature = "sml-comments")]
        let mut f_guid = None;
        #[cfg(feature = "sml-comments")]
        let mut f_shape_id = None;
        #[cfg(feature = "sml-comments")]
        let mut f_text: Option<Box<RichString>> = None;
        let mut f_comment_pr = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                #[cfg(feature = "sml-comments")]
                b"ref" => {
                    f_reference = Some(val.into_owned());
                }
                #[cfg(feature = "sml-comments")]
                b"authorId" => {
                    f_author_id = val.parse().ok();
                }
                #[cfg(feature = "sml-comments")]
                b"guid" => {
                    f_guid = Some(val.into_owned());
                }
                #[cfg(feature = "sml-comments")]
                b"shapeId" => {
                    f_shape_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "sml-comments")]
                            b"text" => {
                                f_text = Some(Box::new(RichString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"commentPr" => {
                                f_comment_pr =
                                    Some(Box::new(CTCommentPr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "sml-comments")]
                            b"text" => {
                                f_text = Some(Box::new(RichString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"commentPr" => {
                                f_comment_pr =
                                    Some(Box::new(CTCommentPr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            #[cfg(feature = "sml-comments")]
            reference: f_reference
                .ok_or_else(|| ParseError::MissingAttribute("ref".to_string()))?,
            #[cfg(feature = "sml-comments")]
            author_id: f_author_id
                .ok_or_else(|| ParseError::MissingAttribute("authorId".to_string()))?,
            #[cfg(feature = "sml-comments")]
            guid: f_guid,
            #[cfg(feature = "sml-comments")]
            shape_id: f_shape_id,
            #[cfg(feature = "sml-comments")]
            text: f_text.ok_or_else(|| ParseError::MissingAttribute("text".to_string()))?,
            comment_pr: f_comment_pr,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTCommentPr {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_locked = None;
        let mut f_default_size = None;
        let mut f_print = None;
        let mut f_disabled = None;
        let mut f_auto_fill = None;
        let mut f_auto_line = None;
        let mut f_alt_text = None;
        let mut f_text_h_align = None;
        let mut f_text_v_align = None;
        let mut f_lock_text = None;
        let mut f_just_last_x = None;
        let mut f_auto_scale = None;
        let mut f_anchor: Option<Box<ObjectAnchor>> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"locked" => {
                    f_locked = Some(val == "true" || val == "1");
                }
                b"defaultSize" => {
                    f_default_size = Some(val == "true" || val == "1");
                }
                b"print" => {
                    f_print = Some(val == "true" || val == "1");
                }
                b"disabled" => {
                    f_disabled = Some(val == "true" || val == "1");
                }
                b"autoFill" => {
                    f_auto_fill = Some(val == "true" || val == "1");
                }
                b"autoLine" => {
                    f_auto_line = Some(val == "true" || val == "1");
                }
                b"altText" => {
                    f_alt_text = Some(val.into_owned());
                }
                b"textHAlign" => {
                    f_text_h_align = val.parse().ok();
                }
                b"textVAlign" => {
                    f_text_v_align = val.parse().ok();
                }
                b"lockText" => {
                    f_lock_text = Some(val == "true" || val == "1");
                }
                b"justLastX" => {
                    f_just_last_x = Some(val == "true" || val == "1");
                }
                b"autoScale" => {
                    f_auto_scale = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"anchor" => {
                                f_anchor =
                                    Some(Box::new(ObjectAnchor::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"anchor" => {
                                f_anchor =
                                    Some(Box::new(ObjectAnchor::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            locked: f_locked,
            default_size: f_default_size,
            print: f_print,
            disabled: f_disabled,
            auto_fill: f_auto_fill,
            auto_line: f_auto_line,
            alt_text: f_alt_text,
            text_h_align: f_text_h_align,
            text_v_align: f_text_v_align,
            lock_text: f_lock_text,
            just_last_x: f_just_last_x,
            auto_scale: f_auto_scale,
            anchor: f_anchor.ok_or_else(|| ParseError::MissingAttribute("anchor".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for MapInfo {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_selection_namespaces: Option<String> = None;
        let mut f_schema = Vec::new();
        let mut f_map = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"SelectionNamespaces" => {
                    f_selection_namespaces = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"Schema" => {
                                f_schema.push(XmlSchema::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"Map" => {
                                f_map.push(XmlMap::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"Schema" => {
                                f_schema.push(XmlSchema::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"Map" => {
                                f_map.push(XmlMap::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            selection_namespaces: f_selection_namespaces
                .ok_or_else(|| ParseError::MissingAttribute("SelectionNamespaces".to_string()))?,
            schema: f_schema,
            map: f_map,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for XmlSchema {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    #[cfg(feature = "extra-children")]
                    Event::Start(e) => {
                        let elem = RawXmlElement::from_reader(reader, &e)?;
                        extra_children
                            .push(PositionedNode::new(child_idx, RawXmlNode::Element(elem)));
                        child_idx += 1;
                    }
                    #[cfg(not(feature = "extra-children"))]
                    Event::Start(_) => {
                        skip_element(reader)?;
                    }
                    #[cfg(feature = "extra-children")]
                    Event::Empty(e) => {
                        let elem = RawXmlElement::from_empty(&e);
                        extra_children
                            .push(PositionedNode::new(child_idx, RawXmlNode::Element(elem)));
                        child_idx += 1;
                    }
                    #[cfg(not(feature = "extra-children"))]
                    Event::Empty(_) => {}
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }
        Ok(Self {
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for XmlMap {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_i_d: Option<u32> = None;
        let mut f_name: Option<String> = None;
        let mut f_root_element: Option<String> = None;
        let mut f_schema_i_d: Option<String> = None;
        let mut f_show_import_export_validation_errors: Option<bool> = None;
        let mut f_auto_fit: Option<bool> = None;
        let mut f_append: Option<bool> = None;
        let mut f_preserve_sort_a_f_layout: Option<bool> = None;
        let mut f_preserve_format: Option<bool> = None;
        let mut f_data_binding = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"ID" => {
                    f_i_d = val.parse().ok();
                }
                b"Name" => {
                    f_name = Some(val.into_owned());
                }
                b"RootElement" => {
                    f_root_element = Some(val.into_owned());
                }
                b"SchemaID" => {
                    f_schema_i_d = Some(val.into_owned());
                }
                b"ShowImportExportValidationErrors" => {
                    f_show_import_export_validation_errors = Some(val == "true" || val == "1");
                }
                b"AutoFit" => {
                    f_auto_fit = Some(val == "true" || val == "1");
                }
                b"Append" => {
                    f_append = Some(val == "true" || val == "1");
                }
                b"PreserveSortAFLayout" => {
                    f_preserve_sort_a_f_layout = Some(val == "true" || val == "1");
                }
                b"PreserveFormat" => {
                    f_preserve_format = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"DataBinding" => {
                                f_data_binding =
                                    Some(Box::new(DataBinding::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"DataBinding" => {
                                f_data_binding =
                                    Some(Box::new(DataBinding::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            i_d: f_i_d.ok_or_else(|| ParseError::MissingAttribute("ID".to_string()))?,
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("Name".to_string()))?,
            root_element: f_root_element
                .ok_or_else(|| ParseError::MissingAttribute("RootElement".to_string()))?,
            schema_i_d: f_schema_i_d
                .ok_or_else(|| ParseError::MissingAttribute("SchemaID".to_string()))?,
            show_import_export_validation_errors: f_show_import_export_validation_errors
                .ok_or_else(|| {
                    ParseError::MissingAttribute("ShowImportExportValidationErrors".to_string())
                })?,
            auto_fit: f_auto_fit
                .ok_or_else(|| ParseError::MissingAttribute("AutoFit".to_string()))?,
            append: f_append.ok_or_else(|| ParseError::MissingAttribute("Append".to_string()))?,
            preserve_sort_a_f_layout: f_preserve_sort_a_f_layout
                .ok_or_else(|| ParseError::MissingAttribute("PreserveSortAFLayout".to_string()))?,
            preserve_format: f_preserve_format
                .ok_or_else(|| ParseError::MissingAttribute("PreserveFormat".to_string()))?,
            data_binding: f_data_binding,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for DataBinding {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_data_binding_name = None;
        let mut f_file_binding = None;
        let mut f_connection_i_d = None;
        let mut f_file_binding_name = None;
        let mut f_data_binding_load_mode: Option<u32> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"DataBindingName" => {
                    f_data_binding_name = Some(val.into_owned());
                }
                b"FileBinding" => {
                    f_file_binding = Some(val == "true" || val == "1");
                }
                b"ConnectionID" => {
                    f_connection_i_d = val.parse().ok();
                }
                b"FileBindingName" => {
                    f_file_binding_name = Some(val.into_owned());
                }
                b"DataBindingLoadMode" => {
                    f_data_binding_load_mode = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            data_binding_name: f_data_binding_name,
            file_binding: f_file_binding,
            connection_i_d: f_connection_i_d,
            file_binding_name: f_file_binding_name,
            data_binding_load_mode: f_data_binding_load_mode
                .ok_or_else(|| ParseError::MissingAttribute("DataBindingLoadMode".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for Connections {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_connection = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"connection" => {
                                f_connection.push(Connection::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"connection" => {
                                f_connection.push(Connection::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            connection: f_connection,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Connection {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<u32> = None;
        let mut f_source_file = None;
        let mut f_odc_file = None;
        let mut f_keep_alive = None;
        let mut f_interval = None;
        let mut f_name = None;
        let mut f_description = None;
        let mut f_type = None;
        let mut f_reconnection_method = None;
        let mut f_refreshed_version: Option<u8> = None;
        let mut f_min_refreshable_version = None;
        let mut f_save_password = None;
        let mut f_new = None;
        let mut f_deleted = None;
        let mut f_only_use_connection_file = None;
        let mut f_background = None;
        let mut f_refresh_on_load = None;
        let mut f_save_data = None;
        let mut f_credentials = None;
        let mut f_single_sign_on_id = None;
        let mut f_db_pr = None;
        let mut f_olap_pr = None;
        let mut f_web_pr = None;
        let mut f_text_pr = None;
        let mut f_parameters = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"sourceFile" => {
                    f_source_file = Some(val.into_owned());
                }
                b"odcFile" => {
                    f_odc_file = Some(val.into_owned());
                }
                b"keepAlive" => {
                    f_keep_alive = Some(val == "true" || val == "1");
                }
                b"interval" => {
                    f_interval = val.parse().ok();
                }
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"description" => {
                    f_description = Some(val.into_owned());
                }
                b"type" => {
                    f_type = val.parse().ok();
                }
                b"reconnectionMethod" => {
                    f_reconnection_method = val.parse().ok();
                }
                b"refreshedVersion" => {
                    f_refreshed_version = val.parse().ok();
                }
                b"minRefreshableVersion" => {
                    f_min_refreshable_version = val.parse().ok();
                }
                b"savePassword" => {
                    f_save_password = Some(val == "true" || val == "1");
                }
                b"new" => {
                    f_new = Some(val == "true" || val == "1");
                }
                b"deleted" => {
                    f_deleted = Some(val == "true" || val == "1");
                }
                b"onlyUseConnectionFile" => {
                    f_only_use_connection_file = Some(val == "true" || val == "1");
                }
                b"background" => {
                    f_background = Some(val == "true" || val == "1");
                }
                b"refreshOnLoad" => {
                    f_refresh_on_load = Some(val == "true" || val == "1");
                }
                b"saveData" => {
                    f_save_data = Some(val == "true" || val == "1");
                }
                b"credentials" => {
                    f_credentials = val.parse().ok();
                }
                b"singleSignOnId" => {
                    f_single_sign_on_id = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"dbPr" => {
                                f_db_pr = Some(Box::new(DatabaseProperties::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"olapPr" => {
                                f_olap_pr =
                                    Some(Box::new(OlapProperties::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"webPr" => {
                                f_web_pr = Some(Box::new(WebQueryProperties::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"textPr" => {
                                f_text_pr = Some(Box::new(TextImportProperties::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"parameters" => {
                                f_parameters =
                                    Some(Box::new(Parameters::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"dbPr" => {
                                f_db_pr =
                                    Some(Box::new(DatabaseProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"olapPr" => {
                                f_olap_pr =
                                    Some(Box::new(OlapProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"webPr" => {
                                f_web_pr =
                                    Some(Box::new(WebQueryProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"textPr" => {
                                f_text_pr = Some(Box::new(TextImportProperties::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"parameters" => {
                                f_parameters =
                                    Some(Box::new(Parameters::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            source_file: f_source_file,
            odc_file: f_odc_file,
            keep_alive: f_keep_alive,
            interval: f_interval,
            name: f_name,
            description: f_description,
            r#type: f_type,
            reconnection_method: f_reconnection_method,
            refreshed_version: f_refreshed_version
                .ok_or_else(|| ParseError::MissingAttribute("refreshedVersion".to_string()))?,
            min_refreshable_version: f_min_refreshable_version,
            save_password: f_save_password,
            new: f_new,
            deleted: f_deleted,
            only_use_connection_file: f_only_use_connection_file,
            background: f_background,
            refresh_on_load: f_refresh_on_load,
            save_data: f_save_data,
            credentials: f_credentials,
            single_sign_on_id: f_single_sign_on_id,
            db_pr: f_db_pr,
            olap_pr: f_olap_pr,
            web_pr: f_web_pr,
            text_pr: f_text_pr,
            parameters: f_parameters,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for DatabaseProperties {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_connection: Option<XmlString> = None;
        let mut f_command = None;
        let mut f_server_command = None;
        let mut f_command_type = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"connection" => {
                    f_connection = Some(val.into_owned());
                }
                b"command" => {
                    f_command = Some(val.into_owned());
                }
                b"serverCommand" => {
                    f_server_command = Some(val.into_owned());
                }
                b"commandType" => {
                    f_command_type = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            connection: f_connection
                .ok_or_else(|| ParseError::MissingAttribute("connection".to_string()))?,
            command: f_command,
            server_command: f_server_command,
            command_type: f_command_type,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for OlapProperties {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_local = None;
        let mut f_local_connection = None;
        let mut f_local_refresh = None;
        let mut f_send_locale = None;
        let mut f_row_drill_count = None;
        let mut f_server_fill = None;
        let mut f_server_number_format = None;
        let mut f_server_font = None;
        let mut f_server_font_color = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"local" => {
                    f_local = Some(val == "true" || val == "1");
                }
                b"localConnection" => {
                    f_local_connection = Some(val.into_owned());
                }
                b"localRefresh" => {
                    f_local_refresh = Some(val == "true" || val == "1");
                }
                b"sendLocale" => {
                    f_send_locale = Some(val == "true" || val == "1");
                }
                b"rowDrillCount" => {
                    f_row_drill_count = val.parse().ok();
                }
                b"serverFill" => {
                    f_server_fill = Some(val == "true" || val == "1");
                }
                b"serverNumberFormat" => {
                    f_server_number_format = Some(val == "true" || val == "1");
                }
                b"serverFont" => {
                    f_server_font = Some(val == "true" || val == "1");
                }
                b"serverFontColor" => {
                    f_server_font_color = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            local: f_local,
            local_connection: f_local_connection,
            local_refresh: f_local_refresh,
            send_locale: f_send_locale,
            row_drill_count: f_row_drill_count,
            server_fill: f_server_fill,
            server_number_format: f_server_number_format,
            server_font: f_server_font,
            server_font_color: f_server_font_color,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for WebQueryProperties {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_xml = None;
        let mut f_source_data = None;
        let mut f_parse_pre = None;
        let mut f_consecutive = None;
        let mut f_first_row = None;
        let mut f_xl97 = None;
        let mut f_text_dates = None;
        let mut f_xl2000 = None;
        let mut f_url = None;
        let mut f_post = None;
        let mut f_html_tables = None;
        let mut f_html_format = None;
        let mut f_edit_page = None;
        let mut f_tables = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"xml" => {
                    f_xml = Some(val == "true" || val == "1");
                }
                b"sourceData" => {
                    f_source_data = Some(val == "true" || val == "1");
                }
                b"parsePre" => {
                    f_parse_pre = Some(val == "true" || val == "1");
                }
                b"consecutive" => {
                    f_consecutive = Some(val == "true" || val == "1");
                }
                b"firstRow" => {
                    f_first_row = Some(val == "true" || val == "1");
                }
                b"xl97" => {
                    f_xl97 = Some(val == "true" || val == "1");
                }
                b"textDates" => {
                    f_text_dates = Some(val == "true" || val == "1");
                }
                b"xl2000" => {
                    f_xl2000 = Some(val == "true" || val == "1");
                }
                b"url" => {
                    f_url = Some(val.into_owned());
                }
                b"post" => {
                    f_post = Some(val.into_owned());
                }
                b"htmlTables" => {
                    f_html_tables = Some(val == "true" || val == "1");
                }
                b"htmlFormat" => {
                    f_html_format = val.parse().ok();
                }
                b"editPage" => {
                    f_edit_page = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"tables" => {
                                f_tables = Some(Box::new(DataTables::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"tables" => {
                                f_tables = Some(Box::new(DataTables::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            xml: f_xml,
            source_data: f_source_data,
            parse_pre: f_parse_pre,
            consecutive: f_consecutive,
            first_row: f_first_row,
            xl97: f_xl97,
            text_dates: f_text_dates,
            xl2000: f_xl2000,
            url: f_url,
            post: f_post,
            html_tables: f_html_tables,
            html_format: f_html_format,
            edit_page: f_edit_page,
            tables: f_tables,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Parameters {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_parameter = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"parameter" => {
                                f_parameter.push(Parameter::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"parameter" => {
                                f_parameter.push(Parameter::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            parameter: f_parameter,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Parameter {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name = None;
        let mut f_sql_type = None;
        let mut f_parameter_type = None;
        let mut f_refresh_on_change = None;
        let mut f_prompt = None;
        let mut f_boolean = None;
        let mut f_double = None;
        let mut f_integer = None;
        let mut f_string = None;
        let mut f_cell = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"sqlType" => {
                    f_sql_type = val.parse().ok();
                }
                b"parameterType" => {
                    f_parameter_type = val.parse().ok();
                }
                b"refreshOnChange" => {
                    f_refresh_on_change = Some(val == "true" || val == "1");
                }
                b"prompt" => {
                    f_prompt = Some(val.into_owned());
                }
                b"boolean" => {
                    f_boolean = Some(val == "true" || val == "1");
                }
                b"double" => {
                    f_double = val.parse().ok();
                }
                b"integer" => {
                    f_integer = val.parse().ok();
                }
                b"string" => {
                    f_string = Some(val.into_owned());
                }
                b"cell" => {
                    f_cell = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name,
            sql_type: f_sql_type,
            parameter_type: f_parameter_type,
            refresh_on_change: f_refresh_on_change,
            prompt: f_prompt,
            boolean: f_boolean,
            double: f_double,
            integer: f_integer,
            string: f_string,
            cell: f_cell,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for DataTables {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_m = None;
        let mut f_style_index = None;
        let mut f_x = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"m" => {
                                f_m = Some(Box::new(TableMissing::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"s" => {
                                f_style_index =
                                    Some(Box::new(CTXStringElement::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"x" => {
                                f_x = Some(Box::new(CTIndex::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"m" => {
                                f_m = Some(Box::new(TableMissing::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"s" => {
                                f_style_index =
                                    Some(Box::new(CTXStringElement::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"x" => {
                                f_x = Some(Box::new(CTIndex::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            m: f_m,
            style_index: f_style_index,
            x: f_x,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for TableMissing {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        _start: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        if !is_empty {
            let mut buf = Vec::new();
            let mut depth = 1u32;
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(_) => depth += 1,
                    Event::End(_) => {
                        depth -= 1;
                        if depth == 0 {
                            break;
                        }
                    }
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }
        Ok(Self {})
    }
}

impl FromXml for TextImportProperties {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_prompt = None;
        let mut f_file_type = None;
        let mut f_code_page = None;
        let mut f_character_set = None;
        let mut f_first_row = None;
        let mut f_source_file = None;
        let mut f_delimited = None;
        let mut f_decimal = None;
        let mut f_thousands = None;
        let mut f_tab = None;
        let mut f_space = None;
        let mut f_comma = None;
        let mut f_semicolon = None;
        let mut f_consecutive = None;
        let mut f_qualifier = None;
        let mut f_delimiter = None;
        let mut f_text_fields = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"prompt" => {
                    f_prompt = Some(val == "true" || val == "1");
                }
                b"fileType" => {
                    f_file_type = val.parse().ok();
                }
                b"codePage" => {
                    f_code_page = val.parse().ok();
                }
                b"characterSet" => {
                    f_character_set = Some(val.into_owned());
                }
                b"firstRow" => {
                    f_first_row = val.parse().ok();
                }
                b"sourceFile" => {
                    f_source_file = Some(val.into_owned());
                }
                b"delimited" => {
                    f_delimited = Some(val == "true" || val == "1");
                }
                b"decimal" => {
                    f_decimal = Some(val.into_owned());
                }
                b"thousands" => {
                    f_thousands = Some(val.into_owned());
                }
                b"tab" => {
                    f_tab = Some(val == "true" || val == "1");
                }
                b"space" => {
                    f_space = Some(val == "true" || val == "1");
                }
                b"comma" => {
                    f_comma = Some(val == "true" || val == "1");
                }
                b"semicolon" => {
                    f_semicolon = Some(val == "true" || val == "1");
                }
                b"consecutive" => {
                    f_consecutive = Some(val == "true" || val == "1");
                }
                b"qualifier" => {
                    f_qualifier = val.parse().ok();
                }
                b"delimiter" => {
                    f_delimiter = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"textFields" => {
                                f_text_fields =
                                    Some(Box::new(TextFields::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"textFields" => {
                                f_text_fields =
                                    Some(Box::new(TextFields::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            prompt: f_prompt,
            file_type: f_file_type,
            code_page: f_code_page,
            character_set: f_character_set,
            first_row: f_first_row,
            source_file: f_source_file,
            delimited: f_delimited,
            decimal: f_decimal,
            thousands: f_thousands,
            tab: f_tab,
            space: f_space,
            comma: f_comma,
            semicolon: f_semicolon,
            consecutive: f_consecutive,
            qualifier: f_qualifier,
            delimiter: f_delimiter,
            text_fields: f_text_fields,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for TextFields {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_text_field = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"textField" => {
                                f_text_field.push(TextField::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"textField" => {
                                f_text_field.push(TextField::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            text_field: f_text_field,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for TextField {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_type = None;
        let mut f_position = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"type" => {
                    f_type = val.parse().ok();
                }
                b"position" => {
                    f_position = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r#type: f_type,
            position: f_position,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for PivotCacheDefinition {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id = None;
        let mut f_invalid = None;
        let mut f_save_data = None;
        let mut f_refresh_on_load = None;
        let mut f_optimize_memory = None;
        let mut f_enable_refresh = None;
        let mut f_refreshed_by = None;
        let mut f_refreshed_date = None;
        let mut f_refreshed_date_iso = None;
        let mut f_background_query = None;
        let mut f_missing_items_limit = None;
        let mut f_created_version = None;
        let mut f_refreshed_version = None;
        let mut f_min_refreshable_version = None;
        let mut f_record_count = None;
        let mut f_upgrade_on_refresh = None;
        let mut f_tuple_cache = None;
        let mut f_support_subquery = None;
        let mut f_support_advanced_drill = None;
        let mut f_cache_source: Option<Box<CacheSource>> = None;
        let mut f_cache_fields: Option<Box<CacheFields>> = None;
        let mut f_cache_hierarchies = None;
        let mut f_kpis = None;
        let mut f_calculated_items = None;
        let mut f_calculated_members = None;
        let mut f_dimensions = None;
        let mut f_measure_groups = None;
        let mut f_maps = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = Some(val.into_owned());
                }
                b"invalid" => {
                    f_invalid = Some(val == "true" || val == "1");
                }
                b"saveData" => {
                    f_save_data = Some(val == "true" || val == "1");
                }
                b"refreshOnLoad" => {
                    f_refresh_on_load = Some(val == "true" || val == "1");
                }
                b"optimizeMemory" => {
                    f_optimize_memory = Some(val == "true" || val == "1");
                }
                b"enableRefresh" => {
                    f_enable_refresh = Some(val == "true" || val == "1");
                }
                b"refreshedBy" => {
                    f_refreshed_by = Some(val.into_owned());
                }
                b"refreshedDate" => {
                    f_refreshed_date = val.parse().ok();
                }
                b"refreshedDateIso" => {
                    f_refreshed_date_iso = Some(val.into_owned());
                }
                b"backgroundQuery" => {
                    f_background_query = Some(val == "true" || val == "1");
                }
                b"missingItemsLimit" => {
                    f_missing_items_limit = val.parse().ok();
                }
                b"createdVersion" => {
                    f_created_version = val.parse().ok();
                }
                b"refreshedVersion" => {
                    f_refreshed_version = val.parse().ok();
                }
                b"minRefreshableVersion" => {
                    f_min_refreshable_version = val.parse().ok();
                }
                b"recordCount" => {
                    f_record_count = val.parse().ok();
                }
                b"upgradeOnRefresh" => {
                    f_upgrade_on_refresh = Some(val == "true" || val == "1");
                }
                b"tupleCache" => {
                    f_tuple_cache = Some(val == "true" || val == "1");
                }
                b"supportSubquery" => {
                    f_support_subquery = Some(val == "true" || val == "1");
                }
                b"supportAdvancedDrill" => {
                    f_support_advanced_drill = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"cacheSource" => {
                                f_cache_source =
                                    Some(Box::new(CacheSource::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cacheFields" => {
                                f_cache_fields =
                                    Some(Box::new(CacheFields::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cacheHierarchies" => {
                                f_cache_hierarchies = Some(Box::new(CTCacheHierarchies::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"kpis" => {
                                f_kpis = Some(Box::new(CTPCDKPIs::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"calculatedItems" => {
                                f_calculated_items =
                                    Some(Box::new(CTCalculatedItems::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"calculatedMembers" => {
                                f_calculated_members = Some(Box::new(
                                    CTCalculatedMembers::from_xml(reader, &e, false)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dimensions" => {
                                f_dimensions =
                                    Some(Box::new(CTDimensions::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"measureGroups" => {
                                f_measure_groups =
                                    Some(Box::new(CTMeasureGroups::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"maps" => {
                                f_maps = Some(Box::new(CTMeasureDimensionMaps::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"cacheSource" => {
                                f_cache_source =
                                    Some(Box::new(CacheSource::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cacheFields" => {
                                f_cache_fields =
                                    Some(Box::new(CacheFields::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cacheHierarchies" => {
                                f_cache_hierarchies =
                                    Some(Box::new(CTCacheHierarchies::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"kpis" => {
                                f_kpis = Some(Box::new(CTPCDKPIs::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"calculatedItems" => {
                                f_calculated_items =
                                    Some(Box::new(CTCalculatedItems::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"calculatedMembers" => {
                                f_calculated_members = Some(Box::new(
                                    CTCalculatedMembers::from_xml(reader, &e, true)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dimensions" => {
                                f_dimensions =
                                    Some(Box::new(CTDimensions::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"measureGroups" => {
                                f_measure_groups =
                                    Some(Box::new(CTMeasureGroups::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"maps" => {
                                f_maps = Some(Box::new(CTMeasureDimensionMaps::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id,
            invalid: f_invalid,
            save_data: f_save_data,
            refresh_on_load: f_refresh_on_load,
            optimize_memory: f_optimize_memory,
            enable_refresh: f_enable_refresh,
            refreshed_by: f_refreshed_by,
            refreshed_date: f_refreshed_date,
            refreshed_date_iso: f_refreshed_date_iso,
            background_query: f_background_query,
            missing_items_limit: f_missing_items_limit,
            created_version: f_created_version,
            refreshed_version: f_refreshed_version,
            min_refreshable_version: f_min_refreshable_version,
            record_count: f_record_count,
            upgrade_on_refresh: f_upgrade_on_refresh,
            tuple_cache: f_tuple_cache,
            support_subquery: f_support_subquery,
            support_advanced_drill: f_support_advanced_drill,
            cache_source: f_cache_source
                .ok_or_else(|| ParseError::MissingAttribute("cacheSource".to_string()))?,
            cache_fields: f_cache_fields
                .ok_or_else(|| ParseError::MissingAttribute("cacheFields".to_string()))?,
            cache_hierarchies: f_cache_hierarchies,
            kpis: f_kpis,
            calculated_items: f_calculated_items,
            calculated_members: f_calculated_members,
            dimensions: f_dimensions,
            measure_groups: f_measure_groups,
            maps: f_maps,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CacheFields {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_cache_field = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"cacheField" => {
                                f_cache_field.push(CacheField::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"cacheField" => {
                                f_cache_field.push(CacheField::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            cache_field: f_cache_field,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CacheField {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name: Option<XmlString> = None;
        let mut f_caption = None;
        let mut f_property_name = None;
        let mut f_server_field = None;
        let mut f_unique_list = None;
        let mut f_number_format_id = None;
        let mut f_formula = None;
        let mut f_sql_type = None;
        let mut f_hierarchy = None;
        let mut f_level = None;
        let mut f_database_field = None;
        let mut f_mapping_count = None;
        let mut f_member_property_field = None;
        let mut f_shared_items = None;
        let mut f_field_group = None;
        let mut f_mp_map = Vec::new();
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"caption" => {
                    f_caption = Some(val.into_owned());
                }
                b"propertyName" => {
                    f_property_name = Some(val.into_owned());
                }
                b"serverField" => {
                    f_server_field = Some(val == "true" || val == "1");
                }
                b"uniqueList" => {
                    f_unique_list = Some(val == "true" || val == "1");
                }
                b"numFmtId" => {
                    f_number_format_id = val.parse().ok();
                }
                b"formula" => {
                    f_formula = Some(val.into_owned());
                }
                b"sqlType" => {
                    f_sql_type = val.parse().ok();
                }
                b"hierarchy" => {
                    f_hierarchy = val.parse().ok();
                }
                b"level" => {
                    f_level = val.parse().ok();
                }
                b"databaseField" => {
                    f_database_field = Some(val == "true" || val == "1");
                }
                b"mappingCount" => {
                    f_mapping_count = val.parse().ok();
                }
                b"memberPropertyField" => {
                    f_member_property_field = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"sharedItems" => {
                                f_shared_items =
                                    Some(Box::new(SharedItems::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"fieldGroup" => {
                                f_field_group =
                                    Some(Box::new(FieldGroup::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"mpMap" => {
                                f_mp_map.push(CTX::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"sharedItems" => {
                                f_shared_items =
                                    Some(Box::new(SharedItems::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"fieldGroup" => {
                                f_field_group =
                                    Some(Box::new(FieldGroup::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"mpMap" => {
                                f_mp_map.push(CTX::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            caption: f_caption,
            property_name: f_property_name,
            server_field: f_server_field,
            unique_list: f_unique_list,
            number_format_id: f_number_format_id,
            formula: f_formula,
            sql_type: f_sql_type,
            hierarchy: f_hierarchy,
            level: f_level,
            database_field: f_database_field,
            mapping_count: f_mapping_count,
            member_property_field: f_member_property_field,
            shared_items: f_shared_items,
            field_group: f_field_group,
            mp_map: f_mp_map,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CacheSource {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_type: Option<STSourceType> = None;
        let mut f_connection_id = None;
        let mut f_worksheet_source = None;
        let mut f_consolidation = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"type" => {
                    f_type = val.parse().ok();
                }
                b"connectionId" => {
                    f_connection_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"worksheetSource" => {
                                f_worksheet_source =
                                    Some(Box::new(WorksheetSource::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"consolidation" => {
                                f_consolidation =
                                    Some(Box::new(Consolidation::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"worksheetSource" => {
                                f_worksheet_source =
                                    Some(Box::new(WorksheetSource::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"consolidation" => {
                                f_consolidation =
                                    Some(Box::new(Consolidation::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r#type: f_type.ok_or_else(|| ParseError::MissingAttribute("type".to_string()))?,
            connection_id: f_connection_id,
            worksheet_source: f_worksheet_source,
            consolidation: f_consolidation,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for WorksheetSource {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_reference = None;
        let mut f_name = None;
        let mut f_sheet = None;
        let mut f_id = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"ref" => {
                    f_reference = Some(val.into_owned());
                }
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"sheet" => {
                    f_sheet = Some(val.into_owned());
                }
                b"id" => {
                    f_id = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            reference: f_reference,
            name: f_name,
            sheet: f_sheet,
            id: f_id,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for Consolidation {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_auto_page = None;
        let mut f_pages = None;
        let mut f_range_sets: Option<Box<CTRangeSets>> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"autoPage" => {
                    f_auto_page = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"pages" => {
                                f_pages = Some(Box::new(CTPages::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rangeSets" => {
                                f_range_sets =
                                    Some(Box::new(CTRangeSets::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"pages" => {
                                f_pages = Some(Box::new(CTPages::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rangeSets" => {
                                f_range_sets =
                                    Some(Box::new(CTRangeSets::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            auto_page: f_auto_page,
            pages: f_pages,
            range_sets: f_range_sets
                .ok_or_else(|| ParseError::MissingAttribute("rangeSets".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTPages {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_page = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"page" => {
                                f_page.push(CTPCDSCPage::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"page" => {
                                f_page.push(CTPCDSCPage::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            page: f_page,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTPCDSCPage {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_page_item = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"pageItem" => {
                                f_page_item.push(CTPageItem::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"pageItem" => {
                                f_page_item.push(CTPageItem::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            page_item: f_page_item,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTPageItem {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name: Option<XmlString> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTRangeSets {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_range_set = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"rangeSet" => {
                                f_range_set.push(CTRangeSet::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"rangeSet" => {
                                f_range_set.push(CTRangeSet::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            range_set: f_range_set,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTRangeSet {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_i1 = None;
        let mut f_i2 = None;
        let mut f_i3 = None;
        let mut f_i4 = None;
        let mut f_reference = None;
        let mut f_name = None;
        let mut f_sheet = None;
        let mut f_id = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"i1" => {
                    f_i1 = val.parse().ok();
                }
                b"i2" => {
                    f_i2 = val.parse().ok();
                }
                b"i3" => {
                    f_i3 = val.parse().ok();
                }
                b"i4" => {
                    f_i4 = val.parse().ok();
                }
                b"ref" => {
                    f_reference = Some(val.into_owned());
                }
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"sheet" => {
                    f_sheet = Some(val.into_owned());
                }
                b"id" => {
                    f_id = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            i1: f_i1,
            i2: f_i2,
            i3: f_i3,
            i4: f_i4,
            reference: f_reference,
            name: f_name,
            sheet: f_sheet,
            id: f_id,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for SharedItems {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_contains_semi_mixed_types = None;
        let mut f_contains_non_date = None;
        let mut f_contains_date = None;
        let mut f_contains_string = None;
        let mut f_contains_blank = None;
        let mut f_contains_mixed_types = None;
        let mut f_contains_number = None;
        let mut f_contains_integer = None;
        let mut f_min_value = None;
        let mut f_max_value = None;
        let mut f_min_date = None;
        let mut f_max_date = None;
        let mut f_count = None;
        let mut f_long_text = None;
        let mut f_m = None;
        let mut f_n = None;
        let mut f_b = None;
        let mut f_e = None;
        let mut f_style_index = None;
        let mut f_d = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"containsSemiMixedTypes" => {
                    f_contains_semi_mixed_types = Some(val == "true" || val == "1");
                }
                b"containsNonDate" => {
                    f_contains_non_date = Some(val == "true" || val == "1");
                }
                b"containsDate" => {
                    f_contains_date = Some(val == "true" || val == "1");
                }
                b"containsString" => {
                    f_contains_string = Some(val == "true" || val == "1");
                }
                b"containsBlank" => {
                    f_contains_blank = Some(val == "true" || val == "1");
                }
                b"containsMixedTypes" => {
                    f_contains_mixed_types = Some(val == "true" || val == "1");
                }
                b"containsNumber" => {
                    f_contains_number = Some(val == "true" || val == "1");
                }
                b"containsInteger" => {
                    f_contains_integer = Some(val == "true" || val == "1");
                }
                b"minValue" => {
                    f_min_value = val.parse().ok();
                }
                b"maxValue" => {
                    f_max_value = val.parse().ok();
                }
                b"minDate" => {
                    f_min_date = Some(val.into_owned());
                }
                b"maxDate" => {
                    f_max_date = Some(val.into_owned());
                }
                b"count" => {
                    f_count = val.parse().ok();
                }
                b"longText" => {
                    f_long_text = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"m" => {
                                f_m = Some(Box::new(CTMissing::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"n" => {
                                f_n = Some(Box::new(CTNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"b" => {
                                f_b = Some(Box::new(CTBoolean::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"e" => {
                                f_e = Some(Box::new(CTError::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"s" => {
                                f_style_index =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"d" => {
                                f_d = Some(Box::new(CTDateTime::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"m" => {
                                f_m = Some(Box::new(CTMissing::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"n" => {
                                f_n = Some(Box::new(CTNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"b" => {
                                f_b = Some(Box::new(CTBoolean::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"e" => {
                                f_e = Some(Box::new(CTError::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"s" => {
                                f_style_index =
                                    Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"d" => {
                                f_d = Some(Box::new(CTDateTime::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            contains_semi_mixed_types: f_contains_semi_mixed_types,
            contains_non_date: f_contains_non_date,
            contains_date: f_contains_date,
            contains_string: f_contains_string,
            contains_blank: f_contains_blank,
            contains_mixed_types: f_contains_mixed_types,
            contains_number: f_contains_number,
            contains_integer: f_contains_integer,
            min_value: f_min_value,
            max_value: f_max_value,
            min_date: f_min_date,
            max_date: f_max_date,
            count: f_count,
            long_text: f_long_text,
            m: f_m,
            n: f_n,
            b: f_b,
            e: f_e,
            style_index: f_style_index,
            d: f_d,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTMissing {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_u = None;
        let mut f_formula = None;
        let mut f_cells = None;
        let mut f_cp = None;
        let mut f_in = None;
        let mut f_bc = None;
        let mut f_fc = None;
        let mut f_i = None;
        let mut f_un = None;
        let mut f_st = None;
        let mut f_b = None;
        let mut f_tpls = Vec::new();
        let mut f_x = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"u" => {
                    f_u = Some(val == "true" || val == "1");
                }
                b"f" => {
                    f_formula = Some(val == "true" || val == "1");
                }
                b"c" => {
                    f_cells = Some(val.into_owned());
                }
                b"cp" => {
                    f_cp = val.parse().ok();
                }
                b"in" => {
                    f_in = val.parse().ok();
                }
                b"bc" => {
                    f_bc = decode_hex(&val);
                }
                b"fc" => {
                    f_fc = decode_hex(&val);
                }
                b"i" => {
                    f_i = Some(val == "true" || val == "1");
                }
                b"un" => {
                    f_un = Some(val == "true" || val == "1");
                }
                b"st" => {
                    f_st = Some(val == "true" || val == "1");
                }
                b"b" => {
                    f_b = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"tpls" => {
                                f_tpls.push(CTTuples::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"x" => {
                                f_x.push(CTX::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"tpls" => {
                                f_tpls.push(CTTuples::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"x" => {
                                f_x.push(CTX::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            u: f_u,
            formula: f_formula,
            cells: f_cells,
            cp: f_cp,
            r#in: f_in,
            bc: f_bc,
            fc: f_fc,
            i: f_i,
            un: f_un,
            st: f_st,
            b: f_b,
            tpls: f_tpls,
            x: f_x,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTNumber {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<f64> = None;
        let mut f_u = None;
        let mut f_formula = None;
        let mut f_cells = None;
        let mut f_cp = None;
        let mut f_in = None;
        let mut f_bc = None;
        let mut f_fc = None;
        let mut f_i = None;
        let mut f_un = None;
        let mut f_st = None;
        let mut f_b = None;
        let mut f_tpls = Vec::new();
        let mut f_x = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"v" => {
                    f_value = val.parse().ok();
                }
                b"u" => {
                    f_u = Some(val == "true" || val == "1");
                }
                b"f" => {
                    f_formula = Some(val == "true" || val == "1");
                }
                b"c" => {
                    f_cells = Some(val.into_owned());
                }
                b"cp" => {
                    f_cp = val.parse().ok();
                }
                b"in" => {
                    f_in = val.parse().ok();
                }
                b"bc" => {
                    f_bc = decode_hex(&val);
                }
                b"fc" => {
                    f_fc = decode_hex(&val);
                }
                b"i" => {
                    f_i = Some(val == "true" || val == "1");
                }
                b"un" => {
                    f_un = Some(val == "true" || val == "1");
                }
                b"st" => {
                    f_st = Some(val == "true" || val == "1");
                }
                b"b" => {
                    f_b = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"tpls" => {
                                f_tpls.push(CTTuples::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"x" => {
                                f_x.push(CTX::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"tpls" => {
                                f_tpls.push(CTTuples::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"x" => {
                                f_x.push(CTX::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("v".to_string()))?,
            u: f_u,
            formula: f_formula,
            cells: f_cells,
            cp: f_cp,
            r#in: f_in,
            bc: f_bc,
            fc: f_fc,
            i: f_i,
            un: f_un,
            st: f_st,
            b: f_b,
            tpls: f_tpls,
            x: f_x,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTBoolean {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<bool> = None;
        let mut f_u = None;
        let mut f_formula = None;
        let mut f_cells = None;
        let mut f_cp = None;
        let mut f_x = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"v" => {
                    f_value = Some(val == "true" || val == "1");
                }
                b"u" => {
                    f_u = Some(val == "true" || val == "1");
                }
                b"f" => {
                    f_formula = Some(val == "true" || val == "1");
                }
                b"c" => {
                    f_cells = Some(val.into_owned());
                }
                b"cp" => {
                    f_cp = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"x" => {
                                f_x.push(CTX::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"x" => {
                                f_x.push(CTX::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("v".to_string()))?,
            u: f_u,
            formula: f_formula,
            cells: f_cells,
            cp: f_cp,
            x: f_x,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTError {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<XmlString> = None;
        let mut f_u = None;
        let mut f_formula = None;
        let mut f_cells = None;
        let mut f_cp = None;
        let mut f_in = None;
        let mut f_bc = None;
        let mut f_fc = None;
        let mut f_i = None;
        let mut f_un = None;
        let mut f_st = None;
        let mut f_b = None;
        let mut f_tpls = None;
        let mut f_x = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"v" => {
                    f_value = Some(val.into_owned());
                }
                b"u" => {
                    f_u = Some(val == "true" || val == "1");
                }
                b"f" => {
                    f_formula = Some(val == "true" || val == "1");
                }
                b"c" => {
                    f_cells = Some(val.into_owned());
                }
                b"cp" => {
                    f_cp = val.parse().ok();
                }
                b"in" => {
                    f_in = val.parse().ok();
                }
                b"bc" => {
                    f_bc = decode_hex(&val);
                }
                b"fc" => {
                    f_fc = decode_hex(&val);
                }
                b"i" => {
                    f_i = Some(val == "true" || val == "1");
                }
                b"un" => {
                    f_un = Some(val == "true" || val == "1");
                }
                b"st" => {
                    f_st = Some(val == "true" || val == "1");
                }
                b"b" => {
                    f_b = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"tpls" => {
                                f_tpls = Some(Box::new(CTTuples::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"x" => {
                                f_x.push(CTX::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"tpls" => {
                                f_tpls = Some(Box::new(CTTuples::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"x" => {
                                f_x.push(CTX::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("v".to_string()))?,
            u: f_u,
            formula: f_formula,
            cells: f_cells,
            cp: f_cp,
            r#in: f_in,
            bc: f_bc,
            fc: f_fc,
            i: f_i,
            un: f_un,
            st: f_st,
            b: f_b,
            tpls: f_tpls,
            x: f_x,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTString {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<XmlString> = None;
        let mut f_u = None;
        let mut f_formula = None;
        let mut f_cells = None;
        let mut f_cp = None;
        let mut f_in = None;
        let mut f_bc = None;
        let mut f_fc = None;
        let mut f_i = None;
        let mut f_un = None;
        let mut f_st = None;
        let mut f_b = None;
        let mut f_tpls = Vec::new();
        let mut f_x = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"v" => {
                    f_value = Some(val.into_owned());
                }
                b"u" => {
                    f_u = Some(val == "true" || val == "1");
                }
                b"f" => {
                    f_formula = Some(val == "true" || val == "1");
                }
                b"c" => {
                    f_cells = Some(val.into_owned());
                }
                b"cp" => {
                    f_cp = val.parse().ok();
                }
                b"in" => {
                    f_in = val.parse().ok();
                }
                b"bc" => {
                    f_bc = decode_hex(&val);
                }
                b"fc" => {
                    f_fc = decode_hex(&val);
                }
                b"i" => {
                    f_i = Some(val == "true" || val == "1");
                }
                b"un" => {
                    f_un = Some(val == "true" || val == "1");
                }
                b"st" => {
                    f_st = Some(val == "true" || val == "1");
                }
                b"b" => {
                    f_b = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"tpls" => {
                                f_tpls.push(CTTuples::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"x" => {
                                f_x.push(CTX::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"tpls" => {
                                f_tpls.push(CTTuples::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"x" => {
                                f_x.push(CTX::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("v".to_string()))?,
            u: f_u,
            formula: f_formula,
            cells: f_cells,
            cp: f_cp,
            r#in: f_in,
            bc: f_bc,
            fc: f_fc,
            i: f_i,
            un: f_un,
            st: f_st,
            b: f_b,
            tpls: f_tpls,
            x: f_x,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTDateTime {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<String> = None;
        let mut f_u = None;
        let mut f_formula = None;
        let mut f_cells = None;
        let mut f_cp = None;
        let mut f_x = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"v" => {
                    f_value = Some(val.into_owned());
                }
                b"u" => {
                    f_u = Some(val == "true" || val == "1");
                }
                b"f" => {
                    f_formula = Some(val == "true" || val == "1");
                }
                b"c" => {
                    f_cells = Some(val.into_owned());
                }
                b"cp" => {
                    f_cp = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"x" => {
                                f_x.push(CTX::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"x" => {
                                f_x.push(CTX::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("v".to_string()))?,
            u: f_u,
            formula: f_formula,
            cells: f_cells,
            cp: f_cp,
            x: f_x,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for FieldGroup {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_par = None;
        let mut f_base = None;
        let mut f_range_pr = None;
        let mut f_discrete_pr = None;
        let mut f_group_items = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"par" => {
                    f_par = val.parse().ok();
                }
                b"base" => {
                    f_base = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"rangePr" => {
                                f_range_pr =
                                    Some(Box::new(CTRangePr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"discretePr" => {
                                f_discrete_pr =
                                    Some(Box::new(CTDiscretePr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"groupItems" => {
                                f_group_items =
                                    Some(Box::new(GroupItems::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"rangePr" => {
                                f_range_pr = Some(Box::new(CTRangePr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"discretePr" => {
                                f_discrete_pr =
                                    Some(Box::new(CTDiscretePr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"groupItems" => {
                                f_group_items =
                                    Some(Box::new(GroupItems::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            par: f_par,
            base: f_base,
            range_pr: f_range_pr,
            discrete_pr: f_discrete_pr,
            group_items: f_group_items,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTRangePr {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_auto_start = None;
        let mut f_auto_end = None;
        let mut f_group_by = None;
        let mut f_start_num = None;
        let mut f_end_num = None;
        let mut f_start_date = None;
        let mut f_end_date = None;
        let mut f_group_interval = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"autoStart" => {
                    f_auto_start = Some(val == "true" || val == "1");
                }
                b"autoEnd" => {
                    f_auto_end = Some(val == "true" || val == "1");
                }
                b"groupBy" => {
                    f_group_by = val.parse().ok();
                }
                b"startNum" => {
                    f_start_num = val.parse().ok();
                }
                b"endNum" => {
                    f_end_num = val.parse().ok();
                }
                b"startDate" => {
                    f_start_date = Some(val.into_owned());
                }
                b"endDate" => {
                    f_end_date = Some(val.into_owned());
                }
                b"groupInterval" => {
                    f_group_interval = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            auto_start: f_auto_start,
            auto_end: f_auto_end,
            group_by: f_group_by,
            start_num: f_start_num,
            end_num: f_end_num,
            start_date: f_start_date,
            end_date: f_end_date,
            group_interval: f_group_interval,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTDiscretePr {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_x = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"x" => {
                                f_x.push(CTIndex::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"x" => {
                                f_x.push(CTIndex::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            x: f_x,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for GroupItems {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_m = None;
        let mut f_n = None;
        let mut f_b = None;
        let mut f_e = None;
        let mut f_style_index = None;
        let mut f_d = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"m" => {
                                f_m = Some(Box::new(CTMissing::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"n" => {
                                f_n = Some(Box::new(CTNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"b" => {
                                f_b = Some(Box::new(CTBoolean::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"e" => {
                                f_e = Some(Box::new(CTError::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"s" => {
                                f_style_index =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"d" => {
                                f_d = Some(Box::new(CTDateTime::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"m" => {
                                f_m = Some(Box::new(CTMissing::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"n" => {
                                f_n = Some(Box::new(CTNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"b" => {
                                f_b = Some(Box::new(CTBoolean::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"e" => {
                                f_e = Some(Box::new(CTError::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"s" => {
                                f_style_index =
                                    Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"d" => {
                                f_d = Some(Box::new(CTDateTime::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            m: f_m,
            n: f_n,
            b: f_b,
            e: f_e,
            style_index: f_style_index,
            d: f_d,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for PivotCacheRecords {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_reference = Vec::new();
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"r" => {
                                f_reference.push(CTRecord::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"r" => {
                                f_reference.push(CTRecord::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            reference: f_reference,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTRecord {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_m = None;
        let mut f_n = None;
        let mut f_b = None;
        let mut f_e = None;
        let mut f_style_index = None;
        let mut f_d = None;
        let mut f_x = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"m" => {
                                f_m = Some(Box::new(CTMissing::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"n" => {
                                f_n = Some(Box::new(CTNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"b" => {
                                f_b = Some(Box::new(CTBoolean::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"e" => {
                                f_e = Some(Box::new(CTError::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"s" => {
                                f_style_index =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"d" => {
                                f_d = Some(Box::new(CTDateTime::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"x" => {
                                f_x = Some(Box::new(CTIndex::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"m" => {
                                f_m = Some(Box::new(CTMissing::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"n" => {
                                f_n = Some(Box::new(CTNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"b" => {
                                f_b = Some(Box::new(CTBoolean::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"e" => {
                                f_e = Some(Box::new(CTError::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"s" => {
                                f_style_index =
                                    Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"d" => {
                                f_d = Some(Box::new(CTDateTime::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"x" => {
                                f_x = Some(Box::new(CTIndex::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            m: f_m,
            n: f_n,
            b: f_b,
            e: f_e,
            style_index: f_style_index,
            d: f_d,
            x: f_x,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTPCDKPIs {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_kpi = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"kpi" => {
                                f_kpi.push(CTPCDKPI::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"kpi" => {
                                f_kpi.push(CTPCDKPI::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            kpi: f_kpi,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTPCDKPI {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_unique_name: Option<XmlString> = None;
        let mut f_caption = None;
        let mut f_display_folder = None;
        let mut f_measure_group = None;
        let mut f_parent = None;
        let mut f_value: Option<XmlString> = None;
        let mut f_goal = None;
        let mut f_status = None;
        let mut f_trend = None;
        let mut f_weight = None;
        let mut f_time = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"uniqueName" => {
                    f_unique_name = Some(val.into_owned());
                }
                b"caption" => {
                    f_caption = Some(val.into_owned());
                }
                b"displayFolder" => {
                    f_display_folder = Some(val.into_owned());
                }
                b"measureGroup" => {
                    f_measure_group = Some(val.into_owned());
                }
                b"parent" => {
                    f_parent = Some(val.into_owned());
                }
                b"value" => {
                    f_value = Some(val.into_owned());
                }
                b"goal" => {
                    f_goal = Some(val.into_owned());
                }
                b"status" => {
                    f_status = Some(val.into_owned());
                }
                b"trend" => {
                    f_trend = Some(val.into_owned());
                }
                b"weight" => {
                    f_weight = Some(val.into_owned());
                }
                b"time" => {
                    f_time = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            unique_name: f_unique_name
                .ok_or_else(|| ParseError::MissingAttribute("uniqueName".to_string()))?,
            caption: f_caption,
            display_folder: f_display_folder,
            measure_group: f_measure_group,
            parent: f_parent,
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("value".to_string()))?,
            goal: f_goal,
            status: f_status,
            trend: f_trend,
            weight: f_weight,
            time: f_time,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTCacheHierarchies {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_cache_hierarchy = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"cacheHierarchy" => {
                                f_cache_hierarchy
                                    .push(CTCacheHierarchy::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"cacheHierarchy" => {
                                f_cache_hierarchy
                                    .push(CTCacheHierarchy::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            cache_hierarchy: f_cache_hierarchy,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTCacheHierarchy {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_unique_name: Option<XmlString> = None;
        let mut f_caption = None;
        let mut f_measure = None;
        let mut f_set = None;
        let mut f_parent_set = None;
        let mut f_icon_set = None;
        let mut f_attribute = None;
        let mut f_time = None;
        let mut f_key_attribute = None;
        let mut f_default_member_unique_name = None;
        let mut f_all_unique_name = None;
        let mut f_all_caption = None;
        let mut f_dimension_unique_name = None;
        let mut f_display_folder = None;
        let mut f_measure_group = None;
        let mut f_measures = None;
        let mut f_count: Option<u32> = None;
        let mut f_one_field = None;
        let mut f_member_value_datatype = None;
        let mut f_unbalanced = None;
        let mut f_unbalanced_group = None;
        let mut f_hidden = None;
        let mut f_fields_usage = None;
        let mut f_group_levels = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"uniqueName" => {
                    f_unique_name = Some(val.into_owned());
                }
                b"caption" => {
                    f_caption = Some(val.into_owned());
                }
                b"measure" => {
                    f_measure = Some(val == "true" || val == "1");
                }
                b"set" => {
                    f_set = Some(val == "true" || val == "1");
                }
                b"parentSet" => {
                    f_parent_set = val.parse().ok();
                }
                b"iconSet" => {
                    f_icon_set = val.parse().ok();
                }
                b"attribute" => {
                    f_attribute = Some(val == "true" || val == "1");
                }
                b"time" => {
                    f_time = Some(val == "true" || val == "1");
                }
                b"keyAttribute" => {
                    f_key_attribute = Some(val == "true" || val == "1");
                }
                b"defaultMemberUniqueName" => {
                    f_default_member_unique_name = Some(val.into_owned());
                }
                b"allUniqueName" => {
                    f_all_unique_name = Some(val.into_owned());
                }
                b"allCaption" => {
                    f_all_caption = Some(val.into_owned());
                }
                b"dimensionUniqueName" => {
                    f_dimension_unique_name = Some(val.into_owned());
                }
                b"displayFolder" => {
                    f_display_folder = Some(val.into_owned());
                }
                b"measureGroup" => {
                    f_measure_group = Some(val.into_owned());
                }
                b"measures" => {
                    f_measures = Some(val == "true" || val == "1");
                }
                b"count" => {
                    f_count = val.parse().ok();
                }
                b"oneField" => {
                    f_one_field = Some(val == "true" || val == "1");
                }
                b"memberValueDatatype" => {
                    f_member_value_datatype = val.parse().ok();
                }
                b"unbalanced" => {
                    f_unbalanced = Some(val == "true" || val == "1");
                }
                b"unbalancedGroup" => {
                    f_unbalanced_group = Some(val == "true" || val == "1");
                }
                b"hidden" => {
                    f_hidden = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"fieldsUsage" => {
                                f_fields_usage =
                                    Some(Box::new(CTFieldsUsage::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"groupLevels" => {
                                f_group_levels =
                                    Some(Box::new(CTGroupLevels::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"fieldsUsage" => {
                                f_fields_usage =
                                    Some(Box::new(CTFieldsUsage::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"groupLevels" => {
                                f_group_levels =
                                    Some(Box::new(CTGroupLevels::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            unique_name: f_unique_name
                .ok_or_else(|| ParseError::MissingAttribute("uniqueName".to_string()))?,
            caption: f_caption,
            measure: f_measure,
            set: f_set,
            parent_set: f_parent_set,
            icon_set: f_icon_set,
            attribute: f_attribute,
            time: f_time,
            key_attribute: f_key_attribute,
            default_member_unique_name: f_default_member_unique_name,
            all_unique_name: f_all_unique_name,
            all_caption: f_all_caption,
            dimension_unique_name: f_dimension_unique_name,
            display_folder: f_display_folder,
            measure_group: f_measure_group,
            measures: f_measures,
            count: f_count.ok_or_else(|| ParseError::MissingAttribute("count".to_string()))?,
            one_field: f_one_field,
            member_value_datatype: f_member_value_datatype,
            unbalanced: f_unbalanced,
            unbalanced_group: f_unbalanced_group,
            hidden: f_hidden,
            fields_usage: f_fields_usage,
            group_levels: f_group_levels,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTFieldsUsage {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_field_usage = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"fieldUsage" => {
                                f_field_usage.push(CTFieldUsage::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"fieldUsage" => {
                                f_field_usage.push(CTFieldUsage::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            field_usage: f_field_usage,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTFieldUsage {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_x: Option<i32> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"x" => {
                    f_x = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            x: f_x.ok_or_else(|| ParseError::MissingAttribute("x".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTGroupLevels {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_group_level = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"groupLevel" => {
                                f_group_level.push(CTGroupLevel::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"groupLevel" => {
                                f_group_level.push(CTGroupLevel::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            group_level: f_group_level,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTGroupLevel {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_unique_name: Option<XmlString> = None;
        let mut f_caption: Option<XmlString> = None;
        let mut f_user = None;
        let mut f_custom_roll_up = None;
        let mut f_groups = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"uniqueName" => {
                    f_unique_name = Some(val.into_owned());
                }
                b"caption" => {
                    f_caption = Some(val.into_owned());
                }
                b"user" => {
                    f_user = Some(val == "true" || val == "1");
                }
                b"customRollUp" => {
                    f_custom_roll_up = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"groups" => {
                                f_groups = Some(Box::new(CTGroups::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"groups" => {
                                f_groups = Some(Box::new(CTGroups::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            unique_name: f_unique_name
                .ok_or_else(|| ParseError::MissingAttribute("uniqueName".to_string()))?,
            caption: f_caption
                .ok_or_else(|| ParseError::MissingAttribute("caption".to_string()))?,
            user: f_user,
            custom_roll_up: f_custom_roll_up,
            groups: f_groups,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTGroups {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_group = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"group" => {
                                f_group.push(CTLevelGroup::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"group" => {
                                f_group.push(CTLevelGroup::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            group: f_group,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTLevelGroup {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name: Option<XmlString> = None;
        let mut f_unique_name: Option<XmlString> = None;
        let mut f_caption: Option<XmlString> = None;
        let mut f_unique_parent = None;
        let mut f_id = None;
        let mut f_group_members: Option<Box<CTGroupMembers>> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"uniqueName" => {
                    f_unique_name = Some(val.into_owned());
                }
                b"caption" => {
                    f_caption = Some(val.into_owned());
                }
                b"uniqueParent" => {
                    f_unique_parent = Some(val.into_owned());
                }
                b"id" => {
                    f_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"groupMembers" => {
                                f_group_members =
                                    Some(Box::new(CTGroupMembers::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"groupMembers" => {
                                f_group_members =
                                    Some(Box::new(CTGroupMembers::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            unique_name: f_unique_name
                .ok_or_else(|| ParseError::MissingAttribute("uniqueName".to_string()))?,
            caption: f_caption
                .ok_or_else(|| ParseError::MissingAttribute("caption".to_string()))?,
            unique_parent: f_unique_parent,
            id: f_id,
            group_members: f_group_members
                .ok_or_else(|| ParseError::MissingAttribute("groupMembers".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTGroupMembers {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_group_member = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"groupMember" => {
                                f_group_member.push(CTGroupMember::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"groupMember" => {
                                f_group_member.push(CTGroupMember::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            group_member: f_group_member,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTGroupMember {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_unique_name: Option<XmlString> = None;
        let mut f_group = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"uniqueName" => {
                    f_unique_name = Some(val.into_owned());
                }
                b"group" => {
                    f_group = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            unique_name: f_unique_name
                .ok_or_else(|| ParseError::MissingAttribute("uniqueName".to_string()))?,
            group: f_group,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTTupleCache {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_entries = None;
        let mut f_sets = None;
        let mut f_query_cache = None;
        let mut f_server_formats = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"entries" => {
                                f_entries =
                                    Some(Box::new(CTPCDSDTCEntries::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sets" => {
                                f_sets = Some(Box::new(CTSets::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"queryCache" => {
                                f_query_cache =
                                    Some(Box::new(CTQueryCache::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"serverFormats" => {
                                f_server_formats =
                                    Some(Box::new(CTServerFormats::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"entries" => {
                                f_entries =
                                    Some(Box::new(CTPCDSDTCEntries::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sets" => {
                                f_sets = Some(Box::new(CTSets::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"queryCache" => {
                                f_query_cache =
                                    Some(Box::new(CTQueryCache::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"serverFormats" => {
                                f_server_formats =
                                    Some(Box::new(CTServerFormats::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            entries: f_entries,
            sets: f_sets,
            query_cache: f_query_cache,
            server_formats: f_server_formats,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTServerFormat {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_culture = None;
        let mut f_format = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"culture" => {
                    f_culture = Some(val.into_owned());
                }
                b"format" => {
                    f_format = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            culture: f_culture,
            format: f_format,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTServerFormats {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_server_format = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"serverFormat" => {
                                f_server_format.push(CTServerFormat::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"serverFormat" => {
                                f_server_format.push(CTServerFormat::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            server_format: f_server_format,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTPCDSDTCEntries {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_m = None;
        let mut f_n = None;
        let mut f_e = None;
        let mut f_style_index = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"m" => {
                                f_m = Some(Box::new(CTMissing::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"n" => {
                                f_n = Some(Box::new(CTNumber::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"e" => {
                                f_e = Some(Box::new(CTError::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"s" => {
                                f_style_index =
                                    Some(Box::new(CTString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"m" => {
                                f_m = Some(Box::new(CTMissing::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"n" => {
                                f_n = Some(Box::new(CTNumber::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"e" => {
                                f_e = Some(Box::new(CTError::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"s" => {
                                f_style_index =
                                    Some(Box::new(CTString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            m: f_m,
            n: f_n,
            e: f_e,
            style_index: f_style_index,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTTuples {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_cells = None;
        let mut f_tpl = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"c" => {
                    f_cells = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"tpl" => {
                                f_tpl.push(CTTuple::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"tpl" => {
                                f_tpl.push(CTTuple::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            cells: f_cells,
            tpl: f_tpl,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTTuple {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_fld = None;
        let mut f_hier = None;
        let mut f_item: Option<u32> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"fld" => {
                    f_fld = val.parse().ok();
                }
                b"hier" => {
                    f_hier = val.parse().ok();
                }
                b"item" => {
                    f_item = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            fld: f_fld,
            hier: f_hier,
            item: f_item.ok_or_else(|| ParseError::MissingAttribute("item".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTSets {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_set = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"set" => {
                                f_set.push(CTSet::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"set" => {
                                f_set.push(CTSet::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            set: f_set,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTSet {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_max_rank: Option<i32> = None;
        let mut f_set_definition: Option<XmlString> = None;
        let mut f_sort_type = None;
        let mut f_query_failed = None;
        let mut f_tpls = Vec::new();
        let mut f_sort_by_tuple = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                b"maxRank" => {
                    f_max_rank = val.parse().ok();
                }
                b"setDefinition" => {
                    f_set_definition = Some(val.into_owned());
                }
                b"sortType" => {
                    f_sort_type = val.parse().ok();
                }
                b"queryFailed" => {
                    f_query_failed = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"tpls" => {
                                f_tpls.push(CTTuples::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sortByTuple" => {
                                f_sort_by_tuple =
                                    Some(Box::new(CTTuples::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"tpls" => {
                                f_tpls.push(CTTuples::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sortByTuple" => {
                                f_sort_by_tuple =
                                    Some(Box::new(CTTuples::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            max_rank: f_max_rank
                .ok_or_else(|| ParseError::MissingAttribute("maxRank".to_string()))?,
            set_definition: f_set_definition
                .ok_or_else(|| ParseError::MissingAttribute("setDefinition".to_string()))?,
            sort_type: f_sort_type,
            query_failed: f_query_failed,
            tpls: f_tpls,
            sort_by_tuple: f_sort_by_tuple,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTQueryCache {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_query = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"query" => {
                                f_query.push(CTQuery::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"query" => {
                                f_query.push(CTQuery::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            query: f_query,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTQuery {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_mdx: Option<XmlString> = None;
        let mut f_tpls = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"mdx" => {
                    f_mdx = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"tpls" => {
                                f_tpls = Some(Box::new(CTTuples::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"tpls" => {
                                f_tpls = Some(Box::new(CTTuples::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            mdx: f_mdx.ok_or_else(|| ParseError::MissingAttribute("mdx".to_string()))?,
            tpls: f_tpls,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTCalculatedItems {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_calculated_item = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"calculatedItem" => {
                                f_calculated_item
                                    .push(CTCalculatedItem::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"calculatedItem" => {
                                f_calculated_item
                                    .push(CTCalculatedItem::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            calculated_item: f_calculated_item,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTCalculatedItem {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_field = None;
        let mut f_formula = None;
        let mut f_pivot_area: Option<Box<PivotArea>> = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"field" => {
                    f_field = val.parse().ok();
                }
                b"formula" => {
                    f_formula = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"pivotArea" => {
                                f_pivot_area =
                                    Some(Box::new(PivotArea::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"pivotArea" => {
                                f_pivot_area =
                                    Some(Box::new(PivotArea::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            field: f_field,
            formula: f_formula,
            pivot_area: f_pivot_area
                .ok_or_else(|| ParseError::MissingAttribute("pivotArea".to_string()))?,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTCalculatedMembers {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_calculated_member = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"calculatedMember" => {
                                f_calculated_member
                                    .push(CTCalculatedMember::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"calculatedMember" => {
                                f_calculated_member
                                    .push(CTCalculatedMember::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            calculated_member: f_calculated_member,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTCalculatedMember {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name: Option<XmlString> = None;
        let mut f_mdx: Option<XmlString> = None;
        let mut f_member_name = None;
        let mut f_hierarchy = None;
        let mut f_parent = None;
        let mut f_solve_order = None;
        let mut f_set = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"mdx" => {
                    f_mdx = Some(val.into_owned());
                }
                b"memberName" => {
                    f_member_name = Some(val.into_owned());
                }
                b"hierarchy" => {
                    f_hierarchy = Some(val.into_owned());
                }
                b"parent" => {
                    f_parent = Some(val.into_owned());
                }
                b"solveOrder" => {
                    f_solve_order = val.parse().ok();
                }
                b"set" => {
                    f_set = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            mdx: f_mdx.ok_or_else(|| ParseError::MissingAttribute("mdx".to_string()))?,
            member_name: f_member_name,
            hierarchy: f_hierarchy,
            parent: f_parent,
            solve_order: f_solve_order,
            set: f_set,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTPivotTableDefinition {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name: Option<XmlString> = None;
        let mut f_cache_id: Option<u32> = None;
        let mut f_data_on_rows = None;
        let mut f_data_position = None;
        let mut f_auto_format_id = None;
        let mut f_apply_number_formats = None;
        let mut f_apply_border_formats = None;
        let mut f_apply_font_formats = None;
        let mut f_apply_pattern_formats = None;
        let mut f_apply_alignment_formats = None;
        let mut f_apply_width_height_formats = None;
        let mut f_data_caption: Option<XmlString> = None;
        let mut f_grand_total_caption = None;
        let mut f_error_caption = None;
        let mut f_show_error = None;
        let mut f_missing_caption = None;
        let mut f_show_missing = None;
        let mut f_page_style = None;
        let mut f_pivot_table_style = None;
        let mut f_vacated_style = None;
        let mut f_tag = None;
        let mut f_updated_version = None;
        let mut f_min_refreshable_version = None;
        let mut f_asterisk_totals = None;
        let mut f_show_items = None;
        let mut f_edit_data = None;
        let mut f_disable_field_list = None;
        let mut f_show_calc_mbrs = None;
        let mut f_visual_totals = None;
        let mut f_show_multiple_label = None;
        let mut f_show_data_drop_down = None;
        let mut f_show_drill = None;
        let mut f_print_drill = None;
        let mut f_show_member_property_tips = None;
        let mut f_show_data_tips = None;
        let mut f_enable_wizard = None;
        let mut f_enable_drill = None;
        let mut f_enable_field_properties = None;
        let mut f_preserve_formatting = None;
        let mut f_use_auto_formatting = None;
        let mut f_page_wrap = None;
        let mut f_page_over_then_down = None;
        let mut f_subtotal_hidden_items = None;
        let mut f_row_grand_totals = None;
        let mut f_col_grand_totals = None;
        let mut f_field_print_titles = None;
        let mut f_item_print_titles = None;
        let mut f_merge_item = None;
        let mut f_show_drop_zones = None;
        let mut f_created_version = None;
        let mut f_indent = None;
        let mut f_show_empty_row = None;
        let mut f_show_empty_col = None;
        let mut f_show_headers = None;
        let mut f_compact = None;
        let mut f_outline = None;
        let mut f_outline_data = None;
        let mut f_compact_data = None;
        let mut f_published = None;
        let mut f_grid_drop_zones = None;
        let mut f_immersive = None;
        let mut f_multiple_field_filters = None;
        let mut f_chart_format = None;
        let mut f_row_header_caption = None;
        let mut f_col_header_caption = None;
        let mut f_field_list_sort_ascending = None;
        let mut f_mdx_subqueries = None;
        let mut f_custom_list_sort = None;
        let mut f_location: Option<Box<PivotLocation>> = None;
        let mut f_pivot_fields = None;
        let mut f_row_fields = None;
        let mut f_row_items = None;
        let mut f_col_fields = None;
        let mut f_col_items = None;
        let mut f_page_fields = None;
        let mut f_data_fields = None;
        let mut f_formats = None;
        let mut f_conditional_formats = None;
        let mut f_chart_formats = None;
        let mut f_pivot_hierarchies = None;
        let mut f_pivot_table_style_info = None;
        let mut f_filters = None;
        let mut f_row_hierarchies_usage = None;
        let mut f_col_hierarchies_usage = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"cacheId" => {
                    f_cache_id = val.parse().ok();
                }
                b"dataOnRows" => {
                    f_data_on_rows = Some(val == "true" || val == "1");
                }
                b"dataPosition" => {
                    f_data_position = val.parse().ok();
                }
                b"autoFormatId" => {
                    f_auto_format_id = val.parse().ok();
                }
                b"applyNumberFormats" => {
                    f_apply_number_formats = Some(val == "true" || val == "1");
                }
                b"applyBorderFormats" => {
                    f_apply_border_formats = Some(val == "true" || val == "1");
                }
                b"applyFontFormats" => {
                    f_apply_font_formats = Some(val == "true" || val == "1");
                }
                b"applyPatternFormats" => {
                    f_apply_pattern_formats = Some(val == "true" || val == "1");
                }
                b"applyAlignmentFormats" => {
                    f_apply_alignment_formats = Some(val == "true" || val == "1");
                }
                b"applyWidthHeightFormats" => {
                    f_apply_width_height_formats = Some(val == "true" || val == "1");
                }
                b"dataCaption" => {
                    f_data_caption = Some(val.into_owned());
                }
                b"grandTotalCaption" => {
                    f_grand_total_caption = Some(val.into_owned());
                }
                b"errorCaption" => {
                    f_error_caption = Some(val.into_owned());
                }
                b"showError" => {
                    f_show_error = Some(val == "true" || val == "1");
                }
                b"missingCaption" => {
                    f_missing_caption = Some(val.into_owned());
                }
                b"showMissing" => {
                    f_show_missing = Some(val == "true" || val == "1");
                }
                b"pageStyle" => {
                    f_page_style = Some(val.into_owned());
                }
                b"pivotTableStyle" => {
                    f_pivot_table_style = Some(val.into_owned());
                }
                b"vacatedStyle" => {
                    f_vacated_style = Some(val.into_owned());
                }
                b"tag" => {
                    f_tag = Some(val.into_owned());
                }
                b"updatedVersion" => {
                    f_updated_version = val.parse().ok();
                }
                b"minRefreshableVersion" => {
                    f_min_refreshable_version = val.parse().ok();
                }
                b"asteriskTotals" => {
                    f_asterisk_totals = Some(val == "true" || val == "1");
                }
                b"showItems" => {
                    f_show_items = Some(val == "true" || val == "1");
                }
                b"editData" => {
                    f_edit_data = Some(val == "true" || val == "1");
                }
                b"disableFieldList" => {
                    f_disable_field_list = Some(val == "true" || val == "1");
                }
                b"showCalcMbrs" => {
                    f_show_calc_mbrs = Some(val == "true" || val == "1");
                }
                b"visualTotals" => {
                    f_visual_totals = Some(val == "true" || val == "1");
                }
                b"showMultipleLabel" => {
                    f_show_multiple_label = Some(val == "true" || val == "1");
                }
                b"showDataDropDown" => {
                    f_show_data_drop_down = Some(val == "true" || val == "1");
                }
                b"showDrill" => {
                    f_show_drill = Some(val == "true" || val == "1");
                }
                b"printDrill" => {
                    f_print_drill = Some(val == "true" || val == "1");
                }
                b"showMemberPropertyTips" => {
                    f_show_member_property_tips = Some(val == "true" || val == "1");
                }
                b"showDataTips" => {
                    f_show_data_tips = Some(val == "true" || val == "1");
                }
                b"enableWizard" => {
                    f_enable_wizard = Some(val == "true" || val == "1");
                }
                b"enableDrill" => {
                    f_enable_drill = Some(val == "true" || val == "1");
                }
                b"enableFieldProperties" => {
                    f_enable_field_properties = Some(val == "true" || val == "1");
                }
                b"preserveFormatting" => {
                    f_preserve_formatting = Some(val == "true" || val == "1");
                }
                b"useAutoFormatting" => {
                    f_use_auto_formatting = Some(val == "true" || val == "1");
                }
                b"pageWrap" => {
                    f_page_wrap = val.parse().ok();
                }
                b"pageOverThenDown" => {
                    f_page_over_then_down = Some(val == "true" || val == "1");
                }
                b"subtotalHiddenItems" => {
                    f_subtotal_hidden_items = Some(val == "true" || val == "1");
                }
                b"rowGrandTotals" => {
                    f_row_grand_totals = Some(val == "true" || val == "1");
                }
                b"colGrandTotals" => {
                    f_col_grand_totals = Some(val == "true" || val == "1");
                }
                b"fieldPrintTitles" => {
                    f_field_print_titles = Some(val == "true" || val == "1");
                }
                b"itemPrintTitles" => {
                    f_item_print_titles = Some(val == "true" || val == "1");
                }
                b"mergeItem" => {
                    f_merge_item = Some(val == "true" || val == "1");
                }
                b"showDropZones" => {
                    f_show_drop_zones = Some(val == "true" || val == "1");
                }
                b"createdVersion" => {
                    f_created_version = val.parse().ok();
                }
                b"indent" => {
                    f_indent = val.parse().ok();
                }
                b"showEmptyRow" => {
                    f_show_empty_row = Some(val == "true" || val == "1");
                }
                b"showEmptyCol" => {
                    f_show_empty_col = Some(val == "true" || val == "1");
                }
                b"showHeaders" => {
                    f_show_headers = Some(val == "true" || val == "1");
                }
                b"compact" => {
                    f_compact = Some(val == "true" || val == "1");
                }
                b"outline" => {
                    f_outline = Some(val == "true" || val == "1");
                }
                b"outlineData" => {
                    f_outline_data = Some(val == "true" || val == "1");
                }
                b"compactData" => {
                    f_compact_data = Some(val == "true" || val == "1");
                }
                b"published" => {
                    f_published = Some(val == "true" || val == "1");
                }
                b"gridDropZones" => {
                    f_grid_drop_zones = Some(val == "true" || val == "1");
                }
                b"immersive" => {
                    f_immersive = Some(val == "true" || val == "1");
                }
                b"multipleFieldFilters" => {
                    f_multiple_field_filters = Some(val == "true" || val == "1");
                }
                b"chartFormat" => {
                    f_chart_format = val.parse().ok();
                }
                b"rowHeaderCaption" => {
                    f_row_header_caption = Some(val.into_owned());
                }
                b"colHeaderCaption" => {
                    f_col_header_caption = Some(val.into_owned());
                }
                b"fieldListSortAscending" => {
                    f_field_list_sort_ascending = Some(val == "true" || val == "1");
                }
                b"mdxSubqueries" => {
                    f_mdx_subqueries = Some(val == "true" || val == "1");
                }
                b"customListSort" => {
                    f_custom_list_sort = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"location" => {
                                f_location =
                                    Some(Box::new(PivotLocation::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pivotFields" => {
                                f_pivot_fields =
                                    Some(Box::new(PivotFields::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rowFields" => {
                                f_row_fields =
                                    Some(Box::new(RowFields::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rowItems" => {
                                f_row_items =
                                    Some(Box::new(CTRowItems::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"colFields" => {
                                f_col_fields =
                                    Some(Box::new(ColFields::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"colItems" => {
                                f_col_items =
                                    Some(Box::new(CTColItems::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pageFields" => {
                                f_page_fields =
                                    Some(Box::new(PageFields::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dataFields" => {
                                f_data_fields =
                                    Some(Box::new(DataFields::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"formats" => {
                                f_formats = Some(Box::new(CTFormats::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"conditionalFormats" => {
                                f_conditional_formats = Some(Box::new(
                                    CTConditionalFormats::from_xml(reader, &e, false)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"chartFormats" => {
                                f_chart_formats =
                                    Some(Box::new(CTChartFormats::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pivotHierarchies" => {
                                f_pivot_hierarchies = Some(Box::new(CTPivotHierarchies::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pivotTableStyleInfo" => {
                                f_pivot_table_style_info =
                                    Some(Box::new(CTPivotTableStyle::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"filters" => {
                                f_filters =
                                    Some(Box::new(PivotFilters::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rowHierarchiesUsage" => {
                                f_row_hierarchies_usage = Some(Box::new(
                                    CTRowHierarchiesUsage::from_xml(reader, &e, false)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"colHierarchiesUsage" => {
                                f_col_hierarchies_usage = Some(Box::new(
                                    CTColHierarchiesUsage::from_xml(reader, &e, false)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"location" => {
                                f_location =
                                    Some(Box::new(PivotLocation::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pivotFields" => {
                                f_pivot_fields =
                                    Some(Box::new(PivotFields::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rowFields" => {
                                f_row_fields =
                                    Some(Box::new(RowFields::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rowItems" => {
                                f_row_items =
                                    Some(Box::new(CTRowItems::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"colFields" => {
                                f_col_fields =
                                    Some(Box::new(ColFields::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"colItems" => {
                                f_col_items =
                                    Some(Box::new(CTColItems::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pageFields" => {
                                f_page_fields =
                                    Some(Box::new(PageFields::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dataFields" => {
                                f_data_fields =
                                    Some(Box::new(DataFields::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"formats" => {
                                f_formats = Some(Box::new(CTFormats::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"conditionalFormats" => {
                                f_conditional_formats = Some(Box::new(
                                    CTConditionalFormats::from_xml(reader, &e, true)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"chartFormats" => {
                                f_chart_formats =
                                    Some(Box::new(CTChartFormats::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pivotHierarchies" => {
                                f_pivot_hierarchies =
                                    Some(Box::new(CTPivotHierarchies::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pivotTableStyleInfo" => {
                                f_pivot_table_style_info =
                                    Some(Box::new(CTPivotTableStyle::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"filters" => {
                                f_filters =
                                    Some(Box::new(PivotFilters::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rowHierarchiesUsage" => {
                                f_row_hierarchies_usage = Some(Box::new(
                                    CTRowHierarchiesUsage::from_xml(reader, &e, true)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"colHierarchiesUsage" => {
                                f_col_hierarchies_usage = Some(Box::new(
                                    CTColHierarchiesUsage::from_xml(reader, &e, true)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            cache_id: f_cache_id
                .ok_or_else(|| ParseError::MissingAttribute("cacheId".to_string()))?,
            data_on_rows: f_data_on_rows,
            data_position: f_data_position,
            auto_format_id: f_auto_format_id,
            apply_number_formats: f_apply_number_formats,
            apply_border_formats: f_apply_border_formats,
            apply_font_formats: f_apply_font_formats,
            apply_pattern_formats: f_apply_pattern_formats,
            apply_alignment_formats: f_apply_alignment_formats,
            apply_width_height_formats: f_apply_width_height_formats,
            data_caption: f_data_caption
                .ok_or_else(|| ParseError::MissingAttribute("dataCaption".to_string()))?,
            grand_total_caption: f_grand_total_caption,
            error_caption: f_error_caption,
            show_error: f_show_error,
            missing_caption: f_missing_caption,
            show_missing: f_show_missing,
            page_style: f_page_style,
            pivot_table_style: f_pivot_table_style,
            vacated_style: f_vacated_style,
            tag: f_tag,
            updated_version: f_updated_version,
            min_refreshable_version: f_min_refreshable_version,
            asterisk_totals: f_asterisk_totals,
            show_items: f_show_items,
            edit_data: f_edit_data,
            disable_field_list: f_disable_field_list,
            show_calc_mbrs: f_show_calc_mbrs,
            visual_totals: f_visual_totals,
            show_multiple_label: f_show_multiple_label,
            show_data_drop_down: f_show_data_drop_down,
            show_drill: f_show_drill,
            print_drill: f_print_drill,
            show_member_property_tips: f_show_member_property_tips,
            show_data_tips: f_show_data_tips,
            enable_wizard: f_enable_wizard,
            enable_drill: f_enable_drill,
            enable_field_properties: f_enable_field_properties,
            preserve_formatting: f_preserve_formatting,
            use_auto_formatting: f_use_auto_formatting,
            page_wrap: f_page_wrap,
            page_over_then_down: f_page_over_then_down,
            subtotal_hidden_items: f_subtotal_hidden_items,
            row_grand_totals: f_row_grand_totals,
            col_grand_totals: f_col_grand_totals,
            field_print_titles: f_field_print_titles,
            item_print_titles: f_item_print_titles,
            merge_item: f_merge_item,
            show_drop_zones: f_show_drop_zones,
            created_version: f_created_version,
            indent: f_indent,
            show_empty_row: f_show_empty_row,
            show_empty_col: f_show_empty_col,
            show_headers: f_show_headers,
            compact: f_compact,
            outline: f_outline,
            outline_data: f_outline_data,
            compact_data: f_compact_data,
            published: f_published,
            grid_drop_zones: f_grid_drop_zones,
            immersive: f_immersive,
            multiple_field_filters: f_multiple_field_filters,
            chart_format: f_chart_format,
            row_header_caption: f_row_header_caption,
            col_header_caption: f_col_header_caption,
            field_list_sort_ascending: f_field_list_sort_ascending,
            mdx_subqueries: f_mdx_subqueries,
            custom_list_sort: f_custom_list_sort,
            location: f_location
                .ok_or_else(|| ParseError::MissingAttribute("location".to_string()))?,
            pivot_fields: f_pivot_fields,
            row_fields: f_row_fields,
            row_items: f_row_items,
            col_fields: f_col_fields,
            col_items: f_col_items,
            page_fields: f_page_fields,
            data_fields: f_data_fields,
            formats: f_formats,
            conditional_formats: f_conditional_formats,
            chart_formats: f_chart_formats,
            pivot_hierarchies: f_pivot_hierarchies,
            pivot_table_style_info: f_pivot_table_style_info,
            filters: f_filters,
            row_hierarchies_usage: f_row_hierarchies_usage,
            col_hierarchies_usage: f_col_hierarchies_usage,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for PivotLocation {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_reference: Option<Reference> = None;
        let mut f_first_header_row: Option<u32> = None;
        let mut f_first_data_row: Option<u32> = None;
        let mut f_first_data_col: Option<u32> = None;
        let mut f_row_page_count = None;
        let mut f_col_page_count = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"ref" => {
                    f_reference = Some(val.into_owned());
                }
                b"firstHeaderRow" => {
                    f_first_header_row = val.parse().ok();
                }
                b"firstDataRow" => {
                    f_first_data_row = val.parse().ok();
                }
                b"firstDataCol" => {
                    f_first_data_col = val.parse().ok();
                }
                b"rowPageCount" => {
                    f_row_page_count = val.parse().ok();
                }
                b"colPageCount" => {
                    f_col_page_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            reference: f_reference
                .ok_or_else(|| ParseError::MissingAttribute("ref".to_string()))?,
            first_header_row: f_first_header_row
                .ok_or_else(|| ParseError::MissingAttribute("firstHeaderRow".to_string()))?,
            first_data_row: f_first_data_row
                .ok_or_else(|| ParseError::MissingAttribute("firstDataRow".to_string()))?,
            first_data_col: f_first_data_col
                .ok_or_else(|| ParseError::MissingAttribute("firstDataCol".to_string()))?,
            row_page_count: f_row_page_count,
            col_page_count: f_col_page_count,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for PivotFields {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_pivot_field = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"pivotField" => {
                                f_pivot_field.push(PivotField::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"pivotField" => {
                                f_pivot_field.push(PivotField::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            pivot_field: f_pivot_field,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for PivotField {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name = None;
        let mut f_axis = None;
        let mut f_data_field = None;
        let mut f_subtotal_caption = None;
        let mut f_show_drop_downs = None;
        let mut f_hidden_level = None;
        let mut f_unique_member_property = None;
        let mut f_compact = None;
        let mut f_all_drilled = None;
        let mut f_number_format_id = None;
        let mut f_outline = None;
        let mut f_subtotal_top = None;
        let mut f_drag_to_row = None;
        let mut f_drag_to_col = None;
        let mut f_multiple_item_selection_allowed = None;
        let mut f_drag_to_page = None;
        let mut f_drag_to_data = None;
        let mut f_drag_off = None;
        let mut f_show_all = None;
        let mut f_insert_blank_row = None;
        let mut f_server_field = None;
        let mut f_insert_page_break = None;
        let mut f_auto_show = None;
        let mut f_top_auto_show = None;
        let mut f_hide_new_items = None;
        let mut f_measure_filter = None;
        let mut f_include_new_items_in_filter = None;
        let mut f_item_page_count = None;
        let mut f_sort_type = None;
        let mut f_data_source_sort = None;
        let mut f_non_auto_sort_default = None;
        let mut f_rank_by = None;
        let mut f_default_subtotal = None;
        let mut f_sum_subtotal = None;
        let mut f_count_a_subtotal = None;
        let mut f_avg_subtotal = None;
        let mut f_max_subtotal = None;
        let mut f_min_subtotal = None;
        let mut f_product_subtotal = None;
        let mut f_count_subtotal = None;
        let mut f_std_dev_subtotal = None;
        let mut f_std_dev_p_subtotal = None;
        let mut f_var_subtotal = None;
        let mut f_var_p_subtotal = None;
        let mut f_show_prop_cell = None;
        let mut f_show_prop_tip = None;
        let mut f_show_prop_as_caption = None;
        let mut f_default_attribute_drill_state = None;
        let mut f_items = None;
        let mut f_auto_sort_scope = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"axis" => {
                    f_axis = val.parse().ok();
                }
                b"dataField" => {
                    f_data_field = Some(val == "true" || val == "1");
                }
                b"subtotalCaption" => {
                    f_subtotal_caption = Some(val.into_owned());
                }
                b"showDropDowns" => {
                    f_show_drop_downs = Some(val == "true" || val == "1");
                }
                b"hiddenLevel" => {
                    f_hidden_level = Some(val == "true" || val == "1");
                }
                b"uniqueMemberProperty" => {
                    f_unique_member_property = Some(val.into_owned());
                }
                b"compact" => {
                    f_compact = Some(val == "true" || val == "1");
                }
                b"allDrilled" => {
                    f_all_drilled = Some(val == "true" || val == "1");
                }
                b"numFmtId" => {
                    f_number_format_id = val.parse().ok();
                }
                b"outline" => {
                    f_outline = Some(val == "true" || val == "1");
                }
                b"subtotalTop" => {
                    f_subtotal_top = Some(val == "true" || val == "1");
                }
                b"dragToRow" => {
                    f_drag_to_row = Some(val == "true" || val == "1");
                }
                b"dragToCol" => {
                    f_drag_to_col = Some(val == "true" || val == "1");
                }
                b"multipleItemSelectionAllowed" => {
                    f_multiple_item_selection_allowed = Some(val == "true" || val == "1");
                }
                b"dragToPage" => {
                    f_drag_to_page = Some(val == "true" || val == "1");
                }
                b"dragToData" => {
                    f_drag_to_data = Some(val == "true" || val == "1");
                }
                b"dragOff" => {
                    f_drag_off = Some(val == "true" || val == "1");
                }
                b"showAll" => {
                    f_show_all = Some(val == "true" || val == "1");
                }
                b"insertBlankRow" => {
                    f_insert_blank_row = Some(val == "true" || val == "1");
                }
                b"serverField" => {
                    f_server_field = Some(val == "true" || val == "1");
                }
                b"insertPageBreak" => {
                    f_insert_page_break = Some(val == "true" || val == "1");
                }
                b"autoShow" => {
                    f_auto_show = Some(val == "true" || val == "1");
                }
                b"topAutoShow" => {
                    f_top_auto_show = Some(val == "true" || val == "1");
                }
                b"hideNewItems" => {
                    f_hide_new_items = Some(val == "true" || val == "1");
                }
                b"measureFilter" => {
                    f_measure_filter = Some(val == "true" || val == "1");
                }
                b"includeNewItemsInFilter" => {
                    f_include_new_items_in_filter = Some(val == "true" || val == "1");
                }
                b"itemPageCount" => {
                    f_item_page_count = val.parse().ok();
                }
                b"sortType" => {
                    f_sort_type = val.parse().ok();
                }
                b"dataSourceSort" => {
                    f_data_source_sort = Some(val == "true" || val == "1");
                }
                b"nonAutoSortDefault" => {
                    f_non_auto_sort_default = Some(val == "true" || val == "1");
                }
                b"rankBy" => {
                    f_rank_by = val.parse().ok();
                }
                b"defaultSubtotal" => {
                    f_default_subtotal = Some(val == "true" || val == "1");
                }
                b"sumSubtotal" => {
                    f_sum_subtotal = Some(val == "true" || val == "1");
                }
                b"countASubtotal" => {
                    f_count_a_subtotal = Some(val == "true" || val == "1");
                }
                b"avgSubtotal" => {
                    f_avg_subtotal = Some(val == "true" || val == "1");
                }
                b"maxSubtotal" => {
                    f_max_subtotal = Some(val == "true" || val == "1");
                }
                b"minSubtotal" => {
                    f_min_subtotal = Some(val == "true" || val == "1");
                }
                b"productSubtotal" => {
                    f_product_subtotal = Some(val == "true" || val == "1");
                }
                b"countSubtotal" => {
                    f_count_subtotal = Some(val == "true" || val == "1");
                }
                b"stdDevSubtotal" => {
                    f_std_dev_subtotal = Some(val == "true" || val == "1");
                }
                b"stdDevPSubtotal" => {
                    f_std_dev_p_subtotal = Some(val == "true" || val == "1");
                }
                b"varSubtotal" => {
                    f_var_subtotal = Some(val == "true" || val == "1");
                }
                b"varPSubtotal" => {
                    f_var_p_subtotal = Some(val == "true" || val == "1");
                }
                b"showPropCell" => {
                    f_show_prop_cell = Some(val == "true" || val == "1");
                }
                b"showPropTip" => {
                    f_show_prop_tip = Some(val == "true" || val == "1");
                }
                b"showPropAsCaption" => {
                    f_show_prop_as_caption = Some(val == "true" || val == "1");
                }
                b"defaultAttributeDrillState" => {
                    f_default_attribute_drill_state = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"items" => {
                                f_items = Some(Box::new(PivotItems::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"autoSortScope" => {
                                f_auto_sort_scope =
                                    Some(Box::new(PivotArea::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"items" => {
                                f_items = Some(Box::new(PivotItems::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"autoSortScope" => {
                                f_auto_sort_scope =
                                    Some(Box::new(PivotArea::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name,
            axis: f_axis,
            data_field: f_data_field,
            subtotal_caption: f_subtotal_caption,
            show_drop_downs: f_show_drop_downs,
            hidden_level: f_hidden_level,
            unique_member_property: f_unique_member_property,
            compact: f_compact,
            all_drilled: f_all_drilled,
            number_format_id: f_number_format_id,
            outline: f_outline,
            subtotal_top: f_subtotal_top,
            drag_to_row: f_drag_to_row,
            drag_to_col: f_drag_to_col,
            multiple_item_selection_allowed: f_multiple_item_selection_allowed,
            drag_to_page: f_drag_to_page,
            drag_to_data: f_drag_to_data,
            drag_off: f_drag_off,
            show_all: f_show_all,
            insert_blank_row: f_insert_blank_row,
            server_field: f_server_field,
            insert_page_break: f_insert_page_break,
            auto_show: f_auto_show,
            top_auto_show: f_top_auto_show,
            hide_new_items: f_hide_new_items,
            measure_filter: f_measure_filter,
            include_new_items_in_filter: f_include_new_items_in_filter,
            item_page_count: f_item_page_count,
            sort_type: f_sort_type,
            data_source_sort: f_data_source_sort,
            non_auto_sort_default: f_non_auto_sort_default,
            rank_by: f_rank_by,
            default_subtotal: f_default_subtotal,
            sum_subtotal: f_sum_subtotal,
            count_a_subtotal: f_count_a_subtotal,
            avg_subtotal: f_avg_subtotal,
            max_subtotal: f_max_subtotal,
            min_subtotal: f_min_subtotal,
            product_subtotal: f_product_subtotal,
            count_subtotal: f_count_subtotal,
            std_dev_subtotal: f_std_dev_subtotal,
            std_dev_p_subtotal: f_std_dev_p_subtotal,
            var_subtotal: f_var_subtotal,
            var_p_subtotal: f_var_p_subtotal,
            show_prop_cell: f_show_prop_cell,
            show_prop_tip: f_show_prop_tip,
            show_prop_as_caption: f_show_prop_as_caption,
            default_attribute_drill_state: f_default_attribute_drill_state,
            items: f_items,
            auto_sort_scope: f_auto_sort_scope,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for PivotItems {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_item = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"item" => {
                                f_item.push(PivotItem::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"item" => {
                                f_item.push(PivotItem::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            item: f_item,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for PivotItem {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_n = None;
        let mut f_cell_type = None;
        let mut f_height = None;
        let mut f_style_index = None;
        let mut f_sd = None;
        let mut f_formula = None;
        let mut f_m = None;
        let mut f_cells = None;
        let mut f_x = None;
        let mut f_d = None;
        let mut f_e = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"n" => {
                    f_n = Some(val.into_owned());
                }
                b"t" => {
                    f_cell_type = val.parse().ok();
                }
                b"h" => {
                    f_height = Some(val == "true" || val == "1");
                }
                b"s" => {
                    f_style_index = Some(val == "true" || val == "1");
                }
                b"sd" => {
                    f_sd = Some(val == "true" || val == "1");
                }
                b"f" => {
                    f_formula = Some(val == "true" || val == "1");
                }
                b"m" => {
                    f_m = Some(val == "true" || val == "1");
                }
                b"c" => {
                    f_cells = Some(val == "true" || val == "1");
                }
                b"x" => {
                    f_x = val.parse().ok();
                }
                b"d" => {
                    f_d = Some(val == "true" || val == "1");
                }
                b"e" => {
                    f_e = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            n: f_n,
            cell_type: f_cell_type,
            height: f_height,
            style_index: f_style_index,
            sd: f_sd,
            formula: f_formula,
            m: f_m,
            cells: f_cells,
            x: f_x,
            d: f_d,
            e: f_e,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for PageFields {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_page_field = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"pageField" => {
                                f_page_field.push(PageField::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"pageField" => {
                                f_page_field.push(PageField::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            page_field: f_page_field,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for PageField {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_fld: Option<i32> = None;
        let mut f_item = None;
        let mut f_hier = None;
        let mut f_name = None;
        let mut f_cap = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"fld" => {
                    f_fld = val.parse().ok();
                }
                b"item" => {
                    f_item = val.parse().ok();
                }
                b"hier" => {
                    f_hier = val.parse().ok();
                }
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"cap" => {
                    f_cap = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            fld: f_fld.ok_or_else(|| ParseError::MissingAttribute("fld".to_string()))?,
            item: f_item,
            hier: f_hier,
            name: f_name,
            cap: f_cap,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for DataFields {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_data_field = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"dataField" => {
                                f_data_field.push(DataField::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"dataField" => {
                                f_data_field.push(DataField::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            data_field: f_data_field,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for DataField {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name = None;
        let mut f_fld: Option<u32> = None;
        let mut f_subtotal = None;
        let mut f_show_data_as = None;
        let mut f_base_field = None;
        let mut f_base_item = None;
        let mut f_number_format_id = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"fld" => {
                    f_fld = val.parse().ok();
                }
                b"subtotal" => {
                    f_subtotal = val.parse().ok();
                }
                b"showDataAs" => {
                    f_show_data_as = val.parse().ok();
                }
                b"baseField" => {
                    f_base_field = val.parse().ok();
                }
                b"baseItem" => {
                    f_base_item = val.parse().ok();
                }
                b"numFmtId" => {
                    f_number_format_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name,
            fld: f_fld.ok_or_else(|| ParseError::MissingAttribute("fld".to_string()))?,
            subtotal: f_subtotal,
            show_data_as: f_show_data_as,
            base_field: f_base_field,
            base_item: f_base_item,
            number_format_id: f_number_format_id,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTRowItems {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_i = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"i" => {
                                f_i.push(CTI::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"i" => {
                                f_i.push(CTI::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            i: f_i,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTColItems {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_i = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"i" => {
                                f_i.push(CTI::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"i" => {
                                f_i.push(CTI::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            i: f_i,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTI {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_cell_type = None;
        let mut f_reference = None;
        let mut f_i = None;
        let mut f_x = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"t" => {
                    f_cell_type = val.parse().ok();
                }
                b"r" => {
                    f_reference = val.parse().ok();
                }
                b"i" => {
                    f_i = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"x" => {
                                f_x.push(CTX::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"x" => {
                                f_x.push(CTX::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            cell_type: f_cell_type,
            reference: f_reference,
            i: f_i,
            x: f_x,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTX {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"v" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for RowFields {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_field = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"field" => {
                                f_field.push(CTField::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"field" => {
                                f_field.push(CTField::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            field: f_field,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for ColFields {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_field = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"field" => {
                                f_field.push(CTField::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"field" => {
                                f_field.push(CTField::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            field: f_field,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTField {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_x: Option<i32> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"x" => {
                    f_x = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            x: f_x.ok_or_else(|| ParseError::MissingAttribute("x".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTFormats {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_format = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"format" => {
                                f_format.push(CTFormat::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"format" => {
                                f_format.push(CTFormat::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            format: f_format,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTFormat {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_action = None;
        let mut f_dxf_id = None;
        let mut f_pivot_area: Option<Box<PivotArea>> = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"action" => {
                    f_action = val.parse().ok();
                }
                b"dxfId" => {
                    f_dxf_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"pivotArea" => {
                                f_pivot_area =
                                    Some(Box::new(PivotArea::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"pivotArea" => {
                                f_pivot_area =
                                    Some(Box::new(PivotArea::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            action: f_action,
            dxf_id: f_dxf_id,
            pivot_area: f_pivot_area
                .ok_or_else(|| ParseError::MissingAttribute("pivotArea".to_string()))?,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTConditionalFormats {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_conditional_format = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"conditionalFormat" => {
                                f_conditional_format
                                    .push(CTConditionalFormat::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"conditionalFormat" => {
                                f_conditional_format
                                    .push(CTConditionalFormat::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            conditional_format: f_conditional_format,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTConditionalFormat {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_scope = None;
        let mut f_type = None;
        let mut f_priority: Option<u32> = None;
        let mut f_pivot_areas: Option<Box<PivotAreas>> = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"scope" => {
                    f_scope = val.parse().ok();
                }
                b"type" => {
                    f_type = val.parse().ok();
                }
                b"priority" => {
                    f_priority = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"pivotAreas" => {
                                f_pivot_areas =
                                    Some(Box::new(PivotAreas::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"pivotAreas" => {
                                f_pivot_areas =
                                    Some(Box::new(PivotAreas::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            scope: f_scope,
            r#type: f_type,
            priority: f_priority
                .ok_or_else(|| ParseError::MissingAttribute("priority".to_string()))?,
            pivot_areas: f_pivot_areas
                .ok_or_else(|| ParseError::MissingAttribute("pivotAreas".to_string()))?,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for PivotAreas {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_pivot_area = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"pivotArea" => {
                                f_pivot_area.push(PivotArea::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"pivotArea" => {
                                f_pivot_area.push(PivotArea::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            pivot_area: f_pivot_area,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTChartFormats {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_chart_format = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"chartFormat" => {
                                f_chart_format.push(CTChartFormat::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"chartFormat" => {
                                f_chart_format.push(CTChartFormat::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            chart_format: f_chart_format,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTChartFormat {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_chart: Option<u32> = None;
        let mut f_format: Option<u32> = None;
        let mut f_series = None;
        let mut f_pivot_area: Option<Box<PivotArea>> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"chart" => {
                    f_chart = val.parse().ok();
                }
                b"format" => {
                    f_format = val.parse().ok();
                }
                b"series" => {
                    f_series = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"pivotArea" => {
                                f_pivot_area =
                                    Some(Box::new(PivotArea::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"pivotArea" => {
                                f_pivot_area =
                                    Some(Box::new(PivotArea::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            chart: f_chart.ok_or_else(|| ParseError::MissingAttribute("chart".to_string()))?,
            format: f_format.ok_or_else(|| ParseError::MissingAttribute("format".to_string()))?,
            series: f_series,
            pivot_area: f_pivot_area
                .ok_or_else(|| ParseError::MissingAttribute("pivotArea".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTPivotHierarchies {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_pivot_hierarchy = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"pivotHierarchy" => {
                                f_pivot_hierarchy
                                    .push(CTPivotHierarchy::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"pivotHierarchy" => {
                                f_pivot_hierarchy
                                    .push(CTPivotHierarchy::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            pivot_hierarchy: f_pivot_hierarchy,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTPivotHierarchy {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_outline = None;
        let mut f_multiple_item_selection_allowed = None;
        let mut f_subtotal_top = None;
        let mut f_show_in_field_list = None;
        let mut f_drag_to_row = None;
        let mut f_drag_to_col = None;
        let mut f_drag_to_page = None;
        let mut f_drag_to_data = None;
        let mut f_drag_off = None;
        let mut f_include_new_items_in_filter = None;
        let mut f_caption = None;
        let mut f_mps = None;
        let mut f_members = Vec::new();
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"outline" => {
                    f_outline = Some(val == "true" || val == "1");
                }
                b"multipleItemSelectionAllowed" => {
                    f_multiple_item_selection_allowed = Some(val == "true" || val == "1");
                }
                b"subtotalTop" => {
                    f_subtotal_top = Some(val == "true" || val == "1");
                }
                b"showInFieldList" => {
                    f_show_in_field_list = Some(val == "true" || val == "1");
                }
                b"dragToRow" => {
                    f_drag_to_row = Some(val == "true" || val == "1");
                }
                b"dragToCol" => {
                    f_drag_to_col = Some(val == "true" || val == "1");
                }
                b"dragToPage" => {
                    f_drag_to_page = Some(val == "true" || val == "1");
                }
                b"dragToData" => {
                    f_drag_to_data = Some(val == "true" || val == "1");
                }
                b"dragOff" => {
                    f_drag_off = Some(val == "true" || val == "1");
                }
                b"includeNewItemsInFilter" => {
                    f_include_new_items_in_filter = Some(val == "true" || val == "1");
                }
                b"caption" => {
                    f_caption = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"mps" => {
                                f_mps = Some(Box::new(CTMemberProperties::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"members" => {
                                f_members.push(CTMembers::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"mps" => {
                                f_mps =
                                    Some(Box::new(CTMemberProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"members" => {
                                f_members.push(CTMembers::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            outline: f_outline,
            multiple_item_selection_allowed: f_multiple_item_selection_allowed,
            subtotal_top: f_subtotal_top,
            show_in_field_list: f_show_in_field_list,
            drag_to_row: f_drag_to_row,
            drag_to_col: f_drag_to_col,
            drag_to_page: f_drag_to_page,
            drag_to_data: f_drag_to_data,
            drag_off: f_drag_off,
            include_new_items_in_filter: f_include_new_items_in_filter,
            caption: f_caption,
            mps: f_mps,
            members: f_members,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTRowHierarchiesUsage {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_row_hierarchy_usage = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"rowHierarchyUsage" => {
                                f_row_hierarchy_usage
                                    .push(CTHierarchyUsage::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"rowHierarchyUsage" => {
                                f_row_hierarchy_usage
                                    .push(CTHierarchyUsage::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            row_hierarchy_usage: f_row_hierarchy_usage,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTColHierarchiesUsage {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_col_hierarchy_usage = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"colHierarchyUsage" => {
                                f_col_hierarchy_usage
                                    .push(CTHierarchyUsage::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"colHierarchyUsage" => {
                                f_col_hierarchy_usage
                                    .push(CTHierarchyUsage::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            col_hierarchy_usage: f_col_hierarchy_usage,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTHierarchyUsage {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_hierarchy_usage: Option<i32> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"hierarchyUsage" => {
                    f_hierarchy_usage = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            hierarchy_usage: f_hierarchy_usage
                .ok_or_else(|| ParseError::MissingAttribute("hierarchyUsage".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTMemberProperties {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_mp = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"mp" => {
                                f_mp.push(CTMemberProperty::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"mp" => {
                                f_mp.push(CTMemberProperty::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            mp: f_mp,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTMemberProperty {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name = None;
        let mut f_show_cell = None;
        let mut f_show_tip = None;
        let mut f_show_as_caption = None;
        let mut f_name_len = None;
        let mut f_p_pos = None;
        let mut f_p_len = None;
        let mut f_level = None;
        let mut f_field: Option<u32> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"showCell" => {
                    f_show_cell = Some(val == "true" || val == "1");
                }
                b"showTip" => {
                    f_show_tip = Some(val == "true" || val == "1");
                }
                b"showAsCaption" => {
                    f_show_as_caption = Some(val == "true" || val == "1");
                }
                b"nameLen" => {
                    f_name_len = val.parse().ok();
                }
                b"pPos" => {
                    f_p_pos = val.parse().ok();
                }
                b"pLen" => {
                    f_p_len = val.parse().ok();
                }
                b"level" => {
                    f_level = val.parse().ok();
                }
                b"field" => {
                    f_field = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name,
            show_cell: f_show_cell,
            show_tip: f_show_tip,
            show_as_caption: f_show_as_caption,
            name_len: f_name_len,
            p_pos: f_p_pos,
            p_len: f_p_len,
            level: f_level,
            field: f_field.ok_or_else(|| ParseError::MissingAttribute("field".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTMembers {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_level = None;
        let mut f_member = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                b"level" => {
                    f_level = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"member" => {
                                f_member.push(CTMember::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"member" => {
                                f_member.push(CTMember::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            level: f_level,
            member: f_member,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTMember {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name: Option<XmlString> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTDimensions {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_dimension = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"dimension" => {
                                f_dimension.push(CTPivotDimension::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"dimension" => {
                                f_dimension.push(CTPivotDimension::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            dimension: f_dimension,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTPivotDimension {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_measure = None;
        let mut f_name: Option<XmlString> = None;
        let mut f_unique_name: Option<XmlString> = None;
        let mut f_caption: Option<XmlString> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"measure" => {
                    f_measure = Some(val == "true" || val == "1");
                }
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"uniqueName" => {
                    f_unique_name = Some(val.into_owned());
                }
                b"caption" => {
                    f_caption = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            measure: f_measure,
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            unique_name: f_unique_name
                .ok_or_else(|| ParseError::MissingAttribute("uniqueName".to_string()))?,
            caption: f_caption
                .ok_or_else(|| ParseError::MissingAttribute("caption".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTMeasureGroups {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_measure_group = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"measureGroup" => {
                                f_measure_group.push(CTMeasureGroup::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"measureGroup" => {
                                f_measure_group.push(CTMeasureGroup::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            measure_group: f_measure_group,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTMeasureDimensionMaps {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_map = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"map" => {
                                f_map.push(CTMeasureDimensionMap::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"map" => {
                                f_map.push(CTMeasureDimensionMap::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            map: f_map,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTMeasureGroup {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name: Option<XmlString> = None;
        let mut f_caption: Option<XmlString> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"caption" => {
                    f_caption = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            caption: f_caption
                .ok_or_else(|| ParseError::MissingAttribute("caption".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTMeasureDimensionMap {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_measure_group = None;
        let mut f_dimension = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"measureGroup" => {
                    f_measure_group = val.parse().ok();
                }
                b"dimension" => {
                    f_dimension = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            measure_group: f_measure_group,
            dimension: f_dimension,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTPivotTableStyle {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name = None;
        let mut f_show_row_headers = None;
        let mut f_show_col_headers = None;
        let mut f_show_row_stripes = None;
        let mut f_show_col_stripes = None;
        let mut f_show_last_column = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"showRowHeaders" => {
                    f_show_row_headers = Some(val == "true" || val == "1");
                }
                b"showColHeaders" => {
                    f_show_col_headers = Some(val == "true" || val == "1");
                }
                b"showRowStripes" => {
                    f_show_row_stripes = Some(val == "true" || val == "1");
                }
                b"showColStripes" => {
                    f_show_col_stripes = Some(val == "true" || val == "1");
                }
                b"showLastColumn" => {
                    f_show_last_column = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name,
            show_row_headers: f_show_row_headers,
            show_col_headers: f_show_col_headers,
            show_row_stripes: f_show_row_stripes,
            show_col_stripes: f_show_col_stripes,
            show_last_column: f_show_last_column,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for PivotFilters {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_filter = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"filter" => {
                                f_filter.push(PivotFilter::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"filter" => {
                                f_filter.push(PivotFilter::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            filter: f_filter,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for PivotFilter {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_fld: Option<u32> = None;
        let mut f_mp_fld = None;
        let mut f_type: Option<STPivotFilterType> = None;
        let mut f_eval_order = None;
        let mut f_id: Option<u32> = None;
        let mut f_i_measure_hier = None;
        let mut f_i_measure_fld = None;
        let mut f_name = None;
        let mut f_description = None;
        let mut f_string_value1 = None;
        let mut f_string_value2 = None;
        let mut f_auto_filter: Option<Box<AutoFilter>> = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"fld" => {
                    f_fld = val.parse().ok();
                }
                b"mpFld" => {
                    f_mp_fld = val.parse().ok();
                }
                b"type" => {
                    f_type = val.parse().ok();
                }
                b"evalOrder" => {
                    f_eval_order = val.parse().ok();
                }
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"iMeasureHier" => {
                    f_i_measure_hier = val.parse().ok();
                }
                b"iMeasureFld" => {
                    f_i_measure_fld = val.parse().ok();
                }
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"description" => {
                    f_description = Some(val.into_owned());
                }
                b"stringValue1" => {
                    f_string_value1 = Some(val.into_owned());
                }
                b"stringValue2" => {
                    f_string_value2 = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"autoFilter" => {
                                f_auto_filter =
                                    Some(Box::new(AutoFilter::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"autoFilter" => {
                                f_auto_filter =
                                    Some(Box::new(AutoFilter::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            fld: f_fld.ok_or_else(|| ParseError::MissingAttribute("fld".to_string()))?,
            mp_fld: f_mp_fld,
            r#type: f_type.ok_or_else(|| ParseError::MissingAttribute("type".to_string()))?,
            eval_order: f_eval_order,
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            i_measure_hier: f_i_measure_hier,
            i_measure_fld: f_i_measure_fld,
            name: f_name,
            description: f_description,
            string_value1: f_string_value1,
            string_value2: f_string_value2,
            auto_filter: f_auto_filter
                .ok_or_else(|| ParseError::MissingAttribute("autoFilter".to_string()))?,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for PivotArea {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_field = None;
        let mut f_type = None;
        let mut f_data_only = None;
        let mut f_label_only = None;
        let mut f_grand_row = None;
        let mut f_grand_col = None;
        let mut f_cache_index = None;
        let mut f_outline = None;
        let mut f_offset = None;
        let mut f_collapsed_levels_are_subtotals = None;
        let mut f_axis = None;
        let mut f_field_position = None;
        let mut f_references = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"field" => {
                    f_field = val.parse().ok();
                }
                b"type" => {
                    f_type = val.parse().ok();
                }
                b"dataOnly" => {
                    f_data_only = Some(val == "true" || val == "1");
                }
                b"labelOnly" => {
                    f_label_only = Some(val == "true" || val == "1");
                }
                b"grandRow" => {
                    f_grand_row = Some(val == "true" || val == "1");
                }
                b"grandCol" => {
                    f_grand_col = Some(val == "true" || val == "1");
                }
                b"cacheIndex" => {
                    f_cache_index = Some(val == "true" || val == "1");
                }
                b"outline" => {
                    f_outline = Some(val == "true" || val == "1");
                }
                b"offset" => {
                    f_offset = Some(val.into_owned());
                }
                b"collapsedLevelsAreSubtotals" => {
                    f_collapsed_levels_are_subtotals = Some(val == "true" || val == "1");
                }
                b"axis" => {
                    f_axis = val.parse().ok();
                }
                b"fieldPosition" => {
                    f_field_position = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"references" => {
                                f_references = Some(Box::new(CTPivotAreaReferences::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"references" => {
                                f_references = Some(Box::new(CTPivotAreaReferences::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            field: f_field,
            r#type: f_type,
            data_only: f_data_only,
            label_only: f_label_only,
            grand_row: f_grand_row,
            grand_col: f_grand_col,
            cache_index: f_cache_index,
            outline: f_outline,
            offset: f_offset,
            collapsed_levels_are_subtotals: f_collapsed_levels_are_subtotals,
            axis: f_axis,
            field_position: f_field_position,
            references: f_references,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTPivotAreaReferences {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_reference = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"reference" => {
                                f_reference
                                    .push(CTPivotAreaReference::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"reference" => {
                                f_reference.push(CTPivotAreaReference::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            reference: f_reference,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTPivotAreaReference {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_field = None;
        let mut f_count = None;
        let mut f_selected = None;
        let mut f_by_position = None;
        let mut f_relative = None;
        let mut f_default_subtotal = None;
        let mut f_sum_subtotal = None;
        let mut f_count_a_subtotal = None;
        let mut f_avg_subtotal = None;
        let mut f_max_subtotal = None;
        let mut f_min_subtotal = None;
        let mut f_product_subtotal = None;
        let mut f_count_subtotal = None;
        let mut f_std_dev_subtotal = None;
        let mut f_std_dev_p_subtotal = None;
        let mut f_var_subtotal = None;
        let mut f_var_p_subtotal = None;
        let mut f_x = Vec::new();
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"field" => {
                    f_field = val.parse().ok();
                }
                b"count" => {
                    f_count = val.parse().ok();
                }
                b"selected" => {
                    f_selected = Some(val == "true" || val == "1");
                }
                b"byPosition" => {
                    f_by_position = Some(val == "true" || val == "1");
                }
                b"relative" => {
                    f_relative = Some(val == "true" || val == "1");
                }
                b"defaultSubtotal" => {
                    f_default_subtotal = Some(val == "true" || val == "1");
                }
                b"sumSubtotal" => {
                    f_sum_subtotal = Some(val == "true" || val == "1");
                }
                b"countASubtotal" => {
                    f_count_a_subtotal = Some(val == "true" || val == "1");
                }
                b"avgSubtotal" => {
                    f_avg_subtotal = Some(val == "true" || val == "1");
                }
                b"maxSubtotal" => {
                    f_max_subtotal = Some(val == "true" || val == "1");
                }
                b"minSubtotal" => {
                    f_min_subtotal = Some(val == "true" || val == "1");
                }
                b"productSubtotal" => {
                    f_product_subtotal = Some(val == "true" || val == "1");
                }
                b"countSubtotal" => {
                    f_count_subtotal = Some(val == "true" || val == "1");
                }
                b"stdDevSubtotal" => {
                    f_std_dev_subtotal = Some(val == "true" || val == "1");
                }
                b"stdDevPSubtotal" => {
                    f_std_dev_p_subtotal = Some(val == "true" || val == "1");
                }
                b"varSubtotal" => {
                    f_var_subtotal = Some(val == "true" || val == "1");
                }
                b"varPSubtotal" => {
                    f_var_p_subtotal = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"x" => {
                                f_x.push(CTIndex::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"x" => {
                                f_x.push(CTIndex::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            field: f_field,
            count: f_count,
            selected: f_selected,
            by_position: f_by_position,
            relative: f_relative,
            default_subtotal: f_default_subtotal,
            sum_subtotal: f_sum_subtotal,
            count_a_subtotal: f_count_a_subtotal,
            avg_subtotal: f_avg_subtotal,
            max_subtotal: f_max_subtotal,
            min_subtotal: f_min_subtotal,
            product_subtotal: f_product_subtotal,
            count_subtotal: f_count_subtotal,
            std_dev_subtotal: f_std_dev_subtotal,
            std_dev_p_subtotal: f_std_dev_p_subtotal,
            var_subtotal: f_var_subtotal,
            var_p_subtotal: f_var_p_subtotal,
            x: f_x,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTIndex {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<u32> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"v" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("v".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for QueryTable {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name: Option<XmlString> = None;
        let mut f_headers = None;
        let mut f_row_numbers = None;
        let mut f_disable_refresh = None;
        let mut f_background_refresh = None;
        let mut f_first_background_refresh = None;
        let mut f_refresh_on_load = None;
        let mut f_grow_shrink_type = None;
        let mut f_fill_formulas = None;
        let mut f_remove_data_on_save = None;
        let mut f_disable_edit = None;
        let mut f_preserve_formatting = None;
        let mut f_adjust_column_width = None;
        let mut f_intermediate = None;
        let mut f_connection_id: Option<u32> = None;
        let mut f_auto_format_id = None;
        let mut f_apply_number_formats = None;
        let mut f_apply_border_formats = None;
        let mut f_apply_font_formats = None;
        let mut f_apply_pattern_formats = None;
        let mut f_apply_alignment_formats = None;
        let mut f_apply_width_height_formats = None;
        let mut f_query_table_refresh = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"headers" => {
                    f_headers = Some(val == "true" || val == "1");
                }
                b"rowNumbers" => {
                    f_row_numbers = Some(val == "true" || val == "1");
                }
                b"disableRefresh" => {
                    f_disable_refresh = Some(val == "true" || val == "1");
                }
                b"backgroundRefresh" => {
                    f_background_refresh = Some(val == "true" || val == "1");
                }
                b"firstBackgroundRefresh" => {
                    f_first_background_refresh = Some(val == "true" || val == "1");
                }
                b"refreshOnLoad" => {
                    f_refresh_on_load = Some(val == "true" || val == "1");
                }
                b"growShrinkType" => {
                    f_grow_shrink_type = val.parse().ok();
                }
                b"fillFormulas" => {
                    f_fill_formulas = Some(val == "true" || val == "1");
                }
                b"removeDataOnSave" => {
                    f_remove_data_on_save = Some(val == "true" || val == "1");
                }
                b"disableEdit" => {
                    f_disable_edit = Some(val == "true" || val == "1");
                }
                b"preserveFormatting" => {
                    f_preserve_formatting = Some(val == "true" || val == "1");
                }
                b"adjustColumnWidth" => {
                    f_adjust_column_width = Some(val == "true" || val == "1");
                }
                b"intermediate" => {
                    f_intermediate = Some(val == "true" || val == "1");
                }
                b"connectionId" => {
                    f_connection_id = val.parse().ok();
                }
                b"autoFormatId" => {
                    f_auto_format_id = val.parse().ok();
                }
                b"applyNumberFormats" => {
                    f_apply_number_formats = Some(val == "true" || val == "1");
                }
                b"applyBorderFormats" => {
                    f_apply_border_formats = Some(val == "true" || val == "1");
                }
                b"applyFontFormats" => {
                    f_apply_font_formats = Some(val == "true" || val == "1");
                }
                b"applyPatternFormats" => {
                    f_apply_pattern_formats = Some(val == "true" || val == "1");
                }
                b"applyAlignmentFormats" => {
                    f_apply_alignment_formats = Some(val == "true" || val == "1");
                }
                b"applyWidthHeightFormats" => {
                    f_apply_width_height_formats = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"queryTableRefresh" => {
                                f_query_table_refresh =
                                    Some(Box::new(QueryTableRefresh::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"queryTableRefresh" => {
                                f_query_table_refresh =
                                    Some(Box::new(QueryTableRefresh::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            headers: f_headers,
            row_numbers: f_row_numbers,
            disable_refresh: f_disable_refresh,
            background_refresh: f_background_refresh,
            first_background_refresh: f_first_background_refresh,
            refresh_on_load: f_refresh_on_load,
            grow_shrink_type: f_grow_shrink_type,
            fill_formulas: f_fill_formulas,
            remove_data_on_save: f_remove_data_on_save,
            disable_edit: f_disable_edit,
            preserve_formatting: f_preserve_formatting,
            adjust_column_width: f_adjust_column_width,
            intermediate: f_intermediate,
            connection_id: f_connection_id
                .ok_or_else(|| ParseError::MissingAttribute("connectionId".to_string()))?,
            auto_format_id: f_auto_format_id,
            apply_number_formats: f_apply_number_formats,
            apply_border_formats: f_apply_border_formats,
            apply_font_formats: f_apply_font_formats,
            apply_pattern_formats: f_apply_pattern_formats,
            apply_alignment_formats: f_apply_alignment_formats,
            apply_width_height_formats: f_apply_width_height_formats,
            query_table_refresh: f_query_table_refresh,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for QueryTableRefresh {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_preserve_sort_filter_layout = None;
        let mut f_field_id_wrapped = None;
        let mut f_headers_in_last_refresh = None;
        let mut f_minimum_version = None;
        let mut f_next_id = None;
        let mut f_unbound_columns_left = None;
        let mut f_unbound_columns_right = None;
        let mut f_query_table_fields: Option<Box<QueryTableFields>> = None;
        let mut f_query_table_deleted_fields = None;
        let mut f_sort_state = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"preserveSortFilterLayout" => {
                    f_preserve_sort_filter_layout = Some(val == "true" || val == "1");
                }
                b"fieldIdWrapped" => {
                    f_field_id_wrapped = Some(val == "true" || val == "1");
                }
                b"headersInLastRefresh" => {
                    f_headers_in_last_refresh = Some(val == "true" || val == "1");
                }
                b"minimumVersion" => {
                    f_minimum_version = val.parse().ok();
                }
                b"nextId" => {
                    f_next_id = val.parse().ok();
                }
                b"unboundColumnsLeft" => {
                    f_unbound_columns_left = val.parse().ok();
                }
                b"unboundColumnsRight" => {
                    f_unbound_columns_right = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"queryTableFields" => {
                                f_query_table_fields =
                                    Some(Box::new(QueryTableFields::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"queryTableDeletedFields" => {
                                f_query_table_deleted_fields = Some(Box::new(
                                    QueryTableDeletedFields::from_xml(reader, &e, false)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sortState" => {
                                f_sort_state =
                                    Some(Box::new(SortState::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"queryTableFields" => {
                                f_query_table_fields =
                                    Some(Box::new(QueryTableFields::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"queryTableDeletedFields" => {
                                f_query_table_deleted_fields = Some(Box::new(
                                    QueryTableDeletedFields::from_xml(reader, &e, true)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sortState" => {
                                f_sort_state =
                                    Some(Box::new(SortState::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            preserve_sort_filter_layout: f_preserve_sort_filter_layout,
            field_id_wrapped: f_field_id_wrapped,
            headers_in_last_refresh: f_headers_in_last_refresh,
            minimum_version: f_minimum_version,
            next_id: f_next_id,
            unbound_columns_left: f_unbound_columns_left,
            unbound_columns_right: f_unbound_columns_right,
            query_table_fields: f_query_table_fields
                .ok_or_else(|| ParseError::MissingAttribute("queryTableFields".to_string()))?,
            query_table_deleted_fields: f_query_table_deleted_fields,
            sort_state: f_sort_state,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for QueryTableDeletedFields {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_deleted_field = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"deletedField" => {
                                f_deleted_field.push(CTDeletedField::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"deletedField" => {
                                f_deleted_field.push(CTDeletedField::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            deleted_field: f_deleted_field,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTDeletedField {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name: Option<XmlString> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for QueryTableFields {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_query_table_field = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"queryTableField" => {
                                f_query_table_field
                                    .push(QueryTableField::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"queryTableField" => {
                                f_query_table_field
                                    .push(QueryTableField::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            query_table_field: f_query_table_field,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for QueryTableField {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<u32> = None;
        let mut f_name = None;
        let mut f_data_bound = None;
        let mut f_row_numbers = None;
        let mut f_fill_formulas = None;
        let mut f_clipped = None;
        let mut f_table_column_id = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"dataBound" => {
                    f_data_bound = Some(val == "true" || val == "1");
                }
                b"rowNumbers" => {
                    f_row_numbers = Some(val == "true" || val == "1");
                }
                b"fillFormulas" => {
                    f_fill_formulas = Some(val == "true" || val == "1");
                }
                b"clipped" => {
                    f_clipped = Some(val == "true" || val == "1");
                }
                b"tableColumnId" => {
                    f_table_column_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            name: f_name,
            data_bound: f_data_bound,
            row_numbers: f_row_numbers,
            fill_formulas: f_fill_formulas,
            clipped: f_clipped,
            table_column_id: f_table_column_id,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for SharedStrings {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_unique_count = None;
        let mut f_si = Vec::new();
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                b"uniqueCount" => {
                    f_unique_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"si" => {
                                f_si.push(RichString::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"si" => {
                                f_si.push(RichString::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            unique_count: f_unique_count,
            si: f_si,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for PhoneticRun {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_sb: Option<u32> = None;
        let mut f_eb: Option<u32> = None;
        let mut f_cell_type: Option<XmlString> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"sb" => {
                    f_sb = val.parse().ok();
                }
                b"eb" => {
                    f_eb = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"t" => {
                                f_cell_type = Some(read_text_content(reader)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"t" => {
                                f_cell_type = Some(String::new());
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            sb: f_sb.ok_or_else(|| ParseError::MissingAttribute("sb".to_string()))?,
            eb: f_eb.ok_or_else(|| ParseError::MissingAttribute("eb".to_string()))?,
            cell_type: f_cell_type.ok_or_else(|| ParseError::MissingAttribute("t".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for RichTextElement {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_r_pr = None;
        let mut f_cell_type: Option<XmlString> = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"rPr" => {
                                f_r_pr = Some(Box::new(RichTextRunProperties::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"t" => {
                                f_cell_type = Some(read_text_content(reader)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"rPr" => {
                                f_r_pr = Some(Box::new(RichTextRunProperties::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"t" => {
                                f_cell_type = Some(String::new());
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r_pr: f_r_pr,
            cell_type: f_cell_type.ok_or_else(|| ParseError::MissingAttribute("t".to_string()))?,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for RichTextRunProperties {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_r_font = None;
        let mut f_charset = None;
        let mut f_family = None;
        let mut f_b = None;
        let mut f_i = None;
        let mut f_strike = None;
        let mut f_outline = None;
        let mut f_shadow = None;
        let mut f_condense = None;
        let mut f_extend = None;
        let mut f_color = None;
        let mut f_sz = None;
        let mut f_u = None;
        let mut f_vert_align = None;
        let mut f_scheme = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"rFont" => {
                                f_r_font = Some(Box::new(FontName::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"charset" => {
                                f_charset =
                                    Some(Box::new(IntProperty::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"family" => {
                                f_family =
                                    Some(Box::new(IntProperty::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"b" => {
                                f_b = Some(Box::new(BooleanProperty::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"i" => {
                                f_i = Some(Box::new(BooleanProperty::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"strike" => {
                                f_strike =
                                    Some(Box::new(BooleanProperty::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"outline" => {
                                f_outline =
                                    Some(Box::new(BooleanProperty::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shadow" => {
                                f_shadow =
                                    Some(Box::new(BooleanProperty::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"condense" => {
                                f_condense =
                                    Some(Box::new(BooleanProperty::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extend" => {
                                f_extend =
                                    Some(Box::new(BooleanProperty::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"color" => {
                                f_color = Some(Box::new(Color::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sz" => {
                                f_sz = Some(Box::new(FontSize::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"u" => {
                                f_u =
                                    Some(Box::new(UnderlineProperty::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vertAlign" => {
                                f_vert_align = Some(Box::new(VerticalAlignFontProperty::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"scheme" => {
                                f_scheme = Some(Box::new(FontSchemeProperty::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"rFont" => {
                                f_r_font = Some(Box::new(FontName::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"charset" => {
                                f_charset =
                                    Some(Box::new(IntProperty::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"family" => {
                                f_family = Some(Box::new(IntProperty::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"b" => {
                                f_b = Some(Box::new(BooleanProperty::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"i" => {
                                f_i = Some(Box::new(BooleanProperty::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"strike" => {
                                f_strike =
                                    Some(Box::new(BooleanProperty::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"outline" => {
                                f_outline =
                                    Some(Box::new(BooleanProperty::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"shadow" => {
                                f_shadow =
                                    Some(Box::new(BooleanProperty::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"condense" => {
                                f_condense =
                                    Some(Box::new(BooleanProperty::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extend" => {
                                f_extend =
                                    Some(Box::new(BooleanProperty::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"color" => {
                                f_color = Some(Box::new(Color::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sz" => {
                                f_sz = Some(Box::new(FontSize::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"u" => {
                                f_u =
                                    Some(Box::new(UnderlineProperty::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"vertAlign" => {
                                f_vert_align = Some(Box::new(VerticalAlignFontProperty::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"scheme" => {
                                f_scheme =
                                    Some(Box::new(FontSchemeProperty::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r_font: f_r_font,
            charset: f_charset,
            family: f_family,
            b: f_b,
            i: f_i,
            strike: f_strike,
            outline: f_outline,
            shadow: f_shadow,
            condense: f_condense,
            extend: f_extend,
            color: f_color,
            sz: f_sz,
            u: f_u,
            vert_align: f_vert_align,
            scheme: f_scheme,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for RichString {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_cell_type = None;
        let mut f_reference = Vec::new();
        let mut f_r_ph = Vec::new();
        let mut f_phonetic_pr = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"t" => {
                                f_cell_type = Some(read_text_content(reader)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"r" => {
                                f_reference.push(RichTextElement::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rPh" => {
                                f_r_ph.push(PhoneticRun::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"phoneticPr" => {
                                f_phonetic_pr = Some(Box::new(PhoneticProperties::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"t" => {
                                f_cell_type = Some(String::new());
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"r" => {
                                f_reference.push(RichTextElement::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rPh" => {
                                f_r_ph.push(PhoneticRun::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"phoneticPr" => {
                                f_phonetic_pr =
                                    Some(Box::new(PhoneticProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            cell_type: f_cell_type,
            reference: f_reference,
            r_ph: f_r_ph,
            phonetic_pr: f_phonetic_pr,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for PhoneticProperties {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_font_id: Option<STFontId> = None;
        let mut f_type = None;
        let mut f_alignment = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"fontId" => {
                    f_font_id = val.parse().ok();
                }
                b"type" => {
                    f_type = val.parse().ok();
                }
                b"alignment" => {
                    f_alignment = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            font_id: f_font_id.ok_or_else(|| ParseError::MissingAttribute("fontId".to_string()))?,
            r#type: f_type,
            alignment: f_alignment,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for RevisionHeaders {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_guid: Option<Guid> = None;
        let mut f_last_guid = None;
        let mut f_shared = None;
        let mut f_disk_revisions = None;
        let mut f_history = None;
        let mut f_track_revisions = None;
        let mut f_exclusive = None;
        let mut f_revision_id = None;
        let mut f_version = None;
        let mut f_keep_change_history = None;
        let mut f_protected = None;
        let mut f_preserve_history = None;
        let mut f_header = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"guid" => {
                    f_guid = Some(val.into_owned());
                }
                b"lastGuid" => {
                    f_last_guid = Some(val.into_owned());
                }
                b"shared" => {
                    f_shared = Some(val == "true" || val == "1");
                }
                b"diskRevisions" => {
                    f_disk_revisions = Some(val == "true" || val == "1");
                }
                b"history" => {
                    f_history = Some(val == "true" || val == "1");
                }
                b"trackRevisions" => {
                    f_track_revisions = Some(val == "true" || val == "1");
                }
                b"exclusive" => {
                    f_exclusive = Some(val == "true" || val == "1");
                }
                b"revisionId" => {
                    f_revision_id = val.parse().ok();
                }
                b"version" => {
                    f_version = val.parse().ok();
                }
                b"keepChangeHistory" => {
                    f_keep_change_history = Some(val == "true" || val == "1");
                }
                b"protected" => {
                    f_protected = Some(val == "true" || val == "1");
                }
                b"preserveHistory" => {
                    f_preserve_history = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"header" => {
                                f_header.push(RevisionHeader::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"header" => {
                                f_header.push(RevisionHeader::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            guid: f_guid.ok_or_else(|| ParseError::MissingAttribute("guid".to_string()))?,
            last_guid: f_last_guid,
            shared: f_shared,
            disk_revisions: f_disk_revisions,
            history: f_history,
            track_revisions: f_track_revisions,
            exclusive: f_exclusive,
            revision_id: f_revision_id,
            version: f_version,
            keep_change_history: f_keep_change_history,
            protected: f_protected,
            preserve_history: f_preserve_history,
            header: f_header,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Revisions {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_rrc = Vec::new();
        let mut f_rm = Vec::new();
        let mut f_rcv = Vec::new();
        let mut f_rsnm = Vec::new();
        let mut f_ris = Vec::new();
        let mut f_rcc = Vec::new();
        let mut f_rfmt = Vec::new();
        let mut f_raf = Vec::new();
        let mut f_rdn = Vec::new();
        let mut f_rcmt = Vec::new();
        let mut f_rqt = Vec::new();
        let mut f_rcft = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"rrc" => {
                                f_rrc.push(RevisionRowColumn::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rm" => {
                                f_rm.push(RevisionMove::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rcv" => {
                                f_rcv.push(RevisionCustomView::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rsnm" => {
                                f_rsnm.push(RevisionSheetRename::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"ris" => {
                                f_ris.push(RevisionInsertSheet::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rcc" => {
                                f_rcc.push(RevisionCellChange::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rfmt" => {
                                f_rfmt.push(RevisionFormatting::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"raf" => {
                                f_raf.push(RevisionAutoFormatting::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rdn" => {
                                f_rdn.push(RevisionDefinedName::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rcmt" => {
                                f_rcmt.push(RevisionComment::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rqt" => {
                                f_rqt.push(RevisionQueryTableField::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rcft" => {
                                f_rcft.push(RevisionConflict::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"rrc" => {
                                f_rrc.push(RevisionRowColumn::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rm" => {
                                f_rm.push(RevisionMove::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rcv" => {
                                f_rcv.push(RevisionCustomView::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rsnm" => {
                                f_rsnm.push(RevisionSheetRename::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"ris" => {
                                f_ris.push(RevisionInsertSheet::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rcc" => {
                                f_rcc.push(RevisionCellChange::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rfmt" => {
                                f_rfmt.push(RevisionFormatting::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"raf" => {
                                f_raf.push(RevisionAutoFormatting::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rdn" => {
                                f_rdn.push(RevisionDefinedName::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rcmt" => {
                                f_rcmt.push(RevisionComment::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rqt" => {
                                f_rqt.push(RevisionQueryTableField::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rcft" => {
                                f_rcft.push(RevisionConflict::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            rrc: f_rrc,
            rm: f_rm,
            rcv: f_rcv,
            rsnm: f_rsnm,
            ris: f_ris,
            rcc: f_rcc,
            rfmt: f_rfmt,
            raf: f_raf,
            rdn: f_rdn,
            rcmt: f_rcmt,
            rqt: f_rqt,
            rcft: f_rcft,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for SmlAGRevData {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_r_id: Option<u32> = None;
        let mut f_ua = None;
        let mut f_ra = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"rId" => {
                    f_r_id = val.parse().ok();
                }
                b"ua" => {
                    f_ua = Some(val == "true" || val == "1");
                }
                b"ra" => {
                    f_ra = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r_id: f_r_id.ok_or_else(|| ParseError::MissingAttribute("rId".to_string()))?,
            ua: f_ua,
            ra: f_ra,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for RevisionHeader {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_guid: Option<Guid> = None;
        let mut f_date_time: Option<String> = None;
        let mut f_max_sheet_id: Option<u32> = None;
        let mut f_user_name: Option<XmlString> = None;
        let mut f_id: Option<STRelationshipId> = None;
        let mut f_min_r_id = None;
        let mut f_max_r_id = None;
        let mut f_sheet_id_map: Option<Box<CTSheetIdMap>> = None;
        let mut f_reviewed_list = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"guid" => {
                    f_guid = Some(val.into_owned());
                }
                b"dateTime" => {
                    f_date_time = Some(val.into_owned());
                }
                b"maxSheetId" => {
                    f_max_sheet_id = val.parse().ok();
                }
                b"userName" => {
                    f_user_name = Some(val.into_owned());
                }
                b"id" => {
                    f_id = Some(val.into_owned());
                }
                b"minRId" => {
                    f_min_r_id = val.parse().ok();
                }
                b"maxRId" => {
                    f_max_r_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"sheetIdMap" => {
                                f_sheet_id_map =
                                    Some(Box::new(CTSheetIdMap::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"reviewedList" => {
                                f_reviewed_list =
                                    Some(Box::new(ReviewedRevisions::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"sheetIdMap" => {
                                f_sheet_id_map =
                                    Some(Box::new(CTSheetIdMap::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"reviewedList" => {
                                f_reviewed_list =
                                    Some(Box::new(ReviewedRevisions::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            guid: f_guid.ok_or_else(|| ParseError::MissingAttribute("guid".to_string()))?,
            date_time: f_date_time
                .ok_or_else(|| ParseError::MissingAttribute("dateTime".to_string()))?,
            max_sheet_id: f_max_sheet_id
                .ok_or_else(|| ParseError::MissingAttribute("maxSheetId".to_string()))?,
            user_name: f_user_name
                .ok_or_else(|| ParseError::MissingAttribute("userName".to_string()))?,
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            min_r_id: f_min_r_id,
            max_r_id: f_max_r_id,
            sheet_id_map: f_sheet_id_map
                .ok_or_else(|| ParseError::MissingAttribute("sheetIdMap".to_string()))?,
            reviewed_list: f_reviewed_list,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTSheetIdMap {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_sheet_id = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"sheetId" => {
                                f_sheet_id.push(CTSheetId::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"sheetId" => {
                                f_sheet_id.push(CTSheetId::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            sheet_id: f_sheet_id,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTSheetId {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<u32> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for ReviewedRevisions {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_reviewed = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"reviewed" => {
                                f_reviewed.push(Reviewed::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"reviewed" => {
                                f_reviewed.push(Reviewed::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            reviewed: f_reviewed,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Reviewed {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_r_id: Option<u32> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"rId" => {
                    f_r_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r_id: f_r_id.ok_or_else(|| ParseError::MissingAttribute("rId".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for UndoInfo {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_index: Option<u32> = None;
        let mut f_exp: Option<STFormulaExpression> = None;
        let mut f_ref3_d = None;
        let mut f_array = None;
        let mut f_value = None;
        let mut f_nf = None;
        let mut f_cs = None;
        let mut f_dr: Option<STRefA> = None;
        let mut f_dn = None;
        let mut f_reference = None;
        let mut f_s_id = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"index" => {
                    f_index = val.parse().ok();
                }
                b"exp" => {
                    f_exp = val.parse().ok();
                }
                b"ref3D" => {
                    f_ref3_d = Some(val == "true" || val == "1");
                }
                b"array" => {
                    f_array = Some(val == "true" || val == "1");
                }
                b"v" => {
                    f_value = Some(val == "true" || val == "1");
                }
                b"nf" => {
                    f_nf = Some(val == "true" || val == "1");
                }
                b"cs" => {
                    f_cs = Some(val == "true" || val == "1");
                }
                b"dr" => {
                    f_dr = Some(val.into_owned());
                }
                b"dn" => {
                    f_dn = Some(val.into_owned());
                }
                b"r" => {
                    f_reference = Some(val.into_owned());
                }
                b"sId" => {
                    f_s_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            index: f_index.ok_or_else(|| ParseError::MissingAttribute("index".to_string()))?,
            exp: f_exp.ok_or_else(|| ParseError::MissingAttribute("exp".to_string()))?,
            ref3_d: f_ref3_d,
            array: f_array,
            value: f_value,
            nf: f_nf,
            cs: f_cs,
            dr: f_dr.ok_or_else(|| ParseError::MissingAttribute("dr".to_string()))?,
            dn: f_dn,
            reference: f_reference,
            s_id: f_s_id,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for RevisionRowColumn {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_r_id: Option<u32> = None;
        let mut f_ua = None;
        let mut f_ra = None;
        let mut f_s_id: Option<u32> = None;
        let mut f_eol = None;
        let mut f_reference: Option<Reference> = None;
        let mut f_action: Option<STRwColActionType> = None;
        let mut f_edge = None;
        let mut f_undo = Vec::new();
        let mut f_rcc = Vec::new();
        let mut f_rfmt = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"rId" => {
                    f_r_id = val.parse().ok();
                }
                b"ua" => {
                    f_ua = Some(val == "true" || val == "1");
                }
                b"ra" => {
                    f_ra = Some(val == "true" || val == "1");
                }
                b"sId" => {
                    f_s_id = val.parse().ok();
                }
                b"eol" => {
                    f_eol = Some(val == "true" || val == "1");
                }
                b"ref" => {
                    f_reference = Some(val.into_owned());
                }
                b"action" => {
                    f_action = val.parse().ok();
                }
                b"edge" => {
                    f_edge = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"undo" => {
                                f_undo.push(UndoInfo::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rcc" => {
                                f_rcc.push(RevisionCellChange::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rfmt" => {
                                f_rfmt.push(RevisionFormatting::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"undo" => {
                                f_undo.push(UndoInfo::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rcc" => {
                                f_rcc.push(RevisionCellChange::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rfmt" => {
                                f_rfmt.push(RevisionFormatting::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r_id: f_r_id.ok_or_else(|| ParseError::MissingAttribute("rId".to_string()))?,
            ua: f_ua,
            ra: f_ra,
            s_id: f_s_id.ok_or_else(|| ParseError::MissingAttribute("sId".to_string()))?,
            eol: f_eol,
            reference: f_reference
                .ok_or_else(|| ParseError::MissingAttribute("ref".to_string()))?,
            action: f_action.ok_or_else(|| ParseError::MissingAttribute("action".to_string()))?,
            edge: f_edge,
            undo: f_undo,
            rcc: f_rcc,
            rfmt: f_rfmt,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for RevisionMove {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_r_id: Option<u32> = None;
        let mut f_ua = None;
        let mut f_ra = None;
        let mut f_sheet_id: Option<u32> = None;
        let mut f_source: Option<Reference> = None;
        let mut f_destination: Option<Reference> = None;
        let mut f_source_sheet_id = None;
        let mut f_undo = Vec::new();
        let mut f_rcc = Vec::new();
        let mut f_rfmt = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"rId" => {
                    f_r_id = val.parse().ok();
                }
                b"ua" => {
                    f_ua = Some(val == "true" || val == "1");
                }
                b"ra" => {
                    f_ra = Some(val == "true" || val == "1");
                }
                b"sheetId" => {
                    f_sheet_id = val.parse().ok();
                }
                b"source" => {
                    f_source = Some(val.into_owned());
                }
                b"destination" => {
                    f_destination = Some(val.into_owned());
                }
                b"sourceSheetId" => {
                    f_source_sheet_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"undo" => {
                                f_undo.push(UndoInfo::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rcc" => {
                                f_rcc.push(RevisionCellChange::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rfmt" => {
                                f_rfmt.push(RevisionFormatting::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"undo" => {
                                f_undo.push(UndoInfo::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rcc" => {
                                f_rcc.push(RevisionCellChange::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rfmt" => {
                                f_rfmt.push(RevisionFormatting::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r_id: f_r_id.ok_or_else(|| ParseError::MissingAttribute("rId".to_string()))?,
            ua: f_ua,
            ra: f_ra,
            sheet_id: f_sheet_id
                .ok_or_else(|| ParseError::MissingAttribute("sheetId".to_string()))?,
            source: f_source.ok_or_else(|| ParseError::MissingAttribute("source".to_string()))?,
            destination: f_destination
                .ok_or_else(|| ParseError::MissingAttribute("destination".to_string()))?,
            source_sheet_id: f_source_sheet_id,
            undo: f_undo,
            rcc: f_rcc,
            rfmt: f_rfmt,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for RevisionCustomView {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_guid: Option<Guid> = None;
        let mut f_action: Option<STRevisionAction> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"guid" => {
                    f_guid = Some(val.into_owned());
                }
                b"action" => {
                    f_action = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            guid: f_guid.ok_or_else(|| ParseError::MissingAttribute("guid".to_string()))?,
            action: f_action.ok_or_else(|| ParseError::MissingAttribute("action".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for RevisionSheetRename {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_r_id: Option<u32> = None;
        let mut f_ua = None;
        let mut f_ra = None;
        let mut f_sheet_id: Option<u32> = None;
        let mut f_old_name: Option<XmlString> = None;
        let mut f_new_name: Option<XmlString> = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"rId" => {
                    f_r_id = val.parse().ok();
                }
                b"ua" => {
                    f_ua = Some(val == "true" || val == "1");
                }
                b"ra" => {
                    f_ra = Some(val == "true" || val == "1");
                }
                b"sheetId" => {
                    f_sheet_id = val.parse().ok();
                }
                b"oldName" => {
                    f_old_name = Some(val.into_owned());
                }
                b"newName" => {
                    f_new_name = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r_id: f_r_id.ok_or_else(|| ParseError::MissingAttribute("rId".to_string()))?,
            ua: f_ua,
            ra: f_ra,
            sheet_id: f_sheet_id
                .ok_or_else(|| ParseError::MissingAttribute("sheetId".to_string()))?,
            old_name: f_old_name
                .ok_or_else(|| ParseError::MissingAttribute("oldName".to_string()))?,
            new_name: f_new_name
                .ok_or_else(|| ParseError::MissingAttribute("newName".to_string()))?,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for RevisionInsertSheet {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_r_id: Option<u32> = None;
        let mut f_ua = None;
        let mut f_ra = None;
        let mut f_sheet_id: Option<u32> = None;
        let mut f_name: Option<XmlString> = None;
        let mut f_sheet_position: Option<u32> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"rId" => {
                    f_r_id = val.parse().ok();
                }
                b"ua" => {
                    f_ua = Some(val == "true" || val == "1");
                }
                b"ra" => {
                    f_ra = Some(val == "true" || val == "1");
                }
                b"sheetId" => {
                    f_sheet_id = val.parse().ok();
                }
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"sheetPosition" => {
                    f_sheet_position = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r_id: f_r_id.ok_or_else(|| ParseError::MissingAttribute("rId".to_string()))?,
            ua: f_ua,
            ra: f_ra,
            sheet_id: f_sheet_id
                .ok_or_else(|| ParseError::MissingAttribute("sheetId".to_string()))?,
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            sheet_position: f_sheet_position
                .ok_or_else(|| ParseError::MissingAttribute("sheetPosition".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for RevisionCellChange {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_r_id: Option<u32> = None;
        let mut f_ua = None;
        let mut f_ra = None;
        let mut f_s_id: Option<u32> = None;
        let mut f_odxf = None;
        let mut f_xf_dxf = None;
        let mut f_style_index = None;
        let mut f_dxf = None;
        let mut f_number_format_id = None;
        let mut f_quote_prefix = None;
        let mut f_old_quote_prefix = None;
        let mut f_placeholder = None;
        let mut f_old_ph = None;
        let mut f_end_of_list_formula_update = None;
        let mut f_oc = None;
        let mut f_nc: Option<Box<Cell>> = None;
        let mut f_ndxf = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"rId" => {
                    f_r_id = val.parse().ok();
                }
                b"ua" => {
                    f_ua = Some(val == "true" || val == "1");
                }
                b"ra" => {
                    f_ra = Some(val == "true" || val == "1");
                }
                b"sId" => {
                    f_s_id = val.parse().ok();
                }
                b"odxf" => {
                    f_odxf = Some(val == "true" || val == "1");
                }
                b"xfDxf" => {
                    f_xf_dxf = Some(val == "true" || val == "1");
                }
                b"s" => {
                    f_style_index = Some(val == "true" || val == "1");
                }
                b"dxf" => {
                    f_dxf = Some(val == "true" || val == "1");
                }
                b"numFmtId" => {
                    f_number_format_id = val.parse().ok();
                }
                b"quotePrefix" => {
                    f_quote_prefix = Some(val == "true" || val == "1");
                }
                b"oldQuotePrefix" => {
                    f_old_quote_prefix = Some(val == "true" || val == "1");
                }
                b"ph" => {
                    f_placeholder = Some(val == "true" || val == "1");
                }
                b"oldPh" => {
                    f_old_ph = Some(val == "true" || val == "1");
                }
                b"endOfListFormulaUpdate" => {
                    f_end_of_list_formula_update = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"oc" => {
                                f_oc = Some(Box::new(Cell::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"nc" => {
                                f_nc = Some(Box::new(Cell::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"ndxf" => {
                                f_ndxf = Some(Box::new(DifferentialFormat::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"oc" => {
                                f_oc = Some(Box::new(Cell::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"nc" => {
                                f_nc = Some(Box::new(Cell::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"ndxf" => {
                                f_ndxf =
                                    Some(Box::new(DifferentialFormat::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r_id: f_r_id.ok_or_else(|| ParseError::MissingAttribute("rId".to_string()))?,
            ua: f_ua,
            ra: f_ra,
            s_id: f_s_id.ok_or_else(|| ParseError::MissingAttribute("sId".to_string()))?,
            odxf: f_odxf,
            xf_dxf: f_xf_dxf,
            style_index: f_style_index,
            dxf: f_dxf,
            number_format_id: f_number_format_id,
            quote_prefix: f_quote_prefix,
            old_quote_prefix: f_old_quote_prefix,
            placeholder: f_placeholder,
            old_ph: f_old_ph,
            end_of_list_formula_update: f_end_of_list_formula_update,
            oc: f_oc,
            nc: f_nc.ok_or_else(|| ParseError::MissingAttribute("nc".to_string()))?,
            ndxf: f_ndxf,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for RevisionFormatting {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_sheet_id: Option<u32> = None;
        let mut f_xf_dxf = None;
        let mut f_style_index = None;
        let mut f_square_reference: Option<SquareRef> = None;
        let mut f_start = None;
        let mut f_length = None;
        let mut f_dxf = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"sheetId" => {
                    f_sheet_id = val.parse().ok();
                }
                b"xfDxf" => {
                    f_xf_dxf = Some(val == "true" || val == "1");
                }
                b"s" => {
                    f_style_index = Some(val == "true" || val == "1");
                }
                b"sqref" => {
                    f_square_reference = Some(val.into_owned());
                }
                b"start" => {
                    f_start = val.parse().ok();
                }
                b"length" => {
                    f_length = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"dxf" => {
                                f_dxf = Some(Box::new(DifferentialFormat::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"dxf" => {
                                f_dxf =
                                    Some(Box::new(DifferentialFormat::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            sheet_id: f_sheet_id
                .ok_or_else(|| ParseError::MissingAttribute("sheetId".to_string()))?,
            xf_dxf: f_xf_dxf,
            style_index: f_style_index,
            square_reference: f_square_reference
                .ok_or_else(|| ParseError::MissingAttribute("sqref".to_string()))?,
            start: f_start,
            length: f_length,
            dxf: f_dxf,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for RevisionAutoFormatting {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_sheet_id: Option<u32> = None;
        let mut f_auto_format_id = None;
        let mut f_apply_number_formats = None;
        let mut f_apply_border_formats = None;
        let mut f_apply_font_formats = None;
        let mut f_apply_pattern_formats = None;
        let mut f_apply_alignment_formats = None;
        let mut f_apply_width_height_formats = None;
        let mut f_reference: Option<Reference> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"sheetId" => {
                    f_sheet_id = val.parse().ok();
                }
                b"autoFormatId" => {
                    f_auto_format_id = val.parse().ok();
                }
                b"applyNumberFormats" => {
                    f_apply_number_formats = Some(val == "true" || val == "1");
                }
                b"applyBorderFormats" => {
                    f_apply_border_formats = Some(val == "true" || val == "1");
                }
                b"applyFontFormats" => {
                    f_apply_font_formats = Some(val == "true" || val == "1");
                }
                b"applyPatternFormats" => {
                    f_apply_pattern_formats = Some(val == "true" || val == "1");
                }
                b"applyAlignmentFormats" => {
                    f_apply_alignment_formats = Some(val == "true" || val == "1");
                }
                b"applyWidthHeightFormats" => {
                    f_apply_width_height_formats = Some(val == "true" || val == "1");
                }
                b"ref" => {
                    f_reference = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            sheet_id: f_sheet_id
                .ok_or_else(|| ParseError::MissingAttribute("sheetId".to_string()))?,
            auto_format_id: f_auto_format_id,
            apply_number_formats: f_apply_number_formats,
            apply_border_formats: f_apply_border_formats,
            apply_font_formats: f_apply_font_formats,
            apply_pattern_formats: f_apply_pattern_formats,
            apply_alignment_formats: f_apply_alignment_formats,
            apply_width_height_formats: f_apply_width_height_formats,
            reference: f_reference
                .ok_or_else(|| ParseError::MissingAttribute("ref".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for RevisionComment {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_sheet_id: Option<u32> = None;
        let mut f_cell: Option<CellRef> = None;
        let mut f_guid: Option<Guid> = None;
        let mut f_action = None;
        let mut f_always_show = None;
        let mut f_old = None;
        let mut f_hidden_row = None;
        let mut f_hidden_column = None;
        let mut f_author: Option<XmlString> = None;
        let mut f_old_length = None;
        let mut f_new_length = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"sheetId" => {
                    f_sheet_id = val.parse().ok();
                }
                b"cell" => {
                    f_cell = Some(val.into_owned());
                }
                b"guid" => {
                    f_guid = Some(val.into_owned());
                }
                b"action" => {
                    f_action = val.parse().ok();
                }
                b"alwaysShow" => {
                    f_always_show = Some(val == "true" || val == "1");
                }
                b"old" => {
                    f_old = Some(val == "true" || val == "1");
                }
                b"hiddenRow" => {
                    f_hidden_row = Some(val == "true" || val == "1");
                }
                b"hiddenColumn" => {
                    f_hidden_column = Some(val == "true" || val == "1");
                }
                b"author" => {
                    f_author = Some(val.into_owned());
                }
                b"oldLength" => {
                    f_old_length = val.parse().ok();
                }
                b"newLength" => {
                    f_new_length = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            sheet_id: f_sheet_id
                .ok_or_else(|| ParseError::MissingAttribute("sheetId".to_string()))?,
            cell: f_cell.ok_or_else(|| ParseError::MissingAttribute("cell".to_string()))?,
            guid: f_guid.ok_or_else(|| ParseError::MissingAttribute("guid".to_string()))?,
            action: f_action,
            always_show: f_always_show,
            old: f_old,
            hidden_row: f_hidden_row,
            hidden_column: f_hidden_column,
            author: f_author.ok_or_else(|| ParseError::MissingAttribute("author".to_string()))?,
            old_length: f_old_length,
            new_length: f_new_length,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for RevisionDefinedName {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_r_id: Option<u32> = None;
        let mut f_ua = None;
        let mut f_ra = None;
        let mut f_local_sheet_id = None;
        let mut f_custom_view = None;
        let mut f_name: Option<XmlString> = None;
        let mut f_function = None;
        let mut f_old_function = None;
        let mut f_function_group_id = None;
        let mut f_old_function_group_id = None;
        let mut f_shortcut_key = None;
        let mut f_old_shortcut_key = None;
        let mut f_hidden = None;
        let mut f_old_hidden = None;
        let mut f_custom_menu = None;
        let mut f_old_custom_menu = None;
        let mut f_description = None;
        let mut f_old_description = None;
        let mut f_help = None;
        let mut f_old_help = None;
        let mut f_status_bar = None;
        let mut f_old_status_bar = None;
        let mut f_comment = None;
        let mut f_old_comment = None;
        let mut f_formula = None;
        let mut f_old_formula = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"rId" => {
                    f_r_id = val.parse().ok();
                }
                b"ua" => {
                    f_ua = Some(val == "true" || val == "1");
                }
                b"ra" => {
                    f_ra = Some(val == "true" || val == "1");
                }
                b"localSheetId" => {
                    f_local_sheet_id = val.parse().ok();
                }
                b"customView" => {
                    f_custom_view = Some(val == "true" || val == "1");
                }
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"function" => {
                    f_function = Some(val == "true" || val == "1");
                }
                b"oldFunction" => {
                    f_old_function = Some(val == "true" || val == "1");
                }
                b"functionGroupId" => {
                    f_function_group_id = val.parse().ok();
                }
                b"oldFunctionGroupId" => {
                    f_old_function_group_id = val.parse().ok();
                }
                b"shortcutKey" => {
                    f_shortcut_key = val.parse().ok();
                }
                b"oldShortcutKey" => {
                    f_old_shortcut_key = val.parse().ok();
                }
                b"hidden" => {
                    f_hidden = Some(val == "true" || val == "1");
                }
                b"oldHidden" => {
                    f_old_hidden = Some(val == "true" || val == "1");
                }
                b"customMenu" => {
                    f_custom_menu = Some(val.into_owned());
                }
                b"oldCustomMenu" => {
                    f_old_custom_menu = Some(val.into_owned());
                }
                b"description" => {
                    f_description = Some(val.into_owned());
                }
                b"oldDescription" => {
                    f_old_description = Some(val.into_owned());
                }
                b"help" => {
                    f_help = Some(val.into_owned());
                }
                b"oldHelp" => {
                    f_old_help = Some(val.into_owned());
                }
                b"statusBar" => {
                    f_status_bar = Some(val.into_owned());
                }
                b"oldStatusBar" => {
                    f_old_status_bar = Some(val.into_owned());
                }
                b"comment" => {
                    f_comment = Some(val.into_owned());
                }
                b"oldComment" => {
                    f_old_comment = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"formula" => {
                                f_formula = Some(read_text_content(reader)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"oldFormula" => {
                                f_old_formula = Some(read_text_content(reader)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"formula" => {
                                f_formula = Some(String::new());
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"oldFormula" => {
                                f_old_formula = Some(String::new());
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r_id: f_r_id.ok_or_else(|| ParseError::MissingAttribute("rId".to_string()))?,
            ua: f_ua,
            ra: f_ra,
            local_sheet_id: f_local_sheet_id,
            custom_view: f_custom_view,
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            function: f_function,
            old_function: f_old_function,
            function_group_id: f_function_group_id,
            old_function_group_id: f_old_function_group_id,
            shortcut_key: f_shortcut_key,
            old_shortcut_key: f_old_shortcut_key,
            hidden: f_hidden,
            old_hidden: f_old_hidden,
            custom_menu: f_custom_menu,
            old_custom_menu: f_old_custom_menu,
            description: f_description,
            old_description: f_old_description,
            help: f_help,
            old_help: f_old_help,
            status_bar: f_status_bar,
            old_status_bar: f_old_status_bar,
            comment: f_comment,
            old_comment: f_old_comment,
            formula: f_formula,
            old_formula: f_old_formula,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for RevisionConflict {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_r_id: Option<u32> = None;
        let mut f_ua = None;
        let mut f_ra = None;
        let mut f_sheet_id = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"rId" => {
                    f_r_id = val.parse().ok();
                }
                b"ua" => {
                    f_ua = Some(val == "true" || val == "1");
                }
                b"ra" => {
                    f_ra = Some(val == "true" || val == "1");
                }
                b"sheetId" => {
                    f_sheet_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r_id: f_r_id.ok_or_else(|| ParseError::MissingAttribute("rId".to_string()))?,
            ua: f_ua,
            ra: f_ra,
            sheet_id: f_sheet_id,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for RevisionQueryTableField {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_sheet_id: Option<u32> = None;
        let mut f_reference: Option<Reference> = None;
        let mut f_field_id: Option<u32> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"sheetId" => {
                    f_sheet_id = val.parse().ok();
                }
                b"ref" => {
                    f_reference = Some(val.into_owned());
                }
                b"fieldId" => {
                    f_field_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            sheet_id: f_sheet_id
                .ok_or_else(|| ParseError::MissingAttribute("sheetId".to_string()))?,
            reference: f_reference
                .ok_or_else(|| ParseError::MissingAttribute("ref".to_string()))?,
            field_id: f_field_id
                .ok_or_else(|| ParseError::MissingAttribute("fieldId".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for Users {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_user_info = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"userInfo" => {
                                f_user_info.push(SharedUser::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"userInfo" => {
                                f_user_info.push(SharedUser::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            user_info: f_user_info,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for SharedUser {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_guid: Option<Guid> = None;
        let mut f_name: Option<XmlString> = None;
        let mut f_id: Option<i32> = None;
        let mut f_date_time: Option<String> = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"guid" => {
                    f_guid = Some(val.into_owned());
                }
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"dateTime" => {
                    f_date_time = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            guid: f_guid.ok_or_else(|| ParseError::MissingAttribute("guid".to_string()))?,
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            date_time: f_date_time
                .ok_or_else(|| ParseError::MissingAttribute("dateTime".to_string()))?,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTMacrosheet {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_sheet_properties = None;
        let mut f_dimension = None;
        let mut f_sheet_views = None;
        let mut f_sheet_format = None;
        let mut f_cols = Vec::new();
        let mut f_sheet_data: Option<Box<SheetData>> = None;
        let mut f_sheet_protection = None;
        let mut f_auto_filter = None;
        let mut f_sort_state = None;
        let mut f_data_consolidate = None;
        let mut f_custom_sheet_views = None;
        let mut f_phonetic_pr = None;
        let mut f_conditional_formatting = Vec::new();
        let mut f_print_options = None;
        let mut f_page_margins = None;
        let mut f_page_setup = None;
        let mut f_header_footer = None;
        let mut f_row_breaks = None;
        let mut f_col_breaks = None;
        let mut f_custom_properties = None;
        let mut f_drawing = None;
        let mut f_legacy_drawing = None;
        let mut f_legacy_drawing_h_f = None;
        let mut f_drawing_h_f = None;
        let mut f_picture = None;
        let mut f_ole_objects = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"sheetPr" => {
                                f_sheet_properties =
                                    Some(Box::new(SheetProperties::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dimension" => {
                                f_dimension =
                                    Some(Box::new(SheetDimension::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sheetViews" => {
                                f_sheet_views =
                                    Some(Box::new(SheetViews::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sheetFormatPr" => {
                                f_sheet_format =
                                    Some(Box::new(SheetFormat::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cols" => {
                                f_cols.push(Columns::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sheetData" => {
                                f_sheet_data =
                                    Some(Box::new(SheetData::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sheetProtection" => {
                                f_sheet_protection =
                                    Some(Box::new(SheetProtection::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"autoFilter" => {
                                f_auto_filter =
                                    Some(Box::new(AutoFilter::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sortState" => {
                                f_sort_state =
                                    Some(Box::new(SortState::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dataConsolidate" => {
                                f_data_consolidate =
                                    Some(Box::new(CTDataConsolidate::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"customSheetViews" => {
                                f_custom_sheet_views =
                                    Some(Box::new(CustomSheetViews::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"phoneticPr" => {
                                f_phonetic_pr = Some(Box::new(PhoneticProperties::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"conditionalFormatting" => {
                                f_conditional_formatting
                                    .push(ConditionalFormatting::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"printOptions" => {
                                f_print_options =
                                    Some(Box::new(PrintOptions::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pageMargins" => {
                                f_page_margins =
                                    Some(Box::new(PageMargins::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pageSetup" => {
                                f_page_setup =
                                    Some(Box::new(PageSetup::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"headerFooter" => {
                                f_header_footer =
                                    Some(Box::new(HeaderFooter::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rowBreaks" => {
                                f_row_breaks =
                                    Some(Box::new(PageBreaks::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"colBreaks" => {
                                f_col_breaks =
                                    Some(Box::new(PageBreaks::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"customProperties" => {
                                f_custom_properties = Some(Box::new(CTCustomProperties::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"drawing" => {
                                f_drawing = Some(Box::new(Drawing::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"legacyDrawing" => {
                                f_legacy_drawing =
                                    Some(Box::new(LegacyDrawing::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"legacyDrawingHF" => {
                                f_legacy_drawing_h_f =
                                    Some(Box::new(LegacyDrawing::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"drawingHF" => {
                                f_drawing_h_f = Some(Box::new(DrawingHeaderFooter::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"picture" => {
                                f_picture = Some(Box::new(SheetBackgroundPicture::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"oleObjects" => {
                                f_ole_objects =
                                    Some(Box::new(OleObjects::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"sheetPr" => {
                                f_sheet_properties =
                                    Some(Box::new(SheetProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dimension" => {
                                f_dimension =
                                    Some(Box::new(SheetDimension::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sheetViews" => {
                                f_sheet_views =
                                    Some(Box::new(SheetViews::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sheetFormatPr" => {
                                f_sheet_format =
                                    Some(Box::new(SheetFormat::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cols" => {
                                f_cols.push(Columns::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sheetData" => {
                                f_sheet_data =
                                    Some(Box::new(SheetData::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sheetProtection" => {
                                f_sheet_protection =
                                    Some(Box::new(SheetProtection::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"autoFilter" => {
                                f_auto_filter =
                                    Some(Box::new(AutoFilter::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sortState" => {
                                f_sort_state =
                                    Some(Box::new(SortState::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dataConsolidate" => {
                                f_data_consolidate =
                                    Some(Box::new(CTDataConsolidate::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"customSheetViews" => {
                                f_custom_sheet_views =
                                    Some(Box::new(CustomSheetViews::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"phoneticPr" => {
                                f_phonetic_pr =
                                    Some(Box::new(PhoneticProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"conditionalFormatting" => {
                                f_conditional_formatting
                                    .push(ConditionalFormatting::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"printOptions" => {
                                f_print_options =
                                    Some(Box::new(PrintOptions::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pageMargins" => {
                                f_page_margins =
                                    Some(Box::new(PageMargins::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pageSetup" => {
                                f_page_setup =
                                    Some(Box::new(PageSetup::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"headerFooter" => {
                                f_header_footer =
                                    Some(Box::new(HeaderFooter::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rowBreaks" => {
                                f_row_breaks =
                                    Some(Box::new(PageBreaks::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"colBreaks" => {
                                f_col_breaks =
                                    Some(Box::new(PageBreaks::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"customProperties" => {
                                f_custom_properties =
                                    Some(Box::new(CTCustomProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"drawing" => {
                                f_drawing = Some(Box::new(Drawing::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"legacyDrawing" => {
                                f_legacy_drawing =
                                    Some(Box::new(LegacyDrawing::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"legacyDrawingHF" => {
                                f_legacy_drawing_h_f =
                                    Some(Box::new(LegacyDrawing::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"drawingHF" => {
                                f_drawing_h_f = Some(Box::new(DrawingHeaderFooter::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"picture" => {
                                f_picture = Some(Box::new(SheetBackgroundPicture::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"oleObjects" => {
                                f_ole_objects =
                                    Some(Box::new(OleObjects::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            sheet_properties: f_sheet_properties,
            dimension: f_dimension,
            sheet_views: f_sheet_views,
            sheet_format: f_sheet_format,
            cols: f_cols,
            sheet_data: f_sheet_data
                .ok_or_else(|| ParseError::MissingAttribute("sheetData".to_string()))?,
            sheet_protection: f_sheet_protection,
            auto_filter: f_auto_filter,
            sort_state: f_sort_state,
            data_consolidate: f_data_consolidate,
            custom_sheet_views: f_custom_sheet_views,
            phonetic_pr: f_phonetic_pr,
            conditional_formatting: f_conditional_formatting,
            print_options: f_print_options,
            page_margins: f_page_margins,
            page_setup: f_page_setup,
            header_footer: f_header_footer,
            row_breaks: f_row_breaks,
            col_breaks: f_col_breaks,
            custom_properties: f_custom_properties,
            drawing: f_drawing,
            legacy_drawing: f_legacy_drawing,
            legacy_drawing_h_f: f_legacy_drawing_h_f,
            drawing_h_f: f_drawing_h_f,
            picture: f_picture,
            ole_objects: f_ole_objects,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTDialogsheet {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_sheet_properties = None;
        let mut f_sheet_views = None;
        let mut f_sheet_format = None;
        let mut f_sheet_protection = None;
        let mut f_custom_sheet_views = None;
        let mut f_print_options = None;
        let mut f_page_margins = None;
        let mut f_page_setup = None;
        let mut f_header_footer = None;
        let mut f_drawing = None;
        let mut f_legacy_drawing = None;
        let mut f_legacy_drawing_h_f = None;
        let mut f_drawing_h_f = None;
        let mut f_ole_objects = None;
        let mut f_controls = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"sheetPr" => {
                                f_sheet_properties =
                                    Some(Box::new(SheetProperties::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sheetViews" => {
                                f_sheet_views =
                                    Some(Box::new(SheetViews::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sheetFormatPr" => {
                                f_sheet_format =
                                    Some(Box::new(SheetFormat::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sheetProtection" => {
                                f_sheet_protection =
                                    Some(Box::new(SheetProtection::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"customSheetViews" => {
                                f_custom_sheet_views =
                                    Some(Box::new(CustomSheetViews::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"printOptions" => {
                                f_print_options =
                                    Some(Box::new(PrintOptions::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pageMargins" => {
                                f_page_margins =
                                    Some(Box::new(PageMargins::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pageSetup" => {
                                f_page_setup =
                                    Some(Box::new(PageSetup::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"headerFooter" => {
                                f_header_footer =
                                    Some(Box::new(HeaderFooter::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"drawing" => {
                                f_drawing = Some(Box::new(Drawing::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"legacyDrawing" => {
                                f_legacy_drawing =
                                    Some(Box::new(LegacyDrawing::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"legacyDrawingHF" => {
                                f_legacy_drawing_h_f =
                                    Some(Box::new(LegacyDrawing::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"drawingHF" => {
                                f_drawing_h_f = Some(Box::new(DrawingHeaderFooter::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"oleObjects" => {
                                f_ole_objects =
                                    Some(Box::new(OleObjects::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"controls" => {
                                f_controls = Some(Box::new(Controls::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"sheetPr" => {
                                f_sheet_properties =
                                    Some(Box::new(SheetProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sheetViews" => {
                                f_sheet_views =
                                    Some(Box::new(SheetViews::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sheetFormatPr" => {
                                f_sheet_format =
                                    Some(Box::new(SheetFormat::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sheetProtection" => {
                                f_sheet_protection =
                                    Some(Box::new(SheetProtection::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"customSheetViews" => {
                                f_custom_sheet_views =
                                    Some(Box::new(CustomSheetViews::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"printOptions" => {
                                f_print_options =
                                    Some(Box::new(PrintOptions::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pageMargins" => {
                                f_page_margins =
                                    Some(Box::new(PageMargins::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pageSetup" => {
                                f_page_setup =
                                    Some(Box::new(PageSetup::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"headerFooter" => {
                                f_header_footer =
                                    Some(Box::new(HeaderFooter::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"drawing" => {
                                f_drawing = Some(Box::new(Drawing::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"legacyDrawing" => {
                                f_legacy_drawing =
                                    Some(Box::new(LegacyDrawing::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"legacyDrawingHF" => {
                                f_legacy_drawing_h_f =
                                    Some(Box::new(LegacyDrawing::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"drawingHF" => {
                                f_drawing_h_f = Some(Box::new(DrawingHeaderFooter::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"oleObjects" => {
                                f_ole_objects =
                                    Some(Box::new(OleObjects::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"controls" => {
                                f_controls = Some(Box::new(Controls::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            sheet_properties: f_sheet_properties,
            sheet_views: f_sheet_views,
            sheet_format: f_sheet_format,
            sheet_protection: f_sheet_protection,
            custom_sheet_views: f_custom_sheet_views,
            print_options: f_print_options,
            page_margins: f_page_margins,
            page_setup: f_page_setup,
            header_footer: f_header_footer,
            drawing: f_drawing,
            legacy_drawing: f_legacy_drawing,
            legacy_drawing_h_f: f_legacy_drawing_h_f,
            drawing_h_f: f_drawing_h_f,
            ole_objects: f_ole_objects,
            controls: f_controls,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Worksheet {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "sml-styling")]
        let mut f_sheet_properties = None;
        let mut f_dimension = None;
        let mut f_sheet_views = None;
        #[cfg(feature = "sml-styling")]
        let mut f_sheet_format = None;
        #[cfg(feature = "sml-styling")]
        let mut f_cols = Vec::new();
        let mut f_sheet_data: Option<Box<SheetData>> = None;
        #[cfg(feature = "sml-formulas")]
        let mut f_sheet_calc_pr = None;
        #[cfg(feature = "sml-protection")]
        let mut f_sheet_protection = None;
        #[cfg(feature = "sml-protection")]
        let mut f_protected_ranges = None;
        #[cfg(feature = "sml-formulas-advanced")]
        let mut f_scenarios = None;
        #[cfg(feature = "sml-filtering")]
        let mut f_auto_filter = None;
        #[cfg(feature = "sml-filtering")]
        let mut f_sort_state = None;
        #[cfg(feature = "sml-formulas-advanced")]
        let mut f_data_consolidate = None;
        #[cfg(feature = "sml-structure")]
        let mut f_custom_sheet_views = None;
        let mut f_merged_cells = None;
        #[cfg(feature = "sml-i18n")]
        let mut f_phonetic_pr = None;
        #[cfg(feature = "sml-styling")]
        let mut f_conditional_formatting = Vec::new();
        #[cfg(feature = "sml-validation")]
        let mut f_data_validations = None;
        #[cfg(feature = "sml-hyperlinks")]
        let mut f_hyperlinks = None;
        #[cfg(feature = "sml-layout")]
        let mut f_print_options = None;
        #[cfg(feature = "sml-layout")]
        let mut f_page_margins = None;
        #[cfg(feature = "sml-layout")]
        let mut f_page_setup = None;
        #[cfg(feature = "sml-layout")]
        let mut f_header_footer = None;
        #[cfg(feature = "sml-layout")]
        let mut f_row_breaks = None;
        #[cfg(feature = "sml-layout")]
        let mut f_col_breaks = None;
        #[cfg(feature = "sml-metadata")]
        let mut f_custom_properties = None;
        #[cfg(feature = "sml-formulas-advanced")]
        let mut f_cell_watches = None;
        #[cfg(feature = "sml-validation")]
        let mut f_ignored_errors = None;
        #[cfg(feature = "sml-metadata")]
        let mut f_smart_tags = None;
        #[cfg(feature = "sml-drawings")]
        let mut f_drawing = None;
        #[cfg(feature = "sml-comments")]
        let mut f_legacy_drawing = None;
        #[cfg(feature = "sml-layout")]
        let mut f_legacy_drawing_h_f = None;
        #[cfg(feature = "sml-drawings")]
        let mut f_drawing_h_f = None;
        #[cfg(feature = "sml-drawings")]
        let mut f_picture = None;
        #[cfg(feature = "sml-external")]
        let mut f_ole_objects = None;
        #[cfg(feature = "sml-external")]
        let mut f_controls = None;
        #[cfg(feature = "sml-external")]
        let mut f_web_publish_items = None;
        #[cfg(feature = "sml-tables")]
        let mut f_table_parts = None;
        #[cfg(feature = "sml-extensions")]
        let mut f_extension_list = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "sml-styling")]
                            b"sheetPr" => {
                                f_sheet_properties =
                                    Some(Box::new(SheetProperties::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dimension" => {
                                f_dimension =
                                    Some(Box::new(SheetDimension::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sheetViews" => {
                                f_sheet_views =
                                    Some(Box::new(SheetViews::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"sheetFormatPr" => {
                                f_sheet_format =
                                    Some(Box::new(SheetFormat::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"cols" => {
                                f_cols.push(Columns::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sheetData" => {
                                f_sheet_data =
                                    Some(Box::new(SheetData::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-formulas")]
                            b"sheetCalcPr" => {
                                f_sheet_calc_pr = Some(Box::new(SheetCalcProperties::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-protection")]
                            b"sheetProtection" => {
                                f_sheet_protection =
                                    Some(Box::new(SheetProtection::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-protection")]
                            b"protectedRanges" => {
                                f_protected_ranges =
                                    Some(Box::new(ProtectedRanges::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-formulas-advanced")]
                            b"scenarios" => {
                                f_scenarios =
                                    Some(Box::new(Scenarios::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-filtering")]
                            b"autoFilter" => {
                                f_auto_filter =
                                    Some(Box::new(AutoFilter::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-filtering")]
                            b"sortState" => {
                                f_sort_state =
                                    Some(Box::new(SortState::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-formulas-advanced")]
                            b"dataConsolidate" => {
                                f_data_consolidate =
                                    Some(Box::new(CTDataConsolidate::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-structure")]
                            b"customSheetViews" => {
                                f_custom_sheet_views =
                                    Some(Box::new(CustomSheetViews::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"mergeCells" => {
                                f_merged_cells =
                                    Some(Box::new(MergedCells::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-i18n")]
                            b"phoneticPr" => {
                                f_phonetic_pr = Some(Box::new(PhoneticProperties::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"conditionalFormatting" => {
                                f_conditional_formatting
                                    .push(ConditionalFormatting::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-validation")]
                            b"dataValidations" => {
                                f_data_validations =
                                    Some(Box::new(DataValidations::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-hyperlinks")]
                            b"hyperlinks" => {
                                f_hyperlinks =
                                    Some(Box::new(Hyperlinks::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-layout")]
                            b"printOptions" => {
                                f_print_options =
                                    Some(Box::new(PrintOptions::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-layout")]
                            b"pageMargins" => {
                                f_page_margins =
                                    Some(Box::new(PageMargins::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-layout")]
                            b"pageSetup" => {
                                f_page_setup =
                                    Some(Box::new(PageSetup::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-layout")]
                            b"headerFooter" => {
                                f_header_footer =
                                    Some(Box::new(HeaderFooter::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-layout")]
                            b"rowBreaks" => {
                                f_row_breaks =
                                    Some(Box::new(PageBreaks::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-layout")]
                            b"colBreaks" => {
                                f_col_breaks =
                                    Some(Box::new(PageBreaks::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-metadata")]
                            b"customProperties" => {
                                f_custom_properties = Some(Box::new(CTCustomProperties::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-formulas-advanced")]
                            b"cellWatches" => {
                                f_cell_watches =
                                    Some(Box::new(CellWatches::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-validation")]
                            b"ignoredErrors" => {
                                f_ignored_errors =
                                    Some(Box::new(IgnoredErrors::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-metadata")]
                            b"smartTags" => {
                                f_smart_tags =
                                    Some(Box::new(SmartTags::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-drawings")]
                            b"drawing" => {
                                f_drawing = Some(Box::new(Drawing::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-comments")]
                            b"legacyDrawing" => {
                                f_legacy_drawing =
                                    Some(Box::new(LegacyDrawing::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-layout")]
                            b"legacyDrawingHF" => {
                                f_legacy_drawing_h_f =
                                    Some(Box::new(LegacyDrawing::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-drawings")]
                            b"drawingHF" => {
                                f_drawing_h_f = Some(Box::new(DrawingHeaderFooter::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-drawings")]
                            b"picture" => {
                                f_picture = Some(Box::new(SheetBackgroundPicture::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-external")]
                            b"oleObjects" => {
                                f_ole_objects =
                                    Some(Box::new(OleObjects::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-external")]
                            b"controls" => {
                                f_controls = Some(Box::new(Controls::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-external")]
                            b"webPublishItems" => {
                                f_web_publish_items =
                                    Some(Box::new(WebPublishItems::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-tables")]
                            b"tableParts" => {
                                f_table_parts =
                                    Some(Box::new(TableParts::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-extensions")]
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "sml-styling")]
                            b"sheetPr" => {
                                f_sheet_properties =
                                    Some(Box::new(SheetProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"dimension" => {
                                f_dimension =
                                    Some(Box::new(SheetDimension::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sheetViews" => {
                                f_sheet_views =
                                    Some(Box::new(SheetViews::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"sheetFormatPr" => {
                                f_sheet_format =
                                    Some(Box::new(SheetFormat::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"cols" => {
                                f_cols.push(Columns::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sheetData" => {
                                f_sheet_data =
                                    Some(Box::new(SheetData::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-formulas")]
                            b"sheetCalcPr" => {
                                f_sheet_calc_pr = Some(Box::new(SheetCalcProperties::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-protection")]
                            b"sheetProtection" => {
                                f_sheet_protection =
                                    Some(Box::new(SheetProtection::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-protection")]
                            b"protectedRanges" => {
                                f_protected_ranges =
                                    Some(Box::new(ProtectedRanges::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-formulas-advanced")]
                            b"scenarios" => {
                                f_scenarios =
                                    Some(Box::new(Scenarios::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-filtering")]
                            b"autoFilter" => {
                                f_auto_filter =
                                    Some(Box::new(AutoFilter::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-filtering")]
                            b"sortState" => {
                                f_sort_state =
                                    Some(Box::new(SortState::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-formulas-advanced")]
                            b"dataConsolidate" => {
                                f_data_consolidate =
                                    Some(Box::new(CTDataConsolidate::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-structure")]
                            b"customSheetViews" => {
                                f_custom_sheet_views =
                                    Some(Box::new(CustomSheetViews::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"mergeCells" => {
                                f_merged_cells =
                                    Some(Box::new(MergedCells::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-i18n")]
                            b"phoneticPr" => {
                                f_phonetic_pr =
                                    Some(Box::new(PhoneticProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"conditionalFormatting" => {
                                f_conditional_formatting
                                    .push(ConditionalFormatting::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-validation")]
                            b"dataValidations" => {
                                f_data_validations =
                                    Some(Box::new(DataValidations::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-hyperlinks")]
                            b"hyperlinks" => {
                                f_hyperlinks =
                                    Some(Box::new(Hyperlinks::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-layout")]
                            b"printOptions" => {
                                f_print_options =
                                    Some(Box::new(PrintOptions::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-layout")]
                            b"pageMargins" => {
                                f_page_margins =
                                    Some(Box::new(PageMargins::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-layout")]
                            b"pageSetup" => {
                                f_page_setup =
                                    Some(Box::new(PageSetup::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-layout")]
                            b"headerFooter" => {
                                f_header_footer =
                                    Some(Box::new(HeaderFooter::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-layout")]
                            b"rowBreaks" => {
                                f_row_breaks =
                                    Some(Box::new(PageBreaks::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-layout")]
                            b"colBreaks" => {
                                f_col_breaks =
                                    Some(Box::new(PageBreaks::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-metadata")]
                            b"customProperties" => {
                                f_custom_properties =
                                    Some(Box::new(CTCustomProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-formulas-advanced")]
                            b"cellWatches" => {
                                f_cell_watches =
                                    Some(Box::new(CellWatches::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-validation")]
                            b"ignoredErrors" => {
                                f_ignored_errors =
                                    Some(Box::new(IgnoredErrors::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-metadata")]
                            b"smartTags" => {
                                f_smart_tags =
                                    Some(Box::new(SmartTags::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-drawings")]
                            b"drawing" => {
                                f_drawing = Some(Box::new(Drawing::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-comments")]
                            b"legacyDrawing" => {
                                f_legacy_drawing =
                                    Some(Box::new(LegacyDrawing::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-layout")]
                            b"legacyDrawingHF" => {
                                f_legacy_drawing_h_f =
                                    Some(Box::new(LegacyDrawing::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-drawings")]
                            b"drawingHF" => {
                                f_drawing_h_f = Some(Box::new(DrawingHeaderFooter::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-drawings")]
                            b"picture" => {
                                f_picture = Some(Box::new(SheetBackgroundPicture::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-external")]
                            b"oleObjects" => {
                                f_ole_objects =
                                    Some(Box::new(OleObjects::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-external")]
                            b"controls" => {
                                f_controls = Some(Box::new(Controls::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-external")]
                            b"webPublishItems" => {
                                f_web_publish_items =
                                    Some(Box::new(WebPublishItems::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-tables")]
                            b"tableParts" => {
                                f_table_parts =
                                    Some(Box::new(TableParts::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-extensions")]
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            #[cfg(feature = "sml-styling")]
            sheet_properties: f_sheet_properties,
            dimension: f_dimension,
            sheet_views: f_sheet_views,
            #[cfg(feature = "sml-styling")]
            sheet_format: f_sheet_format,
            #[cfg(feature = "sml-styling")]
            cols: f_cols,
            sheet_data: f_sheet_data
                .ok_or_else(|| ParseError::MissingAttribute("sheetData".to_string()))?,
            #[cfg(feature = "sml-formulas")]
            sheet_calc_pr: f_sheet_calc_pr,
            #[cfg(feature = "sml-protection")]
            sheet_protection: f_sheet_protection,
            #[cfg(feature = "sml-protection")]
            protected_ranges: f_protected_ranges,
            #[cfg(feature = "sml-formulas-advanced")]
            scenarios: f_scenarios,
            #[cfg(feature = "sml-filtering")]
            auto_filter: f_auto_filter,
            #[cfg(feature = "sml-filtering")]
            sort_state: f_sort_state,
            #[cfg(feature = "sml-formulas-advanced")]
            data_consolidate: f_data_consolidate,
            #[cfg(feature = "sml-structure")]
            custom_sheet_views: f_custom_sheet_views,
            merged_cells: f_merged_cells,
            #[cfg(feature = "sml-i18n")]
            phonetic_pr: f_phonetic_pr,
            #[cfg(feature = "sml-styling")]
            conditional_formatting: f_conditional_formatting,
            #[cfg(feature = "sml-validation")]
            data_validations: f_data_validations,
            #[cfg(feature = "sml-hyperlinks")]
            hyperlinks: f_hyperlinks,
            #[cfg(feature = "sml-layout")]
            print_options: f_print_options,
            #[cfg(feature = "sml-layout")]
            page_margins: f_page_margins,
            #[cfg(feature = "sml-layout")]
            page_setup: f_page_setup,
            #[cfg(feature = "sml-layout")]
            header_footer: f_header_footer,
            #[cfg(feature = "sml-layout")]
            row_breaks: f_row_breaks,
            #[cfg(feature = "sml-layout")]
            col_breaks: f_col_breaks,
            #[cfg(feature = "sml-metadata")]
            custom_properties: f_custom_properties,
            #[cfg(feature = "sml-formulas-advanced")]
            cell_watches: f_cell_watches,
            #[cfg(feature = "sml-validation")]
            ignored_errors: f_ignored_errors,
            #[cfg(feature = "sml-metadata")]
            smart_tags: f_smart_tags,
            #[cfg(feature = "sml-drawings")]
            drawing: f_drawing,
            #[cfg(feature = "sml-comments")]
            legacy_drawing: f_legacy_drawing,
            #[cfg(feature = "sml-layout")]
            legacy_drawing_h_f: f_legacy_drawing_h_f,
            #[cfg(feature = "sml-drawings")]
            drawing_h_f: f_drawing_h_f,
            #[cfg(feature = "sml-drawings")]
            picture: f_picture,
            #[cfg(feature = "sml-external")]
            ole_objects: f_ole_objects,
            #[cfg(feature = "sml-external")]
            controls: f_controls,
            #[cfg(feature = "sml-external")]
            web_publish_items: f_web_publish_items,
            #[cfg(feature = "sml-tables")]
            table_parts: f_table_parts,
            #[cfg(feature = "sml-extensions")]
            extension_list: f_extension_list,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for SheetData {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_row = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"row" => {
                                f_row.push(Row::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"row" => {
                                f_row.push(Row::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            row: f_row,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for SheetCalcProperties {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_full_calc_on_load = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"fullCalcOnLoad" => {
                    f_full_calc_on_load = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            full_calc_on_load: f_full_calc_on_load,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for SheetFormat {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_base_col_width = None;
        let mut f_default_col_width = None;
        let mut f_default_row_height: Option<f64> = None;
        let mut f_custom_height = None;
        let mut f_zero_height = None;
        let mut f_thick_top = None;
        let mut f_thick_bottom = None;
        let mut f_outline_level_row = None;
        let mut f_outline_level_col = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"baseColWidth" => {
                    f_base_col_width = val.parse().ok();
                }
                b"defaultColWidth" => {
                    f_default_col_width = val.parse().ok();
                }
                b"defaultRowHeight" => {
                    f_default_row_height = val.parse().ok();
                }
                b"customHeight" => {
                    f_custom_height = Some(val == "true" || val == "1");
                }
                b"zeroHeight" => {
                    f_zero_height = Some(val == "true" || val == "1");
                }
                b"thickTop" => {
                    f_thick_top = Some(val == "true" || val == "1");
                }
                b"thickBottom" => {
                    f_thick_bottom = Some(val == "true" || val == "1");
                }
                b"outlineLevelRow" => {
                    f_outline_level_row = val.parse().ok();
                }
                b"outlineLevelCol" => {
                    f_outline_level_col = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            base_col_width: f_base_col_width,
            default_col_width: f_default_col_width,
            default_row_height: f_default_row_height
                .ok_or_else(|| ParseError::MissingAttribute("defaultRowHeight".to_string()))?,
            custom_height: f_custom_height,
            zero_height: f_zero_height,
            thick_top: f_thick_top,
            thick_bottom: f_thick_bottom,
            outline_level_row: f_outline_level_row,
            outline_level_col: f_outline_level_col,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for Columns {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_col = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"col" => {
                                f_col.push(Column::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"col" => {
                                f_col.push(Column::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            col: f_col,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Column {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "sml-styling")]
        let mut f_start_column: Option<u32> = None;
        #[cfg(feature = "sml-styling")]
        let mut f_end_column: Option<u32> = None;
        #[cfg(feature = "sml-styling")]
        let mut f_width = None;
        #[cfg(feature = "sml-styling")]
        let mut f_style = None;
        #[cfg(feature = "sml-structure")]
        let mut f_hidden = None;
        #[cfg(feature = "sml-styling")]
        let mut f_best_fit = None;
        #[cfg(feature = "sml-styling")]
        let mut f_custom_width = None;
        #[cfg(feature = "sml-i18n")]
        let mut f_phonetic = None;
        #[cfg(feature = "sml-structure")]
        let mut f_outline_level = None;
        #[cfg(feature = "sml-structure")]
        let mut f_collapsed = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                #[cfg(feature = "sml-styling")]
                b"min" => {
                    f_start_column = val.parse().ok();
                }
                #[cfg(feature = "sml-styling")]
                b"max" => {
                    f_end_column = val.parse().ok();
                }
                #[cfg(feature = "sml-styling")]
                b"width" => {
                    f_width = val.parse().ok();
                }
                #[cfg(feature = "sml-styling")]
                b"style" => {
                    f_style = val.parse().ok();
                }
                #[cfg(feature = "sml-structure")]
                b"hidden" => {
                    f_hidden = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-styling")]
                b"bestFit" => {
                    f_best_fit = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-styling")]
                b"customWidth" => {
                    f_custom_width = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-i18n")]
                b"phonetic" => {
                    f_phonetic = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-structure")]
                b"outlineLevel" => {
                    f_outline_level = val.parse().ok();
                }
                #[cfg(feature = "sml-structure")]
                b"collapsed" => {
                    f_collapsed = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            #[cfg(feature = "sml-styling")]
            start_column: f_start_column
                .ok_or_else(|| ParseError::MissingAttribute("min".to_string()))?,
            #[cfg(feature = "sml-styling")]
            end_column: f_end_column
                .ok_or_else(|| ParseError::MissingAttribute("max".to_string()))?,
            #[cfg(feature = "sml-styling")]
            width: f_width,
            #[cfg(feature = "sml-styling")]
            style: f_style,
            #[cfg(feature = "sml-structure")]
            hidden: f_hidden,
            #[cfg(feature = "sml-styling")]
            best_fit: f_best_fit,
            #[cfg(feature = "sml-styling")]
            custom_width: f_custom_width,
            #[cfg(feature = "sml-i18n")]
            phonetic: f_phonetic,
            #[cfg(feature = "sml-structure")]
            outline_level: f_outline_level,
            #[cfg(feature = "sml-structure")]
            collapsed: f_collapsed,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for Row {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_reference = None;
        let mut f_cell_spans = None;
        let mut f_style_index = None;
        #[cfg(feature = "sml-styling")]
        let mut f_custom_format = None;
        #[cfg(feature = "sml-styling")]
        let mut f_height = None;
        #[cfg(feature = "sml-structure")]
        let mut f_hidden = None;
        #[cfg(feature = "sml-styling")]
        let mut f_custom_height = None;
        #[cfg(feature = "sml-structure")]
        let mut f_outline_level = None;
        #[cfg(feature = "sml-structure")]
        let mut f_collapsed = None;
        #[cfg(feature = "sml-styling")]
        let mut f_thick_top = None;
        #[cfg(feature = "sml-styling")]
        let mut f_thick_bot = None;
        #[cfg(feature = "sml-i18n")]
        let mut f_placeholder = None;
        let mut f_cells = Vec::new();
        #[cfg(feature = "sml-extensions")]
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"r" => {
                    f_reference = val.parse().ok();
                }
                b"spans" => {
                    f_cell_spans = Some(val.into_owned());
                }
                b"s" => {
                    f_style_index = val.parse().ok();
                }
                #[cfg(feature = "sml-styling")]
                b"customFormat" => {
                    f_custom_format = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-styling")]
                b"ht" => {
                    f_height = val.parse().ok();
                }
                #[cfg(feature = "sml-structure")]
                b"hidden" => {
                    f_hidden = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-styling")]
                b"customHeight" => {
                    f_custom_height = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-structure")]
                b"outlineLevel" => {
                    f_outline_level = val.parse().ok();
                }
                #[cfg(feature = "sml-structure")]
                b"collapsed" => {
                    f_collapsed = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-styling")]
                b"thickTop" => {
                    f_thick_top = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-styling")]
                b"thickBot" => {
                    f_thick_bot = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-i18n")]
                b"ph" => {
                    f_placeholder = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"c" => {
                                f_cells.push(Cell::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-extensions")]
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"c" => {
                                f_cells.push(Cell::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-extensions")]
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            reference: f_reference,
            cell_spans: f_cell_spans,
            style_index: f_style_index,
            #[cfg(feature = "sml-styling")]
            custom_format: f_custom_format,
            #[cfg(feature = "sml-styling")]
            height: f_height,
            #[cfg(feature = "sml-structure")]
            hidden: f_hidden,
            #[cfg(feature = "sml-styling")]
            custom_height: f_custom_height,
            #[cfg(feature = "sml-structure")]
            outline_level: f_outline_level,
            #[cfg(feature = "sml-structure")]
            collapsed: f_collapsed,
            #[cfg(feature = "sml-styling")]
            thick_top: f_thick_top,
            #[cfg(feature = "sml-styling")]
            thick_bot: f_thick_bot,
            #[cfg(feature = "sml-i18n")]
            placeholder: f_placeholder,
            cells: f_cells,
            #[cfg(feature = "sml-extensions")]
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Cell {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_reference = None;
        let mut f_style_index = None;
        let mut f_cell_type = None;
        #[cfg(feature = "sml-metadata")]
        let mut f_cm = None;
        #[cfg(feature = "sml-metadata")]
        let mut f_vm = None;
        #[cfg(feature = "sml-i18n")]
        let mut f_placeholder = None;
        let mut f_formula = None;
        let mut f_value = None;
        let mut f_is = None;
        #[cfg(feature = "sml-extensions")]
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"r" => {
                    f_reference = Some(val.into_owned());
                }
                b"s" => {
                    f_style_index = val.parse().ok();
                }
                b"t" => {
                    f_cell_type = val.parse().ok();
                }
                #[cfg(feature = "sml-metadata")]
                b"cm" => {
                    f_cm = val.parse().ok();
                }
                #[cfg(feature = "sml-metadata")]
                b"vm" => {
                    f_vm = val.parse().ok();
                }
                #[cfg(feature = "sml-i18n")]
                b"ph" => {
                    f_placeholder = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"f" => {
                                f_formula =
                                    Some(Box::new(CellFormula::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"v" => {
                                f_value = Some(read_text_content(reader)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"is" => {
                                f_is = Some(Box::new(RichString::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-extensions")]
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"f" => {
                                f_formula =
                                    Some(Box::new(CellFormula::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"v" => {
                                f_value = Some(String::new());
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"is" => {
                                f_is = Some(Box::new(RichString::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-extensions")]
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            reference: f_reference,
            style_index: f_style_index,
            cell_type: f_cell_type,
            #[cfg(feature = "sml-metadata")]
            cm: f_cm,
            #[cfg(feature = "sml-metadata")]
            vm: f_vm,
            #[cfg(feature = "sml-i18n")]
            placeholder: f_placeholder,
            formula: f_formula,
            value: f_value,
            is: f_is,
            #[cfg(feature = "sml-extensions")]
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for SheetProperties {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_sync_horizontal = None;
        let mut f_sync_vertical = None;
        let mut f_sync_ref = None;
        let mut f_transition_evaluation = None;
        let mut f_transition_entry = None;
        let mut f_published = None;
        let mut f_code_name = None;
        let mut f_filter_mode = None;
        let mut f_enable_format_conditions_calculation = None;
        let mut f_tab_color = None;
        let mut f_outline_pr = None;
        let mut f_page_set_up_pr = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"syncHorizontal" => {
                    f_sync_horizontal = Some(val == "true" || val == "1");
                }
                b"syncVertical" => {
                    f_sync_vertical = Some(val == "true" || val == "1");
                }
                b"syncRef" => {
                    f_sync_ref = Some(val.into_owned());
                }
                b"transitionEvaluation" => {
                    f_transition_evaluation = Some(val == "true" || val == "1");
                }
                b"transitionEntry" => {
                    f_transition_entry = Some(val == "true" || val == "1");
                }
                b"published" => {
                    f_published = Some(val == "true" || val == "1");
                }
                b"codeName" => {
                    f_code_name = Some(val.into_owned());
                }
                b"filterMode" => {
                    f_filter_mode = Some(val == "true" || val == "1");
                }
                b"enableFormatConditionsCalculation" => {
                    f_enable_format_conditions_calculation = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"tabColor" => {
                                f_tab_color = Some(Box::new(Color::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"outlinePr" => {
                                f_outline_pr =
                                    Some(Box::new(OutlineProperties::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pageSetUpPr" => {
                                f_page_set_up_pr = Some(Box::new(PageSetupProperties::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"tabColor" => {
                                f_tab_color = Some(Box::new(Color::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"outlinePr" => {
                                f_outline_pr =
                                    Some(Box::new(OutlineProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pageSetUpPr" => {
                                f_page_set_up_pr = Some(Box::new(PageSetupProperties::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            sync_horizontal: f_sync_horizontal,
            sync_vertical: f_sync_vertical,
            sync_ref: f_sync_ref,
            transition_evaluation: f_transition_evaluation,
            transition_entry: f_transition_entry,
            published: f_published,
            code_name: f_code_name,
            filter_mode: f_filter_mode,
            enable_format_conditions_calculation: f_enable_format_conditions_calculation,
            tab_color: f_tab_color,
            outline_pr: f_outline_pr,
            page_set_up_pr: f_page_set_up_pr,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for SheetDimension {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_reference: Option<Reference> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"ref" => {
                    f_reference = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            reference: f_reference
                .ok_or_else(|| ParseError::MissingAttribute("ref".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for SheetViews {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_sheet_view = Vec::new();
        let mut f_extension_list = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"sheetView" => {
                                f_sheet_view.push(SheetView::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"sheetView" => {
                                f_sheet_view.push(SheetView::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            sheet_view: f_sheet_view,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for SheetView {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "sml-protection")]
        let mut f_window_protection = None;
        #[cfg(feature = "sml-formulas")]
        let mut f_show_formulas = None;
        #[cfg(feature = "sml-styling")]
        let mut f_show_grid_lines = None;
        #[cfg(feature = "sml-styling")]
        let mut f_show_row_col_headers = None;
        #[cfg(feature = "sml-styling")]
        let mut f_show_zeros = None;
        #[cfg(feature = "sml-i18n")]
        let mut f_right_to_left = None;
        let mut f_tab_selected = None;
        #[cfg(feature = "sml-layout")]
        let mut f_show_ruler = None;
        #[cfg(feature = "sml-structure")]
        let mut f_show_outline_symbols = None;
        #[cfg(feature = "sml-styling")]
        let mut f_default_grid_color = None;
        #[cfg(feature = "sml-layout")]
        let mut f_show_white_space = None;
        let mut f_view = None;
        let mut f_top_left_cell = None;
        #[cfg(feature = "sml-styling")]
        let mut f_color_id = None;
        let mut f_zoom_scale = None;
        let mut f_zoom_scale_normal = None;
        #[cfg(feature = "sml-layout")]
        let mut f_zoom_scale_sheet_layout_view = None;
        #[cfg(feature = "sml-layout")]
        let mut f_zoom_scale_page_layout_view = None;
        let mut f_workbook_view_id: Option<u32> = None;
        #[cfg(feature = "sml-structure")]
        let mut f_pane = None;
        let mut f_selection = Vec::new();
        #[cfg(feature = "sml-pivot")]
        let mut f_pivot_selection = Vec::new();
        #[cfg(feature = "sml-extensions")]
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                #[cfg(feature = "sml-protection")]
                b"windowProtection" => {
                    f_window_protection = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-formulas")]
                b"showFormulas" => {
                    f_show_formulas = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-styling")]
                b"showGridLines" => {
                    f_show_grid_lines = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-styling")]
                b"showRowColHeaders" => {
                    f_show_row_col_headers = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-styling")]
                b"showZeros" => {
                    f_show_zeros = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-i18n")]
                b"rightToLeft" => {
                    f_right_to_left = Some(val == "true" || val == "1");
                }
                b"tabSelected" => {
                    f_tab_selected = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-layout")]
                b"showRuler" => {
                    f_show_ruler = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-structure")]
                b"showOutlineSymbols" => {
                    f_show_outline_symbols = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-styling")]
                b"defaultGridColor" => {
                    f_default_grid_color = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-layout")]
                b"showWhiteSpace" => {
                    f_show_white_space = Some(val == "true" || val == "1");
                }
                b"view" => {
                    f_view = val.parse().ok();
                }
                b"topLeftCell" => {
                    f_top_left_cell = Some(val.into_owned());
                }
                #[cfg(feature = "sml-styling")]
                b"colorId" => {
                    f_color_id = val.parse().ok();
                }
                b"zoomScale" => {
                    f_zoom_scale = val.parse().ok();
                }
                b"zoomScaleNormal" => {
                    f_zoom_scale_normal = val.parse().ok();
                }
                #[cfg(feature = "sml-layout")]
                b"zoomScaleSheetLayoutView" => {
                    f_zoom_scale_sheet_layout_view = val.parse().ok();
                }
                #[cfg(feature = "sml-layout")]
                b"zoomScalePageLayoutView" => {
                    f_zoom_scale_page_layout_view = val.parse().ok();
                }
                b"workbookViewId" => {
                    f_workbook_view_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "sml-structure")]
                            b"pane" => {
                                f_pane = Some(Box::new(Pane::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"selection" => {
                                f_selection.push(Selection::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-pivot")]
                            b"pivotSelection" => {
                                f_pivot_selection
                                    .push(CTPivotSelection::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-extensions")]
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "sml-structure")]
                            b"pane" => {
                                f_pane = Some(Box::new(Pane::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"selection" => {
                                f_selection.push(Selection::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-pivot")]
                            b"pivotSelection" => {
                                f_pivot_selection
                                    .push(CTPivotSelection::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-extensions")]
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            #[cfg(feature = "sml-protection")]
            window_protection: f_window_protection,
            #[cfg(feature = "sml-formulas")]
            show_formulas: f_show_formulas,
            #[cfg(feature = "sml-styling")]
            show_grid_lines: f_show_grid_lines,
            #[cfg(feature = "sml-styling")]
            show_row_col_headers: f_show_row_col_headers,
            #[cfg(feature = "sml-styling")]
            show_zeros: f_show_zeros,
            #[cfg(feature = "sml-i18n")]
            right_to_left: f_right_to_left,
            tab_selected: f_tab_selected,
            #[cfg(feature = "sml-layout")]
            show_ruler: f_show_ruler,
            #[cfg(feature = "sml-structure")]
            show_outline_symbols: f_show_outline_symbols,
            #[cfg(feature = "sml-styling")]
            default_grid_color: f_default_grid_color,
            #[cfg(feature = "sml-layout")]
            show_white_space: f_show_white_space,
            view: f_view,
            top_left_cell: f_top_left_cell,
            #[cfg(feature = "sml-styling")]
            color_id: f_color_id,
            zoom_scale: f_zoom_scale,
            zoom_scale_normal: f_zoom_scale_normal,
            #[cfg(feature = "sml-layout")]
            zoom_scale_sheet_layout_view: f_zoom_scale_sheet_layout_view,
            #[cfg(feature = "sml-layout")]
            zoom_scale_page_layout_view: f_zoom_scale_page_layout_view,
            workbook_view_id: f_workbook_view_id
                .ok_or_else(|| ParseError::MissingAttribute("workbookViewId".to_string()))?,
            #[cfg(feature = "sml-structure")]
            pane: f_pane,
            selection: f_selection,
            #[cfg(feature = "sml-pivot")]
            pivot_selection: f_pivot_selection,
            #[cfg(feature = "sml-extensions")]
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Pane {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "sml-structure")]
        let mut f_x_split = None;
        #[cfg(feature = "sml-structure")]
        let mut f_y_split = None;
        #[cfg(feature = "sml-structure")]
        let mut f_top_left_cell = None;
        #[cfg(feature = "sml-structure")]
        let mut f_active_pane = None;
        #[cfg(feature = "sml-structure")]
        let mut f_state = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                #[cfg(feature = "sml-structure")]
                b"xSplit" => {
                    f_x_split = val.parse().ok();
                }
                #[cfg(feature = "sml-structure")]
                b"ySplit" => {
                    f_y_split = val.parse().ok();
                }
                #[cfg(feature = "sml-structure")]
                b"topLeftCell" => {
                    f_top_left_cell = Some(val.into_owned());
                }
                #[cfg(feature = "sml-structure")]
                b"activePane" => {
                    f_active_pane = val.parse().ok();
                }
                #[cfg(feature = "sml-structure")]
                b"state" => {
                    f_state = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            #[cfg(feature = "sml-structure")]
            x_split: f_x_split,
            #[cfg(feature = "sml-structure")]
            y_split: f_y_split,
            #[cfg(feature = "sml-structure")]
            top_left_cell: f_top_left_cell,
            #[cfg(feature = "sml-structure")]
            active_pane: f_active_pane,
            #[cfg(feature = "sml-structure")]
            state: f_state,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTPivotSelection {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_pane = None;
        let mut f_show_header = None;
        let mut f_label = None;
        let mut f_data = None;
        let mut f_extendable = None;
        let mut f_count = None;
        let mut f_axis = None;
        let mut f_dimension = None;
        let mut f_start = None;
        let mut f_start_column = None;
        let mut f_end_column = None;
        let mut f_active_row = None;
        let mut f_active_col = None;
        let mut f_previous_row = None;
        let mut f_previous_col = None;
        let mut f_click = None;
        let mut f_id = None;
        let mut f_pivot_area: Option<Box<PivotArea>> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"pane" => {
                    f_pane = val.parse().ok();
                }
                b"showHeader" => {
                    f_show_header = Some(val == "true" || val == "1");
                }
                b"label" => {
                    f_label = Some(val == "true" || val == "1");
                }
                b"data" => {
                    f_data = Some(val == "true" || val == "1");
                }
                b"extendable" => {
                    f_extendable = Some(val == "true" || val == "1");
                }
                b"count" => {
                    f_count = val.parse().ok();
                }
                b"axis" => {
                    f_axis = val.parse().ok();
                }
                b"dimension" => {
                    f_dimension = val.parse().ok();
                }
                b"start" => {
                    f_start = val.parse().ok();
                }
                b"min" => {
                    f_start_column = val.parse().ok();
                }
                b"max" => {
                    f_end_column = val.parse().ok();
                }
                b"activeRow" => {
                    f_active_row = val.parse().ok();
                }
                b"activeCol" => {
                    f_active_col = val.parse().ok();
                }
                b"previousRow" => {
                    f_previous_row = val.parse().ok();
                }
                b"previousCol" => {
                    f_previous_col = val.parse().ok();
                }
                b"click" => {
                    f_click = val.parse().ok();
                }
                b"id" => {
                    f_id = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"pivotArea" => {
                                f_pivot_area =
                                    Some(Box::new(PivotArea::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"pivotArea" => {
                                f_pivot_area =
                                    Some(Box::new(PivotArea::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            pane: f_pane,
            show_header: f_show_header,
            label: f_label,
            data: f_data,
            extendable: f_extendable,
            count: f_count,
            axis: f_axis,
            dimension: f_dimension,
            start: f_start,
            start_column: f_start_column,
            end_column: f_end_column,
            active_row: f_active_row,
            active_col: f_active_col,
            previous_row: f_previous_row,
            previous_col: f_previous_col,
            click: f_click,
            id: f_id,
            pivot_area: f_pivot_area
                .ok_or_else(|| ParseError::MissingAttribute("pivotArea".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Selection {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_pane = None;
        let mut f_active_cell = None;
        let mut f_active_cell_id = None;
        let mut f_square_reference = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"pane" => {
                    f_pane = val.parse().ok();
                }
                b"activeCell" => {
                    f_active_cell = Some(val.into_owned());
                }
                b"activeCellId" => {
                    f_active_cell_id = val.parse().ok();
                }
                b"sqref" => {
                    f_square_reference = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            pane: f_pane,
            active_cell: f_active_cell,
            active_cell_id: f_active_cell_id,
            square_reference: f_square_reference,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for PageBreaks {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_manual_break_count = None;
        let mut f_brk = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                b"manualBreakCount" => {
                    f_manual_break_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"brk" => {
                                f_brk.push(PageBreak::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"brk" => {
                                f_brk.push(PageBreak::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            manual_break_count: f_manual_break_count,
            brk: f_brk,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for PageBreak {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id = None;
        let mut f_start_column = None;
        let mut f_end_column = None;
        let mut f_man = None;
        let mut f_pt = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"min" => {
                    f_start_column = val.parse().ok();
                }
                b"max" => {
                    f_end_column = val.parse().ok();
                }
                b"man" => {
                    f_man = Some(val == "true" || val == "1");
                }
                b"pt" => {
                    f_pt = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id,
            start_column: f_start_column,
            end_column: f_end_column,
            man: f_man,
            pt: f_pt,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for OutlineProperties {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_apply_styles = None;
        let mut f_summary_below = None;
        let mut f_summary_right = None;
        let mut f_show_outline_symbols = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"applyStyles" => {
                    f_apply_styles = Some(val == "true" || val == "1");
                }
                b"summaryBelow" => {
                    f_summary_below = Some(val == "true" || val == "1");
                }
                b"summaryRight" => {
                    f_summary_right = Some(val == "true" || val == "1");
                }
                b"showOutlineSymbols" => {
                    f_show_outline_symbols = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            apply_styles: f_apply_styles,
            summary_below: f_summary_below,
            summary_right: f_summary_right,
            show_outline_symbols: f_show_outline_symbols,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for PageSetupProperties {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_auto_page_breaks = None;
        let mut f_fit_to_page = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"autoPageBreaks" => {
                    f_auto_page_breaks = Some(val == "true" || val == "1");
                }
                b"fitToPage" => {
                    f_fit_to_page = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            auto_page_breaks: f_auto_page_breaks,
            fit_to_page: f_fit_to_page,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTDataConsolidate {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_function = None;
        let mut f_start_labels = None;
        let mut f_left_labels = None;
        let mut f_top_labels = None;
        let mut f_link = None;
        let mut f_data_refs = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"function" => {
                    f_function = val.parse().ok();
                }
                b"startLabels" => {
                    f_start_labels = Some(val == "true" || val == "1");
                }
                b"leftLabels" => {
                    f_left_labels = Some(val == "true" || val == "1");
                }
                b"topLabels" => {
                    f_top_labels = Some(val == "true" || val == "1");
                }
                b"link" => {
                    f_link = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"dataRefs" => {
                                f_data_refs =
                                    Some(Box::new(CTDataRefs::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"dataRefs" => {
                                f_data_refs =
                                    Some(Box::new(CTDataRefs::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            function: f_function,
            start_labels: f_start_labels,
            left_labels: f_left_labels,
            top_labels: f_top_labels,
            link: f_link,
            data_refs: f_data_refs,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTDataRefs {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_data_ref = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"dataRef" => {
                                f_data_ref.push(CTDataRef::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"dataRef" => {
                                f_data_ref.push(CTDataRef::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            data_ref: f_data_ref,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTDataRef {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_reference = None;
        let mut f_name = None;
        let mut f_sheet = None;
        let mut f_id = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"ref" => {
                    f_reference = Some(val.into_owned());
                }
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"sheet" => {
                    f_sheet = Some(val.into_owned());
                }
                b"id" => {
                    f_id = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            reference: f_reference,
            name: f_name,
            sheet: f_sheet,
            id: f_id,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for MergedCells {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_merge_cell = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"mergeCell" => {
                                f_merge_cell.push(MergedCell::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"mergeCell" => {
                                f_merge_cell.push(MergedCell::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            merge_cell: f_merge_cell,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for MergedCell {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_reference: Option<Reference> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"ref" => {
                    f_reference = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            reference: f_reference
                .ok_or_else(|| ParseError::MissingAttribute("ref".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for SmartTags {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_cell_smart_tags = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"cellSmartTags" => {
                                f_cell_smart_tags.push(CellSmartTags::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"cellSmartTags" => {
                                f_cell_smart_tags.push(CellSmartTags::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            cell_smart_tags: f_cell_smart_tags,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CellSmartTags {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_reference: Option<CellRef> = None;
        let mut f_cell_smart_tag = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"r" => {
                    f_reference = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"cellSmartTag" => {
                                f_cell_smart_tag.push(CellSmartTag::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"cellSmartTag" => {
                                f_cell_smart_tag.push(CellSmartTag::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            reference: f_reference.ok_or_else(|| ParseError::MissingAttribute("r".to_string()))?,
            cell_smart_tag: f_cell_smart_tag,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CellSmartTag {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_type: Option<u32> = None;
        let mut f_deleted = None;
        let mut f_xml_based = None;
        let mut f_cell_smart_tag_pr = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"type" => {
                    f_type = val.parse().ok();
                }
                b"deleted" => {
                    f_deleted = Some(val == "true" || val == "1");
                }
                b"xmlBased" => {
                    f_xml_based = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"cellSmartTagPr" => {
                                f_cell_smart_tag_pr
                                    .push(CTCellSmartTagPr::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"cellSmartTagPr" => {
                                f_cell_smart_tag_pr
                                    .push(CTCellSmartTagPr::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r#type: f_type.ok_or_else(|| ParseError::MissingAttribute("type".to_string()))?,
            deleted: f_deleted,
            xml_based: f_xml_based,
            cell_smart_tag_pr: f_cell_smart_tag_pr,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTCellSmartTagPr {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_key: Option<XmlString> = None;
        let mut f_value: Option<XmlString> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"key" => {
                    f_key = Some(val.into_owned());
                }
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            key: f_key.ok_or_else(|| ParseError::MissingAttribute("key".to_string()))?,
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for Drawing {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STRelationshipId> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for LegacyDrawing {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STRelationshipId> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for DrawingHeaderFooter {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STRelationshipId> = None;
        let mut f_lho = None;
        let mut f_lhe = None;
        let mut f_lhf = None;
        let mut f_cho = None;
        let mut f_che = None;
        let mut f_chf = None;
        let mut f_rho = None;
        let mut f_rhe = None;
        let mut f_rhf = None;
        let mut f_lfo = None;
        let mut f_lfe = None;
        let mut f_lff = None;
        let mut f_cfo = None;
        let mut f_cfe = None;
        let mut f_cff = None;
        let mut f_rfo = None;
        let mut f_rfe = None;
        let mut f_rff = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = Some(val.into_owned());
                }
                b"lho" => {
                    f_lho = val.parse().ok();
                }
                b"lhe" => {
                    f_lhe = val.parse().ok();
                }
                b"lhf" => {
                    f_lhf = val.parse().ok();
                }
                b"cho" => {
                    f_cho = val.parse().ok();
                }
                b"che" => {
                    f_che = val.parse().ok();
                }
                b"chf" => {
                    f_chf = val.parse().ok();
                }
                b"rho" => {
                    f_rho = val.parse().ok();
                }
                b"rhe" => {
                    f_rhe = val.parse().ok();
                }
                b"rhf" => {
                    f_rhf = val.parse().ok();
                }
                b"lfo" => {
                    f_lfo = val.parse().ok();
                }
                b"lfe" => {
                    f_lfe = val.parse().ok();
                }
                b"lff" => {
                    f_lff = val.parse().ok();
                }
                b"cfo" => {
                    f_cfo = val.parse().ok();
                }
                b"cfe" => {
                    f_cfe = val.parse().ok();
                }
                b"cff" => {
                    f_cff = val.parse().ok();
                }
                b"rfo" => {
                    f_rfo = val.parse().ok();
                }
                b"rfe" => {
                    f_rfe = val.parse().ok();
                }
                b"rff" => {
                    f_rff = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            lho: f_lho,
            lhe: f_lhe,
            lhf: f_lhf,
            cho: f_cho,
            che: f_che,
            chf: f_chf,
            rho: f_rho,
            rhe: f_rhe,
            rhf: f_rhf,
            lfo: f_lfo,
            lfe: f_lfe,
            lff: f_lff,
            cfo: f_cfo,
            cfe: f_cfe,
            cff: f_cff,
            rfo: f_rfo,
            rfe: f_rfe,
            rff: f_rff,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CustomSheetViews {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_custom_sheet_view = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"customSheetView" => {
                                f_custom_sheet_view
                                    .push(CustomSheetView::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"customSheetView" => {
                                f_custom_sheet_view
                                    .push(CustomSheetView::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            custom_sheet_view: f_custom_sheet_view,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CustomSheetView {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_guid: Option<Guid> = None;
        let mut f_scale = None;
        let mut f_color_id = None;
        let mut f_show_page_breaks = None;
        let mut f_show_formulas = None;
        let mut f_show_grid_lines = None;
        let mut f_show_row_col = None;
        let mut f_outline_symbols = None;
        let mut f_zero_values = None;
        let mut f_fit_to_page = None;
        let mut f_print_area = None;
        let mut f_filter = None;
        let mut f_show_auto_filter = None;
        let mut f_hidden_rows = None;
        let mut f_hidden_columns = None;
        let mut f_state = None;
        let mut f_filter_unique = None;
        let mut f_view = None;
        let mut f_show_ruler = None;
        let mut f_top_left_cell = None;
        let mut f_pane = None;
        let mut f_selection = None;
        let mut f_row_breaks = None;
        let mut f_col_breaks = None;
        let mut f_page_margins = None;
        let mut f_print_options = None;
        let mut f_page_setup = None;
        let mut f_header_footer = None;
        let mut f_auto_filter = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"guid" => {
                    f_guid = Some(val.into_owned());
                }
                b"scale" => {
                    f_scale = val.parse().ok();
                }
                b"colorId" => {
                    f_color_id = val.parse().ok();
                }
                b"showPageBreaks" => {
                    f_show_page_breaks = Some(val == "true" || val == "1");
                }
                b"showFormulas" => {
                    f_show_formulas = Some(val == "true" || val == "1");
                }
                b"showGridLines" => {
                    f_show_grid_lines = Some(val == "true" || val == "1");
                }
                b"showRowCol" => {
                    f_show_row_col = Some(val == "true" || val == "1");
                }
                b"outlineSymbols" => {
                    f_outline_symbols = Some(val == "true" || val == "1");
                }
                b"zeroValues" => {
                    f_zero_values = Some(val == "true" || val == "1");
                }
                b"fitToPage" => {
                    f_fit_to_page = Some(val == "true" || val == "1");
                }
                b"printArea" => {
                    f_print_area = Some(val == "true" || val == "1");
                }
                b"filter" => {
                    f_filter = Some(val == "true" || val == "1");
                }
                b"showAutoFilter" => {
                    f_show_auto_filter = Some(val == "true" || val == "1");
                }
                b"hiddenRows" => {
                    f_hidden_rows = Some(val == "true" || val == "1");
                }
                b"hiddenColumns" => {
                    f_hidden_columns = Some(val == "true" || val == "1");
                }
                b"state" => {
                    f_state = val.parse().ok();
                }
                b"filterUnique" => {
                    f_filter_unique = Some(val == "true" || val == "1");
                }
                b"view" => {
                    f_view = val.parse().ok();
                }
                b"showRuler" => {
                    f_show_ruler = Some(val == "true" || val == "1");
                }
                b"topLeftCell" => {
                    f_top_left_cell = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"pane" => {
                                f_pane = Some(Box::new(Pane::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"selection" => {
                                f_selection =
                                    Some(Box::new(Selection::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rowBreaks" => {
                                f_row_breaks =
                                    Some(Box::new(PageBreaks::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"colBreaks" => {
                                f_col_breaks =
                                    Some(Box::new(PageBreaks::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pageMargins" => {
                                f_page_margins =
                                    Some(Box::new(PageMargins::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"printOptions" => {
                                f_print_options =
                                    Some(Box::new(PrintOptions::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pageSetup" => {
                                f_page_setup =
                                    Some(Box::new(PageSetup::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"headerFooter" => {
                                f_header_footer =
                                    Some(Box::new(HeaderFooter::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"autoFilter" => {
                                f_auto_filter =
                                    Some(Box::new(AutoFilter::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"pane" => {
                                f_pane = Some(Box::new(Pane::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"selection" => {
                                f_selection =
                                    Some(Box::new(Selection::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"rowBreaks" => {
                                f_row_breaks =
                                    Some(Box::new(PageBreaks::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"colBreaks" => {
                                f_col_breaks =
                                    Some(Box::new(PageBreaks::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pageMargins" => {
                                f_page_margins =
                                    Some(Box::new(PageMargins::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"printOptions" => {
                                f_print_options =
                                    Some(Box::new(PrintOptions::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pageSetup" => {
                                f_page_setup =
                                    Some(Box::new(PageSetup::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"headerFooter" => {
                                f_header_footer =
                                    Some(Box::new(HeaderFooter::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"autoFilter" => {
                                f_auto_filter =
                                    Some(Box::new(AutoFilter::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            guid: f_guid.ok_or_else(|| ParseError::MissingAttribute("guid".to_string()))?,
            scale: f_scale,
            color_id: f_color_id,
            show_page_breaks: f_show_page_breaks,
            show_formulas: f_show_formulas,
            show_grid_lines: f_show_grid_lines,
            show_row_col: f_show_row_col,
            outline_symbols: f_outline_symbols,
            zero_values: f_zero_values,
            fit_to_page: f_fit_to_page,
            print_area: f_print_area,
            filter: f_filter,
            show_auto_filter: f_show_auto_filter,
            hidden_rows: f_hidden_rows,
            hidden_columns: f_hidden_columns,
            state: f_state,
            filter_unique: f_filter_unique,
            view: f_view,
            show_ruler: f_show_ruler,
            top_left_cell: f_top_left_cell,
            pane: f_pane,
            selection: f_selection,
            row_breaks: f_row_breaks,
            col_breaks: f_col_breaks,
            page_margins: f_page_margins,
            print_options: f_print_options,
            page_setup: f_page_setup,
            header_footer: f_header_footer,
            auto_filter: f_auto_filter,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for DataValidations {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_disable_prompts = None;
        let mut f_x_window = None;
        let mut f_y_window = None;
        let mut f_count = None;
        let mut f_data_validation = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"disablePrompts" => {
                    f_disable_prompts = Some(val == "true" || val == "1");
                }
                b"xWindow" => {
                    f_x_window = val.parse().ok();
                }
                b"yWindow" => {
                    f_y_window = val.parse().ok();
                }
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"dataValidation" => {
                                f_data_validation
                                    .push(DataValidation::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"dataValidation" => {
                                f_data_validation.push(DataValidation::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            disable_prompts: f_disable_prompts,
            x_window: f_x_window,
            y_window: f_y_window,
            count: f_count,
            data_validation: f_data_validation,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for DataValidation {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "sml-validation")]
        let mut f_type = None;
        #[cfg(feature = "sml-validation")]
        let mut f_error_style = None;
        #[cfg(feature = "sml-validation")]
        let mut f_ime_mode = None;
        #[cfg(feature = "sml-validation")]
        let mut f_operator = None;
        #[cfg(feature = "sml-validation")]
        let mut f_allow_blank = None;
        #[cfg(feature = "sml-validation")]
        let mut f_show_drop_down = None;
        #[cfg(feature = "sml-validation")]
        let mut f_show_input_message = None;
        #[cfg(feature = "sml-validation")]
        let mut f_show_error_message = None;
        #[cfg(feature = "sml-validation")]
        let mut f_error_title = None;
        #[cfg(feature = "sml-validation")]
        let mut f_error = None;
        #[cfg(feature = "sml-validation")]
        let mut f_prompt_title = None;
        #[cfg(feature = "sml-validation")]
        let mut f_prompt = None;
        #[cfg(feature = "sml-validation")]
        let mut f_square_reference: Option<SquareRef> = None;
        #[cfg(feature = "sml-validation")]
        let mut f_formula1 = None;
        #[cfg(feature = "sml-validation")]
        let mut f_formula2 = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                #[cfg(feature = "sml-validation")]
                b"type" => {
                    f_type = val.parse().ok();
                }
                #[cfg(feature = "sml-validation")]
                b"errorStyle" => {
                    f_error_style = val.parse().ok();
                }
                #[cfg(feature = "sml-validation")]
                b"imeMode" => {
                    f_ime_mode = val.parse().ok();
                }
                #[cfg(feature = "sml-validation")]
                b"operator" => {
                    f_operator = val.parse().ok();
                }
                #[cfg(feature = "sml-validation")]
                b"allowBlank" => {
                    f_allow_blank = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-validation")]
                b"showDropDown" => {
                    f_show_drop_down = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-validation")]
                b"showInputMessage" => {
                    f_show_input_message = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-validation")]
                b"showErrorMessage" => {
                    f_show_error_message = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-validation")]
                b"errorTitle" => {
                    f_error_title = Some(val.into_owned());
                }
                #[cfg(feature = "sml-validation")]
                b"error" => {
                    f_error = Some(val.into_owned());
                }
                #[cfg(feature = "sml-validation")]
                b"promptTitle" => {
                    f_prompt_title = Some(val.into_owned());
                }
                #[cfg(feature = "sml-validation")]
                b"prompt" => {
                    f_prompt = Some(val.into_owned());
                }
                #[cfg(feature = "sml-validation")]
                b"sqref" => {
                    f_square_reference = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "sml-validation")]
                            b"formula1" => {
                                f_formula1 = Some(read_text_content(reader)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-validation")]
                            b"formula2" => {
                                f_formula2 = Some(read_text_content(reader)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "sml-validation")]
                            b"formula1" => {
                                f_formula1 = Some(String::new());
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-validation")]
                            b"formula2" => {
                                f_formula2 = Some(String::new());
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            #[cfg(feature = "sml-validation")]
            r#type: f_type,
            #[cfg(feature = "sml-validation")]
            error_style: f_error_style,
            #[cfg(feature = "sml-validation")]
            ime_mode: f_ime_mode,
            #[cfg(feature = "sml-validation")]
            operator: f_operator,
            #[cfg(feature = "sml-validation")]
            allow_blank: f_allow_blank,
            #[cfg(feature = "sml-validation")]
            show_drop_down: f_show_drop_down,
            #[cfg(feature = "sml-validation")]
            show_input_message: f_show_input_message,
            #[cfg(feature = "sml-validation")]
            show_error_message: f_show_error_message,
            #[cfg(feature = "sml-validation")]
            error_title: f_error_title,
            #[cfg(feature = "sml-validation")]
            error: f_error,
            #[cfg(feature = "sml-validation")]
            prompt_title: f_prompt_title,
            #[cfg(feature = "sml-validation")]
            prompt: f_prompt,
            #[cfg(feature = "sml-validation")]
            square_reference: f_square_reference
                .ok_or_else(|| ParseError::MissingAttribute("sqref".to_string()))?,
            #[cfg(feature = "sml-validation")]
            formula1: f_formula1,
            #[cfg(feature = "sml-validation")]
            formula2: f_formula2,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for ConditionalFormatting {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "sml-pivot")]
        let mut f_pivot = None;
        #[cfg(feature = "sml-styling")]
        let mut f_square_reference = None;
        #[cfg(feature = "sml-styling")]
        let mut f_cf_rule = Vec::new();
        #[cfg(feature = "sml-extensions")]
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                #[cfg(feature = "sml-pivot")]
                b"pivot" => {
                    f_pivot = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-styling")]
                b"sqref" => {
                    f_square_reference = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "sml-styling")]
                            b"cfRule" => {
                                f_cf_rule.push(ConditionalRule::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-extensions")]
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "sml-styling")]
                            b"cfRule" => {
                                f_cf_rule.push(ConditionalRule::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-extensions")]
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            #[cfg(feature = "sml-pivot")]
            pivot: f_pivot,
            #[cfg(feature = "sml-styling")]
            square_reference: f_square_reference,
            #[cfg(feature = "sml-styling")]
            cf_rule: f_cf_rule,
            #[cfg(feature = "sml-extensions")]
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for ConditionalRule {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "sml-styling")]
        let mut f_type = None;
        #[cfg(feature = "sml-styling")]
        let mut f_dxf_id = None;
        #[cfg(feature = "sml-styling")]
        let mut f_priority: Option<i32> = None;
        #[cfg(feature = "sml-styling")]
        let mut f_stop_if_true = None;
        #[cfg(feature = "sml-styling")]
        let mut f_above_average = None;
        #[cfg(feature = "sml-styling")]
        let mut f_percent = None;
        #[cfg(feature = "sml-styling")]
        let mut f_bottom = None;
        #[cfg(feature = "sml-styling")]
        let mut f_operator = None;
        #[cfg(feature = "sml-styling")]
        let mut f_text = None;
        #[cfg(feature = "sml-styling")]
        let mut f_time_period = None;
        #[cfg(feature = "sml-styling")]
        let mut f_rank = None;
        #[cfg(feature = "sml-styling")]
        let mut f_std_dev = None;
        #[cfg(feature = "sml-styling")]
        let mut f_equal_average = None;
        #[cfg(feature = "sml-styling")]
        let mut f_formula = Vec::new();
        #[cfg(feature = "sml-styling")]
        let mut f_color_scale = None;
        #[cfg(feature = "sml-styling")]
        let mut f_data_bar = None;
        #[cfg(feature = "sml-styling")]
        let mut f_icon_set = None;
        #[cfg(feature = "sml-extensions")]
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                #[cfg(feature = "sml-styling")]
                b"type" => {
                    f_type = val.parse().ok();
                }
                #[cfg(feature = "sml-styling")]
                b"dxfId" => {
                    f_dxf_id = val.parse().ok();
                }
                #[cfg(feature = "sml-styling")]
                b"priority" => {
                    f_priority = val.parse().ok();
                }
                #[cfg(feature = "sml-styling")]
                b"stopIfTrue" => {
                    f_stop_if_true = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-styling")]
                b"aboveAverage" => {
                    f_above_average = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-styling")]
                b"percent" => {
                    f_percent = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-styling")]
                b"bottom" => {
                    f_bottom = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-styling")]
                b"operator" => {
                    f_operator = val.parse().ok();
                }
                #[cfg(feature = "sml-styling")]
                b"text" => {
                    f_text = Some(val.into_owned());
                }
                #[cfg(feature = "sml-styling")]
                b"timePeriod" => {
                    f_time_period = val.parse().ok();
                }
                #[cfg(feature = "sml-styling")]
                b"rank" => {
                    f_rank = val.parse().ok();
                }
                #[cfg(feature = "sml-styling")]
                b"stdDev" => {
                    f_std_dev = val.parse().ok();
                }
                #[cfg(feature = "sml-styling")]
                b"equalAverage" => {
                    f_equal_average = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "sml-styling")]
                            b"formula" => {
                                f_formula.push(read_text_content(reader)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"colorScale" => {
                                f_color_scale =
                                    Some(Box::new(ColorScale::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"dataBar" => {
                                f_data_bar = Some(Box::new(DataBar::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"iconSet" => {
                                f_icon_set = Some(Box::new(IconSet::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-extensions")]
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "sml-styling")]
                            b"formula" => {
                                f_formula.push(String::new());
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"colorScale" => {
                                f_color_scale =
                                    Some(Box::new(ColorScale::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"dataBar" => {
                                f_data_bar = Some(Box::new(DataBar::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"iconSet" => {
                                f_icon_set = Some(Box::new(IconSet::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-extensions")]
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            #[cfg(feature = "sml-styling")]
            r#type: f_type,
            #[cfg(feature = "sml-styling")]
            dxf_id: f_dxf_id,
            #[cfg(feature = "sml-styling")]
            priority: f_priority
                .ok_or_else(|| ParseError::MissingAttribute("priority".to_string()))?,
            #[cfg(feature = "sml-styling")]
            stop_if_true: f_stop_if_true,
            #[cfg(feature = "sml-styling")]
            above_average: f_above_average,
            #[cfg(feature = "sml-styling")]
            percent: f_percent,
            #[cfg(feature = "sml-styling")]
            bottom: f_bottom,
            #[cfg(feature = "sml-styling")]
            operator: f_operator,
            #[cfg(feature = "sml-styling")]
            text: f_text,
            #[cfg(feature = "sml-styling")]
            time_period: f_time_period,
            #[cfg(feature = "sml-styling")]
            rank: f_rank,
            #[cfg(feature = "sml-styling")]
            std_dev: f_std_dev,
            #[cfg(feature = "sml-styling")]
            equal_average: f_equal_average,
            #[cfg(feature = "sml-styling")]
            formula: f_formula,
            #[cfg(feature = "sml-styling")]
            color_scale: f_color_scale,
            #[cfg(feature = "sml-styling")]
            data_bar: f_data_bar,
            #[cfg(feature = "sml-styling")]
            icon_set: f_icon_set,
            #[cfg(feature = "sml-extensions")]
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Hyperlinks {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_hyperlink = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"hyperlink" => {
                                f_hyperlink.push(Hyperlink::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"hyperlink" => {
                                f_hyperlink.push(Hyperlink::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            hyperlink: f_hyperlink,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Hyperlink {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "sml-hyperlinks")]
        let mut f_reference: Option<Reference> = None;
        let mut f_id = None;
        #[cfg(feature = "sml-hyperlinks")]
        let mut f_location = None;
        #[cfg(feature = "sml-hyperlinks")]
        let mut f_tooltip = None;
        #[cfg(feature = "sml-hyperlinks")]
        let mut f_display = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                #[cfg(feature = "sml-hyperlinks")]
                b"ref" => {
                    f_reference = Some(val.into_owned());
                }
                b"id" => {
                    f_id = Some(val.into_owned());
                }
                #[cfg(feature = "sml-hyperlinks")]
                b"location" => {
                    f_location = Some(val.into_owned());
                }
                #[cfg(feature = "sml-hyperlinks")]
                b"tooltip" => {
                    f_tooltip = Some(val.into_owned());
                }
                #[cfg(feature = "sml-hyperlinks")]
                b"display" => {
                    f_display = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            #[cfg(feature = "sml-hyperlinks")]
            reference: f_reference
                .ok_or_else(|| ParseError::MissingAttribute("ref".to_string()))?,
            id: f_id,
            #[cfg(feature = "sml-hyperlinks")]
            location: f_location,
            #[cfg(feature = "sml-hyperlinks")]
            tooltip: f_tooltip,
            #[cfg(feature = "sml-hyperlinks")]
            display: f_display,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CellFormula {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_text = None;
        let mut f_cell_type = None;
        #[cfg(feature = "sml-formulas-advanced")]
        let mut f_aca = None;
        let mut f_reference = None;
        #[cfg(feature = "sml-formulas-advanced")]
        let mut f_dt2_d = None;
        #[cfg(feature = "sml-formulas-advanced")]
        let mut f_dtr = None;
        #[cfg(feature = "sml-formulas-advanced")]
        let mut f_del1 = None;
        #[cfg(feature = "sml-formulas-advanced")]
        let mut f_del2 = None;
        #[cfg(feature = "sml-formulas-advanced")]
        let mut f_r1 = None;
        #[cfg(feature = "sml-formulas-advanced")]
        let mut f_r2 = None;
        #[cfg(feature = "sml-formulas-advanced")]
        let mut f_ca = None;
        let mut f_si = None;
        #[cfg(feature = "sml-formulas-advanced")]
        let mut f_bx = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"t" => {
                    f_cell_type = val.parse().ok();
                }
                #[cfg(feature = "sml-formulas-advanced")]
                b"aca" => {
                    f_aca = Some(val == "true" || val == "1");
                }
                b"ref" => {
                    f_reference = Some(val.into_owned());
                }
                #[cfg(feature = "sml-formulas-advanced")]
                b"dt2D" => {
                    f_dt2_d = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-formulas-advanced")]
                b"dtr" => {
                    f_dtr = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-formulas-advanced")]
                b"del1" => {
                    f_del1 = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-formulas-advanced")]
                b"del2" => {
                    f_del2 = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-formulas-advanced")]
                b"r1" => {
                    f_r1 = Some(val.into_owned());
                }
                #[cfg(feature = "sml-formulas-advanced")]
                b"r2" => {
                    f_r2 = Some(val.into_owned());
                }
                #[cfg(feature = "sml-formulas-advanced")]
                b"ca" => {
                    f_ca = Some(val == "true" || val == "1");
                }
                b"si" => {
                    f_si = val.parse().ok();
                }
                #[cfg(feature = "sml-formulas-advanced")]
                b"bx" => {
                    f_bx = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::Text(e) => {
                        f_text = Some(e.decode().unwrap_or_default().into_owned());
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            text: f_text,
            cell_type: f_cell_type,
            #[cfg(feature = "sml-formulas-advanced")]
            aca: f_aca,
            reference: f_reference,
            #[cfg(feature = "sml-formulas-advanced")]
            dt2_d: f_dt2_d,
            #[cfg(feature = "sml-formulas-advanced")]
            dtr: f_dtr,
            #[cfg(feature = "sml-formulas-advanced")]
            del1: f_del1,
            #[cfg(feature = "sml-formulas-advanced")]
            del2: f_del2,
            #[cfg(feature = "sml-formulas-advanced")]
            r1: f_r1,
            #[cfg(feature = "sml-formulas-advanced")]
            r2: f_r2,
            #[cfg(feature = "sml-formulas-advanced")]
            ca: f_ca,
            si: f_si,
            #[cfg(feature = "sml-formulas-advanced")]
            bx: f_bx,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for ColorScale {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_cfvo = Vec::new();
        let mut f_color = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"cfvo" => {
                                f_cfvo.push(ConditionalFormatValue::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"color" => {
                                f_color.push(Color::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"cfvo" => {
                                f_cfvo.push(ConditionalFormatValue::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"color" => {
                                f_color.push(Color::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            cfvo: f_cfvo,
            color: f_color,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for DataBar {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_min_length = None;
        let mut f_max_length = None;
        let mut f_show_value = None;
        let mut f_cfvo = Vec::new();
        let mut f_color: Option<Box<Color>> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"minLength" => {
                    f_min_length = val.parse().ok();
                }
                b"maxLength" => {
                    f_max_length = val.parse().ok();
                }
                b"showValue" => {
                    f_show_value = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"cfvo" => {
                                f_cfvo.push(ConditionalFormatValue::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"color" => {
                                f_color = Some(Box::new(Color::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"cfvo" => {
                                f_cfvo.push(ConditionalFormatValue::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"color" => {
                                f_color = Some(Box::new(Color::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            min_length: f_min_length,
            max_length: f_max_length,
            show_value: f_show_value,
            cfvo: f_cfvo,
            color: f_color.ok_or_else(|| ParseError::MissingAttribute("color".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for IconSet {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_icon_set = None;
        let mut f_show_value = None;
        let mut f_percent = None;
        let mut f_reverse = None;
        let mut f_cfvo = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"iconSet" => {
                    f_icon_set = val.parse().ok();
                }
                b"showValue" => {
                    f_show_value = Some(val == "true" || val == "1");
                }
                b"percent" => {
                    f_percent = Some(val == "true" || val == "1");
                }
                b"reverse" => {
                    f_reverse = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"cfvo" => {
                                f_cfvo.push(ConditionalFormatValue::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"cfvo" => {
                                f_cfvo.push(ConditionalFormatValue::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            icon_set: f_icon_set,
            show_value: f_show_value,
            percent: f_percent,
            reverse: f_reverse,
            cfvo: f_cfvo,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for ConditionalFormatValue {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_type: Option<ConditionalValueType> = None;
        let mut f_value = None;
        let mut f_gte = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"type" => {
                    f_type = val.parse().ok();
                }
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                b"gte" => {
                    f_gte = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r#type: f_type.ok_or_else(|| ParseError::MissingAttribute("type".to_string()))?,
            value: f_value,
            gte: f_gte,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for PageMargins {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "sml-layout")]
        let mut f_left: Option<f64> = None;
        #[cfg(feature = "sml-layout")]
        let mut f_right: Option<f64> = None;
        #[cfg(feature = "sml-layout")]
        let mut f_top: Option<f64> = None;
        #[cfg(feature = "sml-layout")]
        let mut f_bottom: Option<f64> = None;
        #[cfg(feature = "sml-layout")]
        let mut f_header: Option<f64> = None;
        #[cfg(feature = "sml-layout")]
        let mut f_footer: Option<f64> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                #[cfg(feature = "sml-layout")]
                b"left" => {
                    f_left = val.parse().ok();
                }
                #[cfg(feature = "sml-layout")]
                b"right" => {
                    f_right = val.parse().ok();
                }
                #[cfg(feature = "sml-layout")]
                b"top" => {
                    f_top = val.parse().ok();
                }
                #[cfg(feature = "sml-layout")]
                b"bottom" => {
                    f_bottom = val.parse().ok();
                }
                #[cfg(feature = "sml-layout")]
                b"header" => {
                    f_header = val.parse().ok();
                }
                #[cfg(feature = "sml-layout")]
                b"footer" => {
                    f_footer = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            #[cfg(feature = "sml-layout")]
            left: f_left.ok_or_else(|| ParseError::MissingAttribute("left".to_string()))?,
            #[cfg(feature = "sml-layout")]
            right: f_right.ok_or_else(|| ParseError::MissingAttribute("right".to_string()))?,
            #[cfg(feature = "sml-layout")]
            top: f_top.ok_or_else(|| ParseError::MissingAttribute("top".to_string()))?,
            #[cfg(feature = "sml-layout")]
            bottom: f_bottom.ok_or_else(|| ParseError::MissingAttribute("bottom".to_string()))?,
            #[cfg(feature = "sml-layout")]
            header: f_header.ok_or_else(|| ParseError::MissingAttribute("header".to_string()))?,
            #[cfg(feature = "sml-layout")]
            footer: f_footer.ok_or_else(|| ParseError::MissingAttribute("footer".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for PrintOptions {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_horizontal_centered = None;
        let mut f_vertical_centered = None;
        let mut f_headings = None;
        let mut f_grid_lines = None;
        let mut f_grid_lines_set = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"horizontalCentered" => {
                    f_horizontal_centered = Some(val == "true" || val == "1");
                }
                b"verticalCentered" => {
                    f_vertical_centered = Some(val == "true" || val == "1");
                }
                b"headings" => {
                    f_headings = Some(val == "true" || val == "1");
                }
                b"gridLines" => {
                    f_grid_lines = Some(val == "true" || val == "1");
                }
                b"gridLinesSet" => {
                    f_grid_lines_set = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            horizontal_centered: f_horizontal_centered,
            vertical_centered: f_vertical_centered,
            headings: f_headings,
            grid_lines: f_grid_lines,
            grid_lines_set: f_grid_lines_set,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for PageSetup {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "sml-layout")]
        let mut f_paper_size = None;
        #[cfg(feature = "sml-layout")]
        let mut f_paper_height = None;
        #[cfg(feature = "sml-layout")]
        let mut f_paper_width = None;
        #[cfg(feature = "sml-layout")]
        let mut f_scale = None;
        #[cfg(feature = "sml-layout")]
        let mut f_first_page_number = None;
        #[cfg(feature = "sml-layout")]
        let mut f_fit_to_width = None;
        #[cfg(feature = "sml-layout")]
        let mut f_fit_to_height = None;
        #[cfg(feature = "sml-layout")]
        let mut f_page_order = None;
        #[cfg(feature = "sml-layout")]
        let mut f_orientation = None;
        #[cfg(feature = "sml-layout")]
        let mut f_use_printer_defaults = None;
        #[cfg(feature = "sml-layout")]
        let mut f_black_and_white = None;
        #[cfg(feature = "sml-layout")]
        let mut f_draft = None;
        #[cfg(feature = "sml-layout")]
        let mut f_cell_comments = None;
        #[cfg(feature = "sml-layout")]
        let mut f_use_first_page_number = None;
        #[cfg(feature = "sml-layout")]
        let mut f_errors = None;
        #[cfg(feature = "sml-layout")]
        let mut f_horizontal_dpi = None;
        #[cfg(feature = "sml-layout")]
        let mut f_vertical_dpi = None;
        #[cfg(feature = "sml-layout")]
        let mut f_copies = None;
        let mut f_id = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                #[cfg(feature = "sml-layout")]
                b"paperSize" => {
                    f_paper_size = val.parse().ok();
                }
                #[cfg(feature = "sml-layout")]
                b"paperHeight" => {
                    f_paper_height = Some(val.into_owned());
                }
                #[cfg(feature = "sml-layout")]
                b"paperWidth" => {
                    f_paper_width = Some(val.into_owned());
                }
                #[cfg(feature = "sml-layout")]
                b"scale" => {
                    f_scale = val.parse().ok();
                }
                #[cfg(feature = "sml-layout")]
                b"firstPageNumber" => {
                    f_first_page_number = val.parse().ok();
                }
                #[cfg(feature = "sml-layout")]
                b"fitToWidth" => {
                    f_fit_to_width = val.parse().ok();
                }
                #[cfg(feature = "sml-layout")]
                b"fitToHeight" => {
                    f_fit_to_height = val.parse().ok();
                }
                #[cfg(feature = "sml-layout")]
                b"pageOrder" => {
                    f_page_order = val.parse().ok();
                }
                #[cfg(feature = "sml-layout")]
                b"orientation" => {
                    f_orientation = val.parse().ok();
                }
                #[cfg(feature = "sml-layout")]
                b"usePrinterDefaults" => {
                    f_use_printer_defaults = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-layout")]
                b"blackAndWhite" => {
                    f_black_and_white = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-layout")]
                b"draft" => {
                    f_draft = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-layout")]
                b"cellComments" => {
                    f_cell_comments = val.parse().ok();
                }
                #[cfg(feature = "sml-layout")]
                b"useFirstPageNumber" => {
                    f_use_first_page_number = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-layout")]
                b"errors" => {
                    f_errors = val.parse().ok();
                }
                #[cfg(feature = "sml-layout")]
                b"horizontalDpi" => {
                    f_horizontal_dpi = val.parse().ok();
                }
                #[cfg(feature = "sml-layout")]
                b"verticalDpi" => {
                    f_vertical_dpi = val.parse().ok();
                }
                #[cfg(feature = "sml-layout")]
                b"copies" => {
                    f_copies = val.parse().ok();
                }
                b"id" => {
                    f_id = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            #[cfg(feature = "sml-layout")]
            paper_size: f_paper_size,
            #[cfg(feature = "sml-layout")]
            paper_height: f_paper_height,
            #[cfg(feature = "sml-layout")]
            paper_width: f_paper_width,
            #[cfg(feature = "sml-layout")]
            scale: f_scale,
            #[cfg(feature = "sml-layout")]
            first_page_number: f_first_page_number,
            #[cfg(feature = "sml-layout")]
            fit_to_width: f_fit_to_width,
            #[cfg(feature = "sml-layout")]
            fit_to_height: f_fit_to_height,
            #[cfg(feature = "sml-layout")]
            page_order: f_page_order,
            #[cfg(feature = "sml-layout")]
            orientation: f_orientation,
            #[cfg(feature = "sml-layout")]
            use_printer_defaults: f_use_printer_defaults,
            #[cfg(feature = "sml-layout")]
            black_and_white: f_black_and_white,
            #[cfg(feature = "sml-layout")]
            draft: f_draft,
            #[cfg(feature = "sml-layout")]
            cell_comments: f_cell_comments,
            #[cfg(feature = "sml-layout")]
            use_first_page_number: f_use_first_page_number,
            #[cfg(feature = "sml-layout")]
            errors: f_errors,
            #[cfg(feature = "sml-layout")]
            horizontal_dpi: f_horizontal_dpi,
            #[cfg(feature = "sml-layout")]
            vertical_dpi: f_vertical_dpi,
            #[cfg(feature = "sml-layout")]
            copies: f_copies,
            id: f_id,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for HeaderFooter {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "sml-layout")]
        let mut f_different_odd_even = None;
        #[cfg(feature = "sml-layout")]
        let mut f_different_first = None;
        #[cfg(feature = "sml-layout")]
        let mut f_scale_with_doc = None;
        #[cfg(feature = "sml-layout")]
        let mut f_align_with_margins = None;
        #[cfg(feature = "sml-layout")]
        let mut f_odd_header = None;
        #[cfg(feature = "sml-layout")]
        let mut f_odd_footer = None;
        #[cfg(feature = "sml-layout")]
        let mut f_even_header = None;
        #[cfg(feature = "sml-layout")]
        let mut f_even_footer = None;
        #[cfg(feature = "sml-layout")]
        let mut f_first_header = None;
        #[cfg(feature = "sml-layout")]
        let mut f_first_footer = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                #[cfg(feature = "sml-layout")]
                b"differentOddEven" => {
                    f_different_odd_even = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-layout")]
                b"differentFirst" => {
                    f_different_first = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-layout")]
                b"scaleWithDoc" => {
                    f_scale_with_doc = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-layout")]
                b"alignWithMargins" => {
                    f_align_with_margins = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "sml-layout")]
                            b"oddHeader" => {
                                f_odd_header = Some(read_text_content(reader)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-layout")]
                            b"oddFooter" => {
                                f_odd_footer = Some(read_text_content(reader)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-layout")]
                            b"evenHeader" => {
                                f_even_header = Some(read_text_content(reader)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-layout")]
                            b"evenFooter" => {
                                f_even_footer = Some(read_text_content(reader)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-layout")]
                            b"firstHeader" => {
                                f_first_header = Some(read_text_content(reader)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-layout")]
                            b"firstFooter" => {
                                f_first_footer = Some(read_text_content(reader)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "sml-layout")]
                            b"oddHeader" => {
                                f_odd_header = Some(String::new());
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-layout")]
                            b"oddFooter" => {
                                f_odd_footer = Some(String::new());
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-layout")]
                            b"evenHeader" => {
                                f_even_header = Some(String::new());
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-layout")]
                            b"evenFooter" => {
                                f_even_footer = Some(String::new());
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-layout")]
                            b"firstHeader" => {
                                f_first_header = Some(String::new());
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-layout")]
                            b"firstFooter" => {
                                f_first_footer = Some(String::new());
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            #[cfg(feature = "sml-layout")]
            different_odd_even: f_different_odd_even,
            #[cfg(feature = "sml-layout")]
            different_first: f_different_first,
            #[cfg(feature = "sml-layout")]
            scale_with_doc: f_scale_with_doc,
            #[cfg(feature = "sml-layout")]
            align_with_margins: f_align_with_margins,
            #[cfg(feature = "sml-layout")]
            odd_header: f_odd_header,
            #[cfg(feature = "sml-layout")]
            odd_footer: f_odd_footer,
            #[cfg(feature = "sml-layout")]
            even_header: f_even_header,
            #[cfg(feature = "sml-layout")]
            even_footer: f_even_footer,
            #[cfg(feature = "sml-layout")]
            first_header: f_first_header,
            #[cfg(feature = "sml-layout")]
            first_footer: f_first_footer,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Scenarios {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_current = None;
        let mut f_show = None;
        let mut f_square_reference = None;
        let mut f_scenario = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"current" => {
                    f_current = val.parse().ok();
                }
                b"show" => {
                    f_show = val.parse().ok();
                }
                b"sqref" => {
                    f_square_reference = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"scenario" => {
                                f_scenario.push(Scenario::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"scenario" => {
                                f_scenario.push(Scenario::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            current: f_current,
            show: f_show,
            square_reference: f_square_reference,
            scenario: f_scenario,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for SheetProtection {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_password = None;
        let mut f_algorithm_name = None;
        let mut f_hash_value = None;
        let mut f_salt_value = None;
        let mut f_spin_count = None;
        let mut f_sheet = None;
        let mut f_objects = None;
        let mut f_scenarios = None;
        let mut f_format_cells = None;
        let mut f_format_columns = None;
        let mut f_format_rows = None;
        let mut f_insert_columns = None;
        let mut f_insert_rows = None;
        let mut f_insert_hyperlinks = None;
        let mut f_delete_columns = None;
        let mut f_delete_rows = None;
        let mut f_select_locked_cells = None;
        let mut f_sort = None;
        let mut f_auto_filter = None;
        let mut f_pivot_tables = None;
        let mut f_select_unlocked_cells = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"password" => {
                    f_password = decode_hex(&val);
                }
                b"algorithmName" => {
                    f_algorithm_name = Some(val.into_owned());
                }
                b"hashValue" => {
                    f_hash_value = decode_hex(&val);
                }
                b"saltValue" => {
                    f_salt_value = decode_hex(&val);
                }
                b"spinCount" => {
                    f_spin_count = val.parse().ok();
                }
                b"sheet" => {
                    f_sheet = Some(val == "true" || val == "1");
                }
                b"objects" => {
                    f_objects = Some(val == "true" || val == "1");
                }
                b"scenarios" => {
                    f_scenarios = Some(val == "true" || val == "1");
                }
                b"formatCells" => {
                    f_format_cells = Some(val == "true" || val == "1");
                }
                b"formatColumns" => {
                    f_format_columns = Some(val == "true" || val == "1");
                }
                b"formatRows" => {
                    f_format_rows = Some(val == "true" || val == "1");
                }
                b"insertColumns" => {
                    f_insert_columns = Some(val == "true" || val == "1");
                }
                b"insertRows" => {
                    f_insert_rows = Some(val == "true" || val == "1");
                }
                b"insertHyperlinks" => {
                    f_insert_hyperlinks = Some(val == "true" || val == "1");
                }
                b"deleteColumns" => {
                    f_delete_columns = Some(val == "true" || val == "1");
                }
                b"deleteRows" => {
                    f_delete_rows = Some(val == "true" || val == "1");
                }
                b"selectLockedCells" => {
                    f_select_locked_cells = Some(val == "true" || val == "1");
                }
                b"sort" => {
                    f_sort = Some(val == "true" || val == "1");
                }
                b"autoFilter" => {
                    f_auto_filter = Some(val == "true" || val == "1");
                }
                b"pivotTables" => {
                    f_pivot_tables = Some(val == "true" || val == "1");
                }
                b"selectUnlockedCells" => {
                    f_select_unlocked_cells = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            password: f_password,
            algorithm_name: f_algorithm_name,
            hash_value: f_hash_value,
            salt_value: f_salt_value,
            spin_count: f_spin_count,
            sheet: f_sheet,
            objects: f_objects,
            scenarios: f_scenarios,
            format_cells: f_format_cells,
            format_columns: f_format_columns,
            format_rows: f_format_rows,
            insert_columns: f_insert_columns,
            insert_rows: f_insert_rows,
            insert_hyperlinks: f_insert_hyperlinks,
            delete_columns: f_delete_columns,
            delete_rows: f_delete_rows,
            select_locked_cells: f_select_locked_cells,
            sort: f_sort,
            auto_filter: f_auto_filter,
            pivot_tables: f_pivot_tables,
            select_unlocked_cells: f_select_unlocked_cells,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for ProtectedRanges {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_protected_range = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"protectedRange" => {
                                f_protected_range
                                    .push(ProtectedRange::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"protectedRange" => {
                                f_protected_range.push(ProtectedRange::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            protected_range: f_protected_range,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for ProtectedRange {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_password = None;
        let mut f_square_reference: Option<SquareRef> = None;
        let mut f_name: Option<XmlString> = None;
        let mut f_security_descriptor = None;
        let mut f_algorithm_name = None;
        let mut f_hash_value = None;
        let mut f_salt_value = None;
        let mut f_spin_count = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"password" => {
                    f_password = decode_hex(&val);
                }
                b"sqref" => {
                    f_square_reference = Some(val.into_owned());
                }
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"securityDescriptor" => {
                    f_security_descriptor = Some(val.into_owned());
                }
                b"algorithmName" => {
                    f_algorithm_name = Some(val.into_owned());
                }
                b"hashValue" => {
                    f_hash_value = decode_hex(&val);
                }
                b"saltValue" => {
                    f_salt_value = decode_hex(&val);
                }
                b"spinCount" => {
                    f_spin_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            password: f_password,
            square_reference: f_square_reference
                .ok_or_else(|| ParseError::MissingAttribute("sqref".to_string()))?,
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            security_descriptor: f_security_descriptor,
            algorithm_name: f_algorithm_name,
            hash_value: f_hash_value,
            salt_value: f_salt_value,
            spin_count: f_spin_count,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for Scenario {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name: Option<XmlString> = None;
        let mut f_locked = None;
        let mut f_hidden = None;
        let mut f_count = None;
        let mut f_user = None;
        let mut f_comment = None;
        let mut f_input_cells = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"locked" => {
                    f_locked = Some(val == "true" || val == "1");
                }
                b"hidden" => {
                    f_hidden = Some(val == "true" || val == "1");
                }
                b"count" => {
                    f_count = val.parse().ok();
                }
                b"user" => {
                    f_user = Some(val.into_owned());
                }
                b"comment" => {
                    f_comment = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"inputCells" => {
                                f_input_cells.push(InputCells::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"inputCells" => {
                                f_input_cells.push(InputCells::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            locked: f_locked,
            hidden: f_hidden,
            count: f_count,
            user: f_user,
            comment: f_comment,
            input_cells: f_input_cells,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for InputCells {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_reference: Option<CellRef> = None;
        let mut f_deleted = None;
        let mut f_undone = None;
        let mut f_value: Option<XmlString> = None;
        let mut f_number_format_id = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"r" => {
                    f_reference = Some(val.into_owned());
                }
                b"deleted" => {
                    f_deleted = Some(val == "true" || val == "1");
                }
                b"undone" => {
                    f_undone = Some(val == "true" || val == "1");
                }
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                b"numFmtId" => {
                    f_number_format_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            reference: f_reference.ok_or_else(|| ParseError::MissingAttribute("r".to_string()))?,
            deleted: f_deleted,
            undone: f_undone,
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            number_format_id: f_number_format_id,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CellWatches {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_cell_watch = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"cellWatch" => {
                                f_cell_watch.push(CellWatch::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"cellWatch" => {
                                f_cell_watch.push(CellWatch::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            cell_watch: f_cell_watch,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CellWatch {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_reference: Option<CellRef> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"r" => {
                    f_reference = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            reference: f_reference.ok_or_else(|| ParseError::MissingAttribute("r".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for Chartsheet {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_sheet_properties = None;
        let mut f_sheet_views: Option<Box<ChartsheetViews>> = None;
        let mut f_sheet_protection = None;
        let mut f_custom_sheet_views = None;
        let mut f_page_margins = None;
        let mut f_page_setup = None;
        let mut f_header_footer = None;
        let mut f_drawing: Option<Box<Drawing>> = None;
        let mut f_legacy_drawing = None;
        let mut f_legacy_drawing_h_f = None;
        let mut f_drawing_h_f = None;
        let mut f_picture = None;
        let mut f_web_publish_items = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"sheetPr" => {
                                f_sheet_properties = Some(Box::new(
                                    ChartsheetProperties::from_xml(reader, &e, false)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sheetViews" => {
                                f_sheet_views =
                                    Some(Box::new(ChartsheetViews::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sheetProtection" => {
                                f_sheet_protection = Some(Box::new(
                                    ChartsheetProtection::from_xml(reader, &e, false)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"customSheetViews" => {
                                f_custom_sheet_views = Some(Box::new(
                                    CustomChartsheetViews::from_xml(reader, &e, false)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pageMargins" => {
                                f_page_margins =
                                    Some(Box::new(PageMargins::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pageSetup" => {
                                f_page_setup = Some(Box::new(ChartsheetPageSetup::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"headerFooter" => {
                                f_header_footer =
                                    Some(Box::new(HeaderFooter::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"drawing" => {
                                f_drawing = Some(Box::new(Drawing::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"legacyDrawing" => {
                                f_legacy_drawing =
                                    Some(Box::new(LegacyDrawing::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"legacyDrawingHF" => {
                                f_legacy_drawing_h_f =
                                    Some(Box::new(LegacyDrawing::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"drawingHF" => {
                                f_drawing_h_f = Some(Box::new(DrawingHeaderFooter::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"picture" => {
                                f_picture = Some(Box::new(SheetBackgroundPicture::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"webPublishItems" => {
                                f_web_publish_items =
                                    Some(Box::new(WebPublishItems::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"sheetPr" => {
                                f_sheet_properties = Some(Box::new(
                                    ChartsheetProperties::from_xml(reader, &e, true)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sheetViews" => {
                                f_sheet_views =
                                    Some(Box::new(ChartsheetViews::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sheetProtection" => {
                                f_sheet_protection = Some(Box::new(
                                    ChartsheetProtection::from_xml(reader, &e, true)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"customSheetViews" => {
                                f_custom_sheet_views = Some(Box::new(
                                    CustomChartsheetViews::from_xml(reader, &e, true)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pageMargins" => {
                                f_page_margins =
                                    Some(Box::new(PageMargins::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pageSetup" => {
                                f_page_setup = Some(Box::new(ChartsheetPageSetup::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"headerFooter" => {
                                f_header_footer =
                                    Some(Box::new(HeaderFooter::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"drawing" => {
                                f_drawing = Some(Box::new(Drawing::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"legacyDrawing" => {
                                f_legacy_drawing =
                                    Some(Box::new(LegacyDrawing::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"legacyDrawingHF" => {
                                f_legacy_drawing_h_f =
                                    Some(Box::new(LegacyDrawing::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"drawingHF" => {
                                f_drawing_h_f = Some(Box::new(DrawingHeaderFooter::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"picture" => {
                                f_picture = Some(Box::new(SheetBackgroundPicture::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"webPublishItems" => {
                                f_web_publish_items =
                                    Some(Box::new(WebPublishItems::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            sheet_properties: f_sheet_properties,
            sheet_views: f_sheet_views
                .ok_or_else(|| ParseError::MissingAttribute("sheetViews".to_string()))?,
            sheet_protection: f_sheet_protection,
            custom_sheet_views: f_custom_sheet_views,
            page_margins: f_page_margins,
            page_setup: f_page_setup,
            header_footer: f_header_footer,
            drawing: f_drawing
                .ok_or_else(|| ParseError::MissingAttribute("drawing".to_string()))?,
            legacy_drawing: f_legacy_drawing,
            legacy_drawing_h_f: f_legacy_drawing_h_f,
            drawing_h_f: f_drawing_h_f,
            picture: f_picture,
            web_publish_items: f_web_publish_items,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for ChartsheetProperties {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_published = None;
        let mut f_code_name = None;
        let mut f_tab_color = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"published" => {
                    f_published = Some(val == "true" || val == "1");
                }
                b"codeName" => {
                    f_code_name = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"tabColor" => {
                                f_tab_color = Some(Box::new(Color::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"tabColor" => {
                                f_tab_color = Some(Box::new(Color::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            published: f_published,
            code_name: f_code_name,
            tab_color: f_tab_color,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for ChartsheetViews {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_sheet_view = Vec::new();
        let mut f_extension_list = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"sheetView" => {
                                f_sheet_view.push(ChartsheetView::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"sheetView" => {
                                f_sheet_view.push(ChartsheetView::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            sheet_view: f_sheet_view,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for ChartsheetView {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_tab_selected = None;
        let mut f_zoom_scale = None;
        let mut f_workbook_view_id: Option<u32> = None;
        let mut f_zoom_to_fit = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"tabSelected" => {
                    f_tab_selected = Some(val == "true" || val == "1");
                }
                b"zoomScale" => {
                    f_zoom_scale = val.parse().ok();
                }
                b"workbookViewId" => {
                    f_workbook_view_id = val.parse().ok();
                }
                b"zoomToFit" => {
                    f_zoom_to_fit = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            tab_selected: f_tab_selected,
            zoom_scale: f_zoom_scale,
            workbook_view_id: f_workbook_view_id
                .ok_or_else(|| ParseError::MissingAttribute("workbookViewId".to_string()))?,
            zoom_to_fit: f_zoom_to_fit,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for ChartsheetProtection {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_password = None;
        let mut f_algorithm_name = None;
        let mut f_hash_value = None;
        let mut f_salt_value = None;
        let mut f_spin_count = None;
        let mut f_content = None;
        let mut f_objects = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"password" => {
                    f_password = decode_hex(&val);
                }
                b"algorithmName" => {
                    f_algorithm_name = Some(val.into_owned());
                }
                b"hashValue" => {
                    f_hash_value = decode_hex(&val);
                }
                b"saltValue" => {
                    f_salt_value = decode_hex(&val);
                }
                b"spinCount" => {
                    f_spin_count = val.parse().ok();
                }
                b"content" => {
                    f_content = Some(val == "true" || val == "1");
                }
                b"objects" => {
                    f_objects = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            password: f_password,
            algorithm_name: f_algorithm_name,
            hash_value: f_hash_value,
            salt_value: f_salt_value,
            spin_count: f_spin_count,
            content: f_content,
            objects: f_objects,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for ChartsheetPageSetup {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_paper_size = None;
        let mut f_paper_height = None;
        let mut f_paper_width = None;
        let mut f_first_page_number = None;
        let mut f_orientation = None;
        let mut f_use_printer_defaults = None;
        let mut f_black_and_white = None;
        let mut f_draft = None;
        let mut f_use_first_page_number = None;
        let mut f_horizontal_dpi = None;
        let mut f_vertical_dpi = None;
        let mut f_copies = None;
        let mut f_id = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"paperSize" => {
                    f_paper_size = val.parse().ok();
                }
                b"paperHeight" => {
                    f_paper_height = Some(val.into_owned());
                }
                b"paperWidth" => {
                    f_paper_width = Some(val.into_owned());
                }
                b"firstPageNumber" => {
                    f_first_page_number = val.parse().ok();
                }
                b"orientation" => {
                    f_orientation = val.parse().ok();
                }
                b"usePrinterDefaults" => {
                    f_use_printer_defaults = Some(val == "true" || val == "1");
                }
                b"blackAndWhite" => {
                    f_black_and_white = Some(val == "true" || val == "1");
                }
                b"draft" => {
                    f_draft = Some(val == "true" || val == "1");
                }
                b"useFirstPageNumber" => {
                    f_use_first_page_number = Some(val == "true" || val == "1");
                }
                b"horizontalDpi" => {
                    f_horizontal_dpi = val.parse().ok();
                }
                b"verticalDpi" => {
                    f_vertical_dpi = val.parse().ok();
                }
                b"copies" => {
                    f_copies = val.parse().ok();
                }
                b"id" => {
                    f_id = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            paper_size: f_paper_size,
            paper_height: f_paper_height,
            paper_width: f_paper_width,
            first_page_number: f_first_page_number,
            orientation: f_orientation,
            use_printer_defaults: f_use_printer_defaults,
            black_and_white: f_black_and_white,
            draft: f_draft,
            use_first_page_number: f_use_first_page_number,
            horizontal_dpi: f_horizontal_dpi,
            vertical_dpi: f_vertical_dpi,
            copies: f_copies,
            id: f_id,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CustomChartsheetViews {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_custom_sheet_view = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"customSheetView" => {
                                f_custom_sheet_view
                                    .push(CustomChartsheetView::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"customSheetView" => {
                                f_custom_sheet_view
                                    .push(CustomChartsheetView::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            custom_sheet_view: f_custom_sheet_view,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CustomChartsheetView {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_guid: Option<Guid> = None;
        let mut f_scale = None;
        let mut f_state = None;
        let mut f_zoom_to_fit = None;
        let mut f_page_margins = None;
        let mut f_page_setup = None;
        let mut f_header_footer = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"guid" => {
                    f_guid = Some(val.into_owned());
                }
                b"scale" => {
                    f_scale = val.parse().ok();
                }
                b"state" => {
                    f_state = val.parse().ok();
                }
                b"zoomToFit" => {
                    f_zoom_to_fit = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"pageMargins" => {
                                f_page_margins =
                                    Some(Box::new(PageMargins::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pageSetup" => {
                                f_page_setup = Some(Box::new(ChartsheetPageSetup::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"headerFooter" => {
                                f_header_footer =
                                    Some(Box::new(HeaderFooter::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"pageMargins" => {
                                f_page_margins =
                                    Some(Box::new(PageMargins::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"pageSetup" => {
                                f_page_setup = Some(Box::new(ChartsheetPageSetup::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"headerFooter" => {
                                f_header_footer =
                                    Some(Box::new(HeaderFooter::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            guid: f_guid.ok_or_else(|| ParseError::MissingAttribute("guid".to_string()))?,
            scale: f_scale,
            state: f_state,
            zoom_to_fit: f_zoom_to_fit,
            page_margins: f_page_margins,
            page_setup: f_page_setup,
            header_footer: f_header_footer,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTCustomProperties {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_custom_pr = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"customPr" => {
                                f_custom_pr.push(CTCustomProperty::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"customPr" => {
                                f_custom_pr.push(CTCustomProperty::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            custom_pr: f_custom_pr,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTCustomProperty {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name: Option<XmlString> = None;
        let mut f_id: Option<STRelationshipId> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"id" => {
                    f_id = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for OleObjects {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_ole_object = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"oleObject" => {
                                f_ole_object.push(OleObject::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"oleObject" => {
                                f_ole_object.push(OleObject::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            ole_object: f_ole_object,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for OleObject {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_prog_id = None;
        let mut f_dv_aspect = None;
        let mut f_link = None;
        let mut f_ole_update = None;
        let mut f_auto_load = None;
        let mut f_shape_id: Option<u32> = None;
        let mut f_id = None;
        let mut f_object_pr = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"progId" => {
                    f_prog_id = Some(val.into_owned());
                }
                b"dvAspect" => {
                    f_dv_aspect = val.parse().ok();
                }
                b"link" => {
                    f_link = Some(val.into_owned());
                }
                b"oleUpdate" => {
                    f_ole_update = val.parse().ok();
                }
                b"autoLoad" => {
                    f_auto_load = Some(val == "true" || val == "1");
                }
                b"shapeId" => {
                    f_shape_id = val.parse().ok();
                }
                b"id" => {
                    f_id = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"objectPr" => {
                                f_object_pr =
                                    Some(Box::new(ObjectProperties::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"objectPr" => {
                                f_object_pr =
                                    Some(Box::new(ObjectProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            prog_id: f_prog_id,
            dv_aspect: f_dv_aspect,
            link: f_link,
            ole_update: f_ole_update,
            auto_load: f_auto_load,
            shape_id: f_shape_id
                .ok_or_else(|| ParseError::MissingAttribute("shapeId".to_string()))?,
            id: f_id,
            object_pr: f_object_pr,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for ObjectProperties {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_locked = None;
        let mut f_default_size = None;
        let mut f_print = None;
        let mut f_disabled = None;
        let mut f_ui_object = None;
        let mut f_auto_fill = None;
        let mut f_auto_line = None;
        let mut f_auto_pict = None;
        let mut f_macro = None;
        let mut f_alt_text = None;
        let mut f_dde = None;
        let mut f_id = None;
        let mut f_anchor: Option<Box<ObjectAnchor>> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"locked" => {
                    f_locked = Some(val == "true" || val == "1");
                }
                b"defaultSize" => {
                    f_default_size = Some(val == "true" || val == "1");
                }
                b"print" => {
                    f_print = Some(val == "true" || val == "1");
                }
                b"disabled" => {
                    f_disabled = Some(val == "true" || val == "1");
                }
                b"uiObject" => {
                    f_ui_object = Some(val == "true" || val == "1");
                }
                b"autoFill" => {
                    f_auto_fill = Some(val == "true" || val == "1");
                }
                b"autoLine" => {
                    f_auto_line = Some(val == "true" || val == "1");
                }
                b"autoPict" => {
                    f_auto_pict = Some(val == "true" || val == "1");
                }
                b"macro" => {
                    f_macro = Some(val.into_owned());
                }
                b"altText" => {
                    f_alt_text = Some(val.into_owned());
                }
                b"dde" => {
                    f_dde = Some(val == "true" || val == "1");
                }
                b"id" => {
                    f_id = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"anchor" => {
                                f_anchor =
                                    Some(Box::new(ObjectAnchor::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"anchor" => {
                                f_anchor =
                                    Some(Box::new(ObjectAnchor::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            locked: f_locked,
            default_size: f_default_size,
            print: f_print,
            disabled: f_disabled,
            ui_object: f_ui_object,
            auto_fill: f_auto_fill,
            auto_line: f_auto_line,
            auto_pict: f_auto_pict,
            r#macro: f_macro,
            alt_text: f_alt_text,
            dde: f_dde,
            id: f_id,
            anchor: f_anchor.ok_or_else(|| ParseError::MissingAttribute("anchor".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for WebPublishItems {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_web_publish_item = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"webPublishItem" => {
                                f_web_publish_item
                                    .push(WebPublishItem::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"webPublishItem" => {
                                f_web_publish_item
                                    .push(WebPublishItem::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            web_publish_item: f_web_publish_item,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for WebPublishItem {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<u32> = None;
        let mut f_div_id: Option<XmlString> = None;
        let mut f_source_type: Option<STWebSourceType> = None;
        let mut f_source_ref = None;
        let mut f_source_object = None;
        let mut f_destination_file: Option<XmlString> = None;
        let mut f_title = None;
        let mut f_auto_republish = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"divId" => {
                    f_div_id = Some(val.into_owned());
                }
                b"sourceType" => {
                    f_source_type = val.parse().ok();
                }
                b"sourceRef" => {
                    f_source_ref = Some(val.into_owned());
                }
                b"sourceObject" => {
                    f_source_object = Some(val.into_owned());
                }
                b"destinationFile" => {
                    f_destination_file = Some(val.into_owned());
                }
                b"title" => {
                    f_title = Some(val.into_owned());
                }
                b"autoRepublish" => {
                    f_auto_republish = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            div_id: f_div_id.ok_or_else(|| ParseError::MissingAttribute("divId".to_string()))?,
            source_type: f_source_type
                .ok_or_else(|| ParseError::MissingAttribute("sourceType".to_string()))?,
            source_ref: f_source_ref,
            source_object: f_source_object,
            destination_file: f_destination_file
                .ok_or_else(|| ParseError::MissingAttribute("destinationFile".to_string()))?,
            title: f_title,
            auto_republish: f_auto_republish,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for Controls {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_control = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"control" => {
                                f_control.push(Control::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"control" => {
                                f_control.push(Control::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            control: f_control,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Control {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_shape_id: Option<u32> = None;
        let mut f_id: Option<STRelationshipId> = None;
        let mut f_name = None;
        let mut f_control_pr = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"shapeId" => {
                    f_shape_id = val.parse().ok();
                }
                b"id" => {
                    f_id = Some(val.into_owned());
                }
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"controlPr" => {
                                f_control_pr =
                                    Some(Box::new(CTControlPr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"controlPr" => {
                                f_control_pr =
                                    Some(Box::new(CTControlPr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            shape_id: f_shape_id
                .ok_or_else(|| ParseError::MissingAttribute("shapeId".to_string()))?,
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            name: f_name,
            control_pr: f_control_pr,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTControlPr {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_locked = None;
        let mut f_default_size = None;
        let mut f_print = None;
        let mut f_disabled = None;
        let mut f_recalc_always = None;
        let mut f_ui_object = None;
        let mut f_auto_fill = None;
        let mut f_auto_line = None;
        let mut f_auto_pict = None;
        let mut f_macro = None;
        let mut f_alt_text = None;
        let mut f_linked_cell = None;
        let mut f_list_fill_range = None;
        let mut f_cf = None;
        let mut f_id = None;
        let mut f_anchor: Option<Box<ObjectAnchor>> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"locked" => {
                    f_locked = Some(val == "true" || val == "1");
                }
                b"defaultSize" => {
                    f_default_size = Some(val == "true" || val == "1");
                }
                b"print" => {
                    f_print = Some(val == "true" || val == "1");
                }
                b"disabled" => {
                    f_disabled = Some(val == "true" || val == "1");
                }
                b"recalcAlways" => {
                    f_recalc_always = Some(val == "true" || val == "1");
                }
                b"uiObject" => {
                    f_ui_object = Some(val == "true" || val == "1");
                }
                b"autoFill" => {
                    f_auto_fill = Some(val == "true" || val == "1");
                }
                b"autoLine" => {
                    f_auto_line = Some(val == "true" || val == "1");
                }
                b"autoPict" => {
                    f_auto_pict = Some(val == "true" || val == "1");
                }
                b"macro" => {
                    f_macro = Some(val.into_owned());
                }
                b"altText" => {
                    f_alt_text = Some(val.into_owned());
                }
                b"linkedCell" => {
                    f_linked_cell = Some(val.into_owned());
                }
                b"listFillRange" => {
                    f_list_fill_range = Some(val.into_owned());
                }
                b"cf" => {
                    f_cf = Some(val.into_owned());
                }
                b"id" => {
                    f_id = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"anchor" => {
                                f_anchor =
                                    Some(Box::new(ObjectAnchor::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"anchor" => {
                                f_anchor =
                                    Some(Box::new(ObjectAnchor::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            locked: f_locked,
            default_size: f_default_size,
            print: f_print,
            disabled: f_disabled,
            recalc_always: f_recalc_always,
            ui_object: f_ui_object,
            auto_fill: f_auto_fill,
            auto_line: f_auto_line,
            auto_pict: f_auto_pict,
            r#macro: f_macro,
            alt_text: f_alt_text,
            linked_cell: f_linked_cell,
            list_fill_range: f_list_fill_range,
            cf: f_cf,
            id: f_id,
            anchor: f_anchor.ok_or_else(|| ParseError::MissingAttribute("anchor".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for IgnoredErrors {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_ignored_error = Vec::new();
        let mut f_extension_list = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"ignoredError" => {
                                f_ignored_error.push(IgnoredError::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"ignoredError" => {
                                f_ignored_error.push(IgnoredError::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            ignored_error: f_ignored_error,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for IgnoredError {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_square_reference: Option<SquareRef> = None;
        let mut f_eval_error = None;
        let mut f_two_digit_text_year = None;
        let mut f_number_stored_as_text = None;
        let mut f_formula = None;
        let mut f_formula_range = None;
        let mut f_unlocked_formula = None;
        let mut f_empty_cell_reference = None;
        let mut f_list_data_validation = None;
        let mut f_calculated_column = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"sqref" => {
                    f_square_reference = Some(val.into_owned());
                }
                b"evalError" => {
                    f_eval_error = Some(val == "true" || val == "1");
                }
                b"twoDigitTextYear" => {
                    f_two_digit_text_year = Some(val == "true" || val == "1");
                }
                b"numberStoredAsText" => {
                    f_number_stored_as_text = Some(val == "true" || val == "1");
                }
                b"formula" => {
                    f_formula = Some(val == "true" || val == "1");
                }
                b"formulaRange" => {
                    f_formula_range = Some(val == "true" || val == "1");
                }
                b"unlockedFormula" => {
                    f_unlocked_formula = Some(val == "true" || val == "1");
                }
                b"emptyCellReference" => {
                    f_empty_cell_reference = Some(val == "true" || val == "1");
                }
                b"listDataValidation" => {
                    f_list_data_validation = Some(val == "true" || val == "1");
                }
                b"calculatedColumn" => {
                    f_calculated_column = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            square_reference: f_square_reference
                .ok_or_else(|| ParseError::MissingAttribute("sqref".to_string()))?,
            eval_error: f_eval_error,
            two_digit_text_year: f_two_digit_text_year,
            number_stored_as_text: f_number_stored_as_text,
            formula: f_formula,
            formula_range: f_formula_range,
            unlocked_formula: f_unlocked_formula,
            empty_cell_reference: f_empty_cell_reference,
            list_data_validation: f_list_data_validation,
            calculated_column: f_calculated_column,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for TableParts {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_table_part = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"tablePart" => {
                                f_table_part.push(TablePart::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"tablePart" => {
                                f_table_part.push(TablePart::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            table_part: f_table_part,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for TablePart {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STRelationshipId> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for Metadata {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_metadata_types = None;
        let mut f_metadata_strings = None;
        let mut f_mdx_metadata = None;
        let mut f_future_metadata = Vec::new();
        let mut f_cell_metadata = None;
        let mut f_value_metadata = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"metadataTypes" => {
                                f_metadata_types =
                                    Some(Box::new(MetadataTypes::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"metadataStrings" => {
                                f_metadata_strings =
                                    Some(Box::new(MetadataStrings::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"mdxMetadata" => {
                                f_mdx_metadata =
                                    Some(Box::new(CTMdxMetadata::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"futureMetadata" => {
                                f_future_metadata
                                    .push(CTFutureMetadata::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cellMetadata" => {
                                f_cell_metadata =
                                    Some(Box::new(MetadataBlocks::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"valueMetadata" => {
                                f_value_metadata =
                                    Some(Box::new(MetadataBlocks::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"metadataTypes" => {
                                f_metadata_types =
                                    Some(Box::new(MetadataTypes::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"metadataStrings" => {
                                f_metadata_strings =
                                    Some(Box::new(MetadataStrings::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"mdxMetadata" => {
                                f_mdx_metadata =
                                    Some(Box::new(CTMdxMetadata::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"futureMetadata" => {
                                f_future_metadata
                                    .push(CTFutureMetadata::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"cellMetadata" => {
                                f_cell_metadata =
                                    Some(Box::new(MetadataBlocks::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"valueMetadata" => {
                                f_value_metadata =
                                    Some(Box::new(MetadataBlocks::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            metadata_types: f_metadata_types,
            metadata_strings: f_metadata_strings,
            mdx_metadata: f_mdx_metadata,
            future_metadata: f_future_metadata,
            cell_metadata: f_cell_metadata,
            value_metadata: f_value_metadata,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for MetadataTypes {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_metadata_type = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"metadataType" => {
                                f_metadata_type.push(MetadataType::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"metadataType" => {
                                f_metadata_type.push(MetadataType::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            metadata_type: f_metadata_type,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for MetadataType {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name: Option<XmlString> = None;
        let mut f_min_supported_version: Option<u32> = None;
        let mut f_ghost_row = None;
        let mut f_ghost_col = None;
        let mut f_edit = None;
        let mut f_delete = None;
        let mut f_copy = None;
        let mut f_paste_all = None;
        let mut f_paste_formulas = None;
        let mut f_paste_values = None;
        let mut f_paste_formats = None;
        let mut f_paste_comments = None;
        let mut f_paste_data_validation = None;
        let mut f_paste_borders = None;
        let mut f_paste_col_widths = None;
        let mut f_paste_number_formats = None;
        let mut f_merge = None;
        let mut f_split_first = None;
        let mut f_split_all = None;
        let mut f_row_col_shift = None;
        let mut f_clear_all = None;
        let mut f_clear_formats = None;
        let mut f_clear_contents = None;
        let mut f_clear_comments = None;
        let mut f_assign = None;
        let mut f_coerce = None;
        let mut f_adjust = None;
        let mut f_cell_meta = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"minSupportedVersion" => {
                    f_min_supported_version = val.parse().ok();
                }
                b"ghostRow" => {
                    f_ghost_row = Some(val == "true" || val == "1");
                }
                b"ghostCol" => {
                    f_ghost_col = Some(val == "true" || val == "1");
                }
                b"edit" => {
                    f_edit = Some(val == "true" || val == "1");
                }
                b"delete" => {
                    f_delete = Some(val == "true" || val == "1");
                }
                b"copy" => {
                    f_copy = Some(val == "true" || val == "1");
                }
                b"pasteAll" => {
                    f_paste_all = Some(val == "true" || val == "1");
                }
                b"pasteFormulas" => {
                    f_paste_formulas = Some(val == "true" || val == "1");
                }
                b"pasteValues" => {
                    f_paste_values = Some(val == "true" || val == "1");
                }
                b"pasteFormats" => {
                    f_paste_formats = Some(val == "true" || val == "1");
                }
                b"pasteComments" => {
                    f_paste_comments = Some(val == "true" || val == "1");
                }
                b"pasteDataValidation" => {
                    f_paste_data_validation = Some(val == "true" || val == "1");
                }
                b"pasteBorders" => {
                    f_paste_borders = Some(val == "true" || val == "1");
                }
                b"pasteColWidths" => {
                    f_paste_col_widths = Some(val == "true" || val == "1");
                }
                b"pasteNumberFormats" => {
                    f_paste_number_formats = Some(val == "true" || val == "1");
                }
                b"merge" => {
                    f_merge = Some(val == "true" || val == "1");
                }
                b"splitFirst" => {
                    f_split_first = Some(val == "true" || val == "1");
                }
                b"splitAll" => {
                    f_split_all = Some(val == "true" || val == "1");
                }
                b"rowColShift" => {
                    f_row_col_shift = Some(val == "true" || val == "1");
                }
                b"clearAll" => {
                    f_clear_all = Some(val == "true" || val == "1");
                }
                b"clearFormats" => {
                    f_clear_formats = Some(val == "true" || val == "1");
                }
                b"clearContents" => {
                    f_clear_contents = Some(val == "true" || val == "1");
                }
                b"clearComments" => {
                    f_clear_comments = Some(val == "true" || val == "1");
                }
                b"assign" => {
                    f_assign = Some(val == "true" || val == "1");
                }
                b"coerce" => {
                    f_coerce = Some(val == "true" || val == "1");
                }
                b"adjust" => {
                    f_adjust = Some(val == "true" || val == "1");
                }
                b"cellMeta" => {
                    f_cell_meta = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            min_supported_version: f_min_supported_version
                .ok_or_else(|| ParseError::MissingAttribute("minSupportedVersion".to_string()))?,
            ghost_row: f_ghost_row,
            ghost_col: f_ghost_col,
            edit: f_edit,
            delete: f_delete,
            copy: f_copy,
            paste_all: f_paste_all,
            paste_formulas: f_paste_formulas,
            paste_values: f_paste_values,
            paste_formats: f_paste_formats,
            paste_comments: f_paste_comments,
            paste_data_validation: f_paste_data_validation,
            paste_borders: f_paste_borders,
            paste_col_widths: f_paste_col_widths,
            paste_number_formats: f_paste_number_formats,
            merge: f_merge,
            split_first: f_split_first,
            split_all: f_split_all,
            row_col_shift: f_row_col_shift,
            clear_all: f_clear_all,
            clear_formats: f_clear_formats,
            clear_contents: f_clear_contents,
            clear_comments: f_clear_comments,
            assign: f_assign,
            coerce: f_coerce,
            adjust: f_adjust,
            cell_meta: f_cell_meta,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for MetadataBlocks {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_bk = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"bk" => {
                                f_bk.push(MetadataBlock::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"bk" => {
                                f_bk.push(MetadataBlock::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            bk: f_bk,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for MetadataBlock {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_rc = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"rc" => {
                                f_rc.push(MetadataRecord::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"rc" => {
                                f_rc.push(MetadataRecord::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            rc: f_rc,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for MetadataRecord {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_cell_type: Option<u32> = None;
        let mut f_value: Option<u32> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"t" => {
                    f_cell_type = val.parse().ok();
                }
                b"v" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            cell_type: f_cell_type.ok_or_else(|| ParseError::MissingAttribute("t".to_string()))?,
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("v".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTFutureMetadata {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name: Option<XmlString> = None;
        let mut f_count = None;
        let mut f_bk = Vec::new();
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"bk" => {
                                f_bk.push(CTFutureMetadataBlock::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"bk" => {
                                f_bk.push(CTFutureMetadataBlock::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            count: f_count,
            bk: f_bk,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTFutureMetadataBlock {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_extension_list = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            extension_list: f_extension_list,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTMdxMetadata {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_mdx = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"mdx" => {
                                f_mdx.push(CTMdx::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"mdx" => {
                                f_mdx.push(CTMdx::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            mdx: f_mdx,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTMdx {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_n: Option<u32> = None;
        let mut f_formula: Option<STMdxFunctionType> = None;
        let mut f_cell_type = None;
        let mut f_ms = None;
        let mut f_p = None;
        let mut f_k = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"n" => {
                    f_n = val.parse().ok();
                }
                b"f" => {
                    f_formula = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"t" => {
                                f_cell_type =
                                    Some(Box::new(CTMdxTuple::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"ms" => {
                                f_ms = Some(Box::new(CTMdxSet::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"p" => {
                                f_p =
                                    Some(Box::new(CTMdxMemeberProp::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"k" => {
                                f_k = Some(Box::new(CTMdxKPI::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"t" => {
                                f_cell_type =
                                    Some(Box::new(CTMdxTuple::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"ms" => {
                                f_ms = Some(Box::new(CTMdxSet::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"p" => {
                                f_p = Some(Box::new(CTMdxMemeberProp::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"k" => {
                                f_k = Some(Box::new(CTMdxKPI::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            n: f_n.ok_or_else(|| ParseError::MissingAttribute("n".to_string()))?,
            formula: f_formula.ok_or_else(|| ParseError::MissingAttribute("f".to_string()))?,
            cell_type: f_cell_type,
            ms: f_ms,
            p: f_p,
            k: f_k,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTMdxTuple {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_cells = None;
        let mut f_ct = None;
        let mut f_si = None;
        let mut f_fi = None;
        let mut f_bc = None;
        let mut f_fc = None;
        let mut f_i = None;
        let mut f_u = None;
        let mut f_st = None;
        let mut f_b = None;
        let mut f_n = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"c" => {
                    f_cells = val.parse().ok();
                }
                b"ct" => {
                    f_ct = Some(val.into_owned());
                }
                b"si" => {
                    f_si = val.parse().ok();
                }
                b"fi" => {
                    f_fi = val.parse().ok();
                }
                b"bc" => {
                    f_bc = decode_hex(&val);
                }
                b"fc" => {
                    f_fc = decode_hex(&val);
                }
                b"i" => {
                    f_i = Some(val == "true" || val == "1");
                }
                b"u" => {
                    f_u = Some(val == "true" || val == "1");
                }
                b"st" => {
                    f_st = Some(val == "true" || val == "1");
                }
                b"b" => {
                    f_b = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"n" => {
                                f_n.push(CTMetadataStringIndex::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"n" => {
                                f_n.push(CTMetadataStringIndex::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            cells: f_cells,
            ct: f_ct,
            si: f_si,
            fi: f_fi,
            bc: f_bc,
            fc: f_fc,
            i: f_i,
            u: f_u,
            st: f_st,
            b: f_b,
            n: f_n,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTMdxSet {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_ns: Option<u32> = None;
        let mut f_cells = None;
        let mut f_o = None;
        let mut f_n = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"ns" => {
                    f_ns = val.parse().ok();
                }
                b"c" => {
                    f_cells = val.parse().ok();
                }
                b"o" => {
                    f_o = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"n" => {
                                f_n.push(CTMetadataStringIndex::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"n" => {
                                f_n.push(CTMetadataStringIndex::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            ns: f_ns.ok_or_else(|| ParseError::MissingAttribute("ns".to_string()))?,
            cells: f_cells,
            o: f_o,
            n: f_n,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTMdxMemeberProp {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_n: Option<u32> = None;
        let mut f_np: Option<u32> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"n" => {
                    f_n = val.parse().ok();
                }
                b"np" => {
                    f_np = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            n: f_n.ok_or_else(|| ParseError::MissingAttribute("n".to_string()))?,
            np: f_np.ok_or_else(|| ParseError::MissingAttribute("np".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTMdxKPI {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_n: Option<u32> = None;
        let mut f_np: Option<u32> = None;
        let mut f_p: Option<STMdxKPIProperty> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"n" => {
                    f_n = val.parse().ok();
                }
                b"np" => {
                    f_np = val.parse().ok();
                }
                b"p" => {
                    f_p = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            n: f_n.ok_or_else(|| ParseError::MissingAttribute("n".to_string()))?,
            np: f_np.ok_or_else(|| ParseError::MissingAttribute("np".to_string()))?,
            p: f_p.ok_or_else(|| ParseError::MissingAttribute("p".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTMetadataStringIndex {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_x: Option<u32> = None;
        let mut f_style_index = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"x" => {
                    f_x = val.parse().ok();
                }
                b"s" => {
                    f_style_index = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            x: f_x.ok_or_else(|| ParseError::MissingAttribute("x".to_string()))?,
            style_index: f_style_index,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for MetadataStrings {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_style_index = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"s" => {
                                f_style_index.push(CTXStringElement::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"s" => {
                                f_style_index.push(CTXStringElement::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            style_index: f_style_index,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for SingleXmlCells {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_single_xml_cell = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"singleXmlCell" => {
                                f_single_xml_cell.push(SingleXmlCell::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"singleXmlCell" => {
                                f_single_xml_cell.push(SingleXmlCell::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            single_xml_cell: f_single_xml_cell,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for SingleXmlCell {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<u32> = None;
        let mut f_reference: Option<CellRef> = None;
        let mut f_connection_id: Option<u32> = None;
        let mut f_xml_cell_pr: Option<Box<XmlCellProperties>> = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"r" => {
                    f_reference = Some(val.into_owned());
                }
                b"connectionId" => {
                    f_connection_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"xmlCellPr" => {
                                f_xml_cell_pr =
                                    Some(Box::new(XmlCellProperties::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"xmlCellPr" => {
                                f_xml_cell_pr =
                                    Some(Box::new(XmlCellProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            reference: f_reference.ok_or_else(|| ParseError::MissingAttribute("r".to_string()))?,
            connection_id: f_connection_id
                .ok_or_else(|| ParseError::MissingAttribute("connectionId".to_string()))?,
            xml_cell_pr: f_xml_cell_pr
                .ok_or_else(|| ParseError::MissingAttribute("xmlCellPr".to_string()))?,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for XmlCellProperties {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<u32> = None;
        let mut f_unique_name = None;
        let mut f_xml_pr: Option<Box<XmlProperties>> = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"uniqueName" => {
                    f_unique_name = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"xmlPr" => {
                                f_xml_pr =
                                    Some(Box::new(XmlProperties::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"xmlPr" => {
                                f_xml_pr =
                                    Some(Box::new(XmlProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            unique_name: f_unique_name,
            xml_pr: f_xml_pr.ok_or_else(|| ParseError::MissingAttribute("xmlPr".to_string()))?,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for XmlProperties {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_map_id: Option<u32> = None;
        let mut f_xpath: Option<XmlString> = None;
        let mut f_xml_data_type: Option<STXmlDataType> = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"mapId" => {
                    f_map_id = val.parse().ok();
                }
                b"xpath" => {
                    f_xpath = Some(val.into_owned());
                }
                b"xmlDataType" => {
                    f_xml_data_type = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            map_id: f_map_id.ok_or_else(|| ParseError::MissingAttribute("mapId".to_string()))?,
            xpath: f_xpath.ok_or_else(|| ParseError::MissingAttribute("xpath".to_string()))?,
            xml_data_type: f_xml_data_type
                .ok_or_else(|| ParseError::MissingAttribute("xmlDataType".to_string()))?,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Stylesheet {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "sml-styling")]
        let mut f_num_fmts = None;
        #[cfg(feature = "sml-styling")]
        let mut f_fonts = None;
        #[cfg(feature = "sml-styling")]
        let mut f_fills = None;
        #[cfg(feature = "sml-styling")]
        let mut f_borders = None;
        #[cfg(feature = "sml-styling")]
        let mut f_cell_style_xfs = None;
        #[cfg(feature = "sml-styling")]
        let mut f_cell_xfs = None;
        #[cfg(feature = "sml-styling")]
        let mut f_cell_styles = None;
        #[cfg(feature = "sml-styling")]
        let mut f_dxfs = None;
        #[cfg(feature = "sml-styling")]
        let mut f_table_styles = None;
        #[cfg(feature = "sml-styling")]
        let mut f_colors = None;
        #[cfg(feature = "sml-extensions")]
        let mut f_extension_list = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "sml-styling")]
                            b"numFmts" => {
                                f_num_fmts =
                                    Some(Box::new(NumberFormats::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"fonts" => {
                                f_fonts = Some(Box::new(Fonts::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"fills" => {
                                f_fills = Some(Box::new(Fills::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"borders" => {
                                f_borders = Some(Box::new(Borders::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"cellStyleXfs" => {
                                f_cell_style_xfs =
                                    Some(Box::new(CellStyleFormats::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"cellXfs" => {
                                f_cell_xfs =
                                    Some(Box::new(CellFormats::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"cellStyles" => {
                                f_cell_styles =
                                    Some(Box::new(CellStyles::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"dxfs" => {
                                f_dxfs = Some(Box::new(DifferentialFormats::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"tableStyles" => {
                                f_table_styles =
                                    Some(Box::new(TableStyles::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"colors" => {
                                f_colors = Some(Box::new(Colors::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-extensions")]
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "sml-styling")]
                            b"numFmts" => {
                                f_num_fmts =
                                    Some(Box::new(NumberFormats::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"fonts" => {
                                f_fonts = Some(Box::new(Fonts::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"fills" => {
                                f_fills = Some(Box::new(Fills::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"borders" => {
                                f_borders = Some(Box::new(Borders::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"cellStyleXfs" => {
                                f_cell_style_xfs =
                                    Some(Box::new(CellStyleFormats::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"cellXfs" => {
                                f_cell_xfs =
                                    Some(Box::new(CellFormats::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"cellStyles" => {
                                f_cell_styles =
                                    Some(Box::new(CellStyles::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"dxfs" => {
                                f_dxfs = Some(Box::new(DifferentialFormats::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"tableStyles" => {
                                f_table_styles =
                                    Some(Box::new(TableStyles::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"colors" => {
                                f_colors = Some(Box::new(Colors::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-extensions")]
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            #[cfg(feature = "sml-styling")]
            num_fmts: f_num_fmts,
            #[cfg(feature = "sml-styling")]
            fonts: f_fonts,
            #[cfg(feature = "sml-styling")]
            fills: f_fills,
            #[cfg(feature = "sml-styling")]
            borders: f_borders,
            #[cfg(feature = "sml-styling")]
            cell_style_xfs: f_cell_style_xfs,
            #[cfg(feature = "sml-styling")]
            cell_xfs: f_cell_xfs,
            #[cfg(feature = "sml-styling")]
            cell_styles: f_cell_styles,
            #[cfg(feature = "sml-styling")]
            dxfs: f_dxfs,
            #[cfg(feature = "sml-styling")]
            table_styles: f_table_styles,
            #[cfg(feature = "sml-styling")]
            colors: f_colors,
            #[cfg(feature = "sml-extensions")]
            extension_list: f_extension_list,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CellAlignment {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_horizontal = None;
        let mut f_vertical = None;
        let mut f_text_rotation = None;
        let mut f_wrap_text = None;
        let mut f_indent = None;
        let mut f_relative_indent = None;
        let mut f_justify_last_line = None;
        let mut f_shrink_to_fit = None;
        let mut f_reading_order = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"horizontal" => {
                    f_horizontal = val.parse().ok();
                }
                b"vertical" => {
                    f_vertical = val.parse().ok();
                }
                b"textRotation" => {
                    f_text_rotation = Some(val.into_owned());
                }
                b"wrapText" => {
                    f_wrap_text = Some(val == "true" || val == "1");
                }
                b"indent" => {
                    f_indent = val.parse().ok();
                }
                b"relativeIndent" => {
                    f_relative_indent = val.parse().ok();
                }
                b"justifyLastLine" => {
                    f_justify_last_line = Some(val == "true" || val == "1");
                }
                b"shrinkToFit" => {
                    f_shrink_to_fit = Some(val == "true" || val == "1");
                }
                b"readingOrder" => {
                    f_reading_order = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            horizontal: f_horizontal,
            vertical: f_vertical,
            text_rotation: f_text_rotation,
            wrap_text: f_wrap_text,
            indent: f_indent,
            relative_indent: f_relative_indent,
            justify_last_line: f_justify_last_line,
            shrink_to_fit: f_shrink_to_fit,
            reading_order: f_reading_order,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for Borders {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_border = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"border" => {
                                f_border.push(Border::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"border" => {
                                f_border.push(Border::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            border: f_border,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Border {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "sml-styling")]
        let mut f_diagonal_up = None;
        #[cfg(feature = "sml-styling")]
        let mut f_diagonal_down = None;
        #[cfg(feature = "sml-styling")]
        let mut f_outline = None;
        let mut f_start = None;
        let mut f_end = None;
        #[cfg(feature = "sml-styling")]
        let mut f_left = None;
        #[cfg(feature = "sml-styling")]
        let mut f_right = None;
        #[cfg(feature = "sml-styling")]
        let mut f_top = None;
        #[cfg(feature = "sml-styling")]
        let mut f_bottom = None;
        #[cfg(feature = "sml-styling")]
        let mut f_diagonal = None;
        #[cfg(feature = "sml-styling")]
        let mut f_vertical = None;
        #[cfg(feature = "sml-styling")]
        let mut f_horizontal = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                #[cfg(feature = "sml-styling")]
                b"diagonalUp" => {
                    f_diagonal_up = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-styling")]
                b"diagonalDown" => {
                    f_diagonal_down = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-styling")]
                b"outline" => {
                    f_outline = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"start" => {
                                f_start =
                                    Some(Box::new(BorderProperties::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"end" => {
                                f_end =
                                    Some(Box::new(BorderProperties::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"left" => {
                                f_left =
                                    Some(Box::new(BorderProperties::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"right" => {
                                f_right =
                                    Some(Box::new(BorderProperties::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"top" => {
                                f_top =
                                    Some(Box::new(BorderProperties::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"bottom" => {
                                f_bottom =
                                    Some(Box::new(BorderProperties::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"diagonal" => {
                                f_diagonal =
                                    Some(Box::new(BorderProperties::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"vertical" => {
                                f_vertical =
                                    Some(Box::new(BorderProperties::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"horizontal" => {
                                f_horizontal =
                                    Some(Box::new(BorderProperties::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"start" => {
                                f_start =
                                    Some(Box::new(BorderProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"end" => {
                                f_end =
                                    Some(Box::new(BorderProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"left" => {
                                f_left =
                                    Some(Box::new(BorderProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"right" => {
                                f_right =
                                    Some(Box::new(BorderProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"top" => {
                                f_top =
                                    Some(Box::new(BorderProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"bottom" => {
                                f_bottom =
                                    Some(Box::new(BorderProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"diagonal" => {
                                f_diagonal =
                                    Some(Box::new(BorderProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"vertical" => {
                                f_vertical =
                                    Some(Box::new(BorderProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"horizontal" => {
                                f_horizontal =
                                    Some(Box::new(BorderProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            #[cfg(feature = "sml-styling")]
            diagonal_up: f_diagonal_up,
            #[cfg(feature = "sml-styling")]
            diagonal_down: f_diagonal_down,
            #[cfg(feature = "sml-styling")]
            outline: f_outline,
            start: f_start,
            end: f_end,
            #[cfg(feature = "sml-styling")]
            left: f_left,
            #[cfg(feature = "sml-styling")]
            right: f_right,
            #[cfg(feature = "sml-styling")]
            top: f_top,
            #[cfg(feature = "sml-styling")]
            bottom: f_bottom,
            #[cfg(feature = "sml-styling")]
            diagonal: f_diagonal,
            #[cfg(feature = "sml-styling")]
            vertical: f_vertical,
            #[cfg(feature = "sml-styling")]
            horizontal: f_horizontal,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for BorderProperties {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_style = None;
        let mut f_color = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"style" => {
                    f_style = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"color" => {
                                f_color = Some(Box::new(Color::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"color" => {
                                f_color = Some(Box::new(Color::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            style: f_style,
            color: f_color,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CellProtection {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_locked = None;
        let mut f_hidden = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"locked" => {
                    f_locked = Some(val == "true" || val == "1");
                }
                b"hidden" => {
                    f_hidden = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            locked: f_locked,
            hidden: f_hidden,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for Fonts {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_font = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"font" => {
                                f_font.push(Font::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"font" => {
                                f_font.push(Font::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            font: f_font,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Fills {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_fill = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"fill" => {
                                f_fill.push(Fill::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"fill" => {
                                f_fill.push(Fill::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            fill: f_fill,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Fill {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "sml-styling")]
        let mut f_pattern_fill = None;
        #[cfg(feature = "sml-styling")]
        let mut f_gradient_fill = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "sml-styling")]
                            b"patternFill" => {
                                f_pattern_fill =
                                    Some(Box::new(PatternFill::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"gradientFill" => {
                                f_gradient_fill =
                                    Some(Box::new(GradientFill::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "sml-styling")]
                            b"patternFill" => {
                                f_pattern_fill =
                                    Some(Box::new(PatternFill::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"gradientFill" => {
                                f_gradient_fill =
                                    Some(Box::new(GradientFill::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            #[cfg(feature = "sml-styling")]
            pattern_fill: f_pattern_fill,
            #[cfg(feature = "sml-styling")]
            gradient_fill: f_gradient_fill,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for PatternFill {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_pattern_type = None;
        let mut f_fg_color = None;
        let mut f_bg_color = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"patternType" => {
                    f_pattern_type = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"fgColor" => {
                                f_fg_color = Some(Box::new(Color::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bgColor" => {
                                f_bg_color = Some(Box::new(Color::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"fgColor" => {
                                f_fg_color = Some(Box::new(Color::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bgColor" => {
                                f_bg_color = Some(Box::new(Color::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            pattern_type: f_pattern_type,
            fg_color: f_fg_color,
            bg_color: f_bg_color,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Color {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_auto = None;
        let mut f_indexed = None;
        let mut f_rgb = None;
        let mut f_theme = None;
        let mut f_tint = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"auto" => {
                    f_auto = Some(val == "true" || val == "1");
                }
                b"indexed" => {
                    f_indexed = val.parse().ok();
                }
                b"rgb" => {
                    f_rgb = decode_hex(&val);
                }
                b"theme" => {
                    f_theme = val.parse().ok();
                }
                b"tint" => {
                    f_tint = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            auto: f_auto,
            indexed: f_indexed,
            rgb: f_rgb,
            theme: f_theme,
            tint: f_tint,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for GradientFill {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_type = None;
        let mut f_degree = None;
        let mut f_left = None;
        let mut f_right = None;
        let mut f_top = None;
        let mut f_bottom = None;
        let mut f_stop = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"type" => {
                    f_type = val.parse().ok();
                }
                b"degree" => {
                    f_degree = val.parse().ok();
                }
                b"left" => {
                    f_left = val.parse().ok();
                }
                b"right" => {
                    f_right = val.parse().ok();
                }
                b"top" => {
                    f_top = val.parse().ok();
                }
                b"bottom" => {
                    f_bottom = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"stop" => {
                                f_stop.push(GradientStop::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"stop" => {
                                f_stop.push(GradientStop::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r#type: f_type,
            degree: f_degree,
            left: f_left,
            right: f_right,
            top: f_top,
            bottom: f_bottom,
            stop: f_stop,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for GradientStop {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_position: Option<f64> = None;
        let mut f_color: Option<Box<Color>> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"position" => {
                    f_position = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"color" => {
                                f_color = Some(Box::new(Color::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"color" => {
                                f_color = Some(Box::new(Color::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            position: f_position
                .ok_or_else(|| ParseError::MissingAttribute("position".to_string()))?,
            color: f_color.ok_or_else(|| ParseError::MissingAttribute("color".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for NumberFormats {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_num_fmt = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"numFmt" => {
                                f_num_fmt.push(NumberFormat::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"numFmt" => {
                                f_num_fmt.push(NumberFormat::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            num_fmt: f_num_fmt,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for NumberFormat {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_number_format_id: Option<STNumFmtId> = None;
        let mut f_format_code: Option<XmlString> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"numFmtId" => {
                    f_number_format_id = val.parse().ok();
                }
                b"formatCode" => {
                    f_format_code = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            number_format_id: f_number_format_id
                .ok_or_else(|| ParseError::MissingAttribute("numFmtId".to_string()))?,
            format_code: f_format_code
                .ok_or_else(|| ParseError::MissingAttribute("formatCode".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CellStyleFormats {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_xf = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"xf" => {
                                f_xf.push(Format::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"xf" => {
                                f_xf.push(Format::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            xf: f_xf,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CellFormats {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_xf = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"xf" => {
                                f_xf.push(Format::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"xf" => {
                                f_xf.push(Format::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            xf: f_xf,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Format {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "sml-styling")]
        let mut f_number_format_id = None;
        #[cfg(feature = "sml-styling")]
        let mut f_font_id = None;
        #[cfg(feature = "sml-styling")]
        let mut f_fill_id = None;
        #[cfg(feature = "sml-styling")]
        let mut f_border_id = None;
        #[cfg(feature = "sml-styling")]
        let mut f_format_id = None;
        #[cfg(feature = "sml-styling")]
        let mut f_quote_prefix = None;
        #[cfg(feature = "sml-pivot")]
        let mut f_pivot_button = None;
        #[cfg(feature = "sml-styling")]
        let mut f_apply_number_format = None;
        #[cfg(feature = "sml-styling")]
        let mut f_apply_font = None;
        #[cfg(feature = "sml-styling")]
        let mut f_apply_fill = None;
        #[cfg(feature = "sml-styling")]
        let mut f_apply_border = None;
        #[cfg(feature = "sml-styling")]
        let mut f_apply_alignment = None;
        #[cfg(feature = "sml-styling")]
        let mut f_apply_protection = None;
        #[cfg(feature = "sml-styling")]
        let mut f_alignment = None;
        #[cfg(feature = "sml-protection")]
        let mut f_protection = None;
        #[cfg(feature = "sml-extensions")]
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                #[cfg(feature = "sml-styling")]
                b"numFmtId" => {
                    f_number_format_id = val.parse().ok();
                }
                #[cfg(feature = "sml-styling")]
                b"fontId" => {
                    f_font_id = val.parse().ok();
                }
                #[cfg(feature = "sml-styling")]
                b"fillId" => {
                    f_fill_id = val.parse().ok();
                }
                #[cfg(feature = "sml-styling")]
                b"borderId" => {
                    f_border_id = val.parse().ok();
                }
                #[cfg(feature = "sml-styling")]
                b"xfId" => {
                    f_format_id = val.parse().ok();
                }
                #[cfg(feature = "sml-styling")]
                b"quotePrefix" => {
                    f_quote_prefix = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-pivot")]
                b"pivotButton" => {
                    f_pivot_button = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-styling")]
                b"applyNumberFormat" => {
                    f_apply_number_format = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-styling")]
                b"applyFont" => {
                    f_apply_font = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-styling")]
                b"applyFill" => {
                    f_apply_fill = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-styling")]
                b"applyBorder" => {
                    f_apply_border = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-styling")]
                b"applyAlignment" => {
                    f_apply_alignment = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-styling")]
                b"applyProtection" => {
                    f_apply_protection = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "sml-styling")]
                            b"alignment" => {
                                f_alignment =
                                    Some(Box::new(CellAlignment::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-protection")]
                            b"protection" => {
                                f_protection =
                                    Some(Box::new(CellProtection::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-extensions")]
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "sml-styling")]
                            b"alignment" => {
                                f_alignment =
                                    Some(Box::new(CellAlignment::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-protection")]
                            b"protection" => {
                                f_protection =
                                    Some(Box::new(CellProtection::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-extensions")]
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            #[cfg(feature = "sml-styling")]
            number_format_id: f_number_format_id,
            #[cfg(feature = "sml-styling")]
            font_id: f_font_id,
            #[cfg(feature = "sml-styling")]
            fill_id: f_fill_id,
            #[cfg(feature = "sml-styling")]
            border_id: f_border_id,
            #[cfg(feature = "sml-styling")]
            format_id: f_format_id,
            #[cfg(feature = "sml-styling")]
            quote_prefix: f_quote_prefix,
            #[cfg(feature = "sml-pivot")]
            pivot_button: f_pivot_button,
            #[cfg(feature = "sml-styling")]
            apply_number_format: f_apply_number_format,
            #[cfg(feature = "sml-styling")]
            apply_font: f_apply_font,
            #[cfg(feature = "sml-styling")]
            apply_fill: f_apply_fill,
            #[cfg(feature = "sml-styling")]
            apply_border: f_apply_border,
            #[cfg(feature = "sml-styling")]
            apply_alignment: f_apply_alignment,
            #[cfg(feature = "sml-styling")]
            apply_protection: f_apply_protection,
            #[cfg(feature = "sml-styling")]
            alignment: f_alignment,
            #[cfg(feature = "sml-protection")]
            protection: f_protection,
            #[cfg(feature = "sml-extensions")]
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CellStyles {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_cell_style = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"cellStyle" => {
                                f_cell_style.push(CellStyle::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"cellStyle" => {
                                f_cell_style.push(CellStyle::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            cell_style: f_cell_style,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CellStyle {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name = None;
        let mut f_format_id: Option<STCellStyleXfId> = None;
        let mut f_builtin_id = None;
        let mut f_i_level = None;
        let mut f_hidden = None;
        let mut f_custom_builtin = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"xfId" => {
                    f_format_id = val.parse().ok();
                }
                b"builtinId" => {
                    f_builtin_id = val.parse().ok();
                }
                b"iLevel" => {
                    f_i_level = val.parse().ok();
                }
                b"hidden" => {
                    f_hidden = Some(val == "true" || val == "1");
                }
                b"customBuiltin" => {
                    f_custom_builtin = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name,
            format_id: f_format_id
                .ok_or_else(|| ParseError::MissingAttribute("xfId".to_string()))?,
            builtin_id: f_builtin_id,
            i_level: f_i_level,
            hidden: f_hidden,
            custom_builtin: f_custom_builtin,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for DifferentialFormats {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_dxf = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"dxf" => {
                                f_dxf.push(DifferentialFormat::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"dxf" => {
                                f_dxf.push(DifferentialFormat::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            dxf: f_dxf,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for DifferentialFormat {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_font = None;
        let mut f_num_fmt = None;
        let mut f_fill = None;
        let mut f_alignment = None;
        let mut f_border = None;
        let mut f_protection = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"font" => {
                                f_font = Some(Box::new(Font::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numFmt" => {
                                f_num_fmt =
                                    Some(Box::new(NumberFormat::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"fill" => {
                                f_fill = Some(Box::new(Fill::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"alignment" => {
                                f_alignment =
                                    Some(Box::new(CellAlignment::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"border" => {
                                f_border = Some(Box::new(Border::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"protection" => {
                                f_protection =
                                    Some(Box::new(CellProtection::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"font" => {
                                f_font = Some(Box::new(Font::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"numFmt" => {
                                f_num_fmt =
                                    Some(Box::new(NumberFormat::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"fill" => {
                                f_fill = Some(Box::new(Fill::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"alignment" => {
                                f_alignment =
                                    Some(Box::new(CellAlignment::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"border" => {
                                f_border = Some(Box::new(Border::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"protection" => {
                                f_protection =
                                    Some(Box::new(CellProtection::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            font: f_font,
            num_fmt: f_num_fmt,
            fill: f_fill,
            alignment: f_alignment,
            border: f_border,
            protection: f_protection,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Colors {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_indexed_colors = None;
        let mut f_mru_colors = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"indexedColors" => {
                                f_indexed_colors =
                                    Some(Box::new(IndexedColors::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"mruColors" => {
                                f_mru_colors =
                                    Some(Box::new(MostRecentColors::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"indexedColors" => {
                                f_indexed_colors =
                                    Some(Box::new(IndexedColors::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"mruColors" => {
                                f_mru_colors =
                                    Some(Box::new(MostRecentColors::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            indexed_colors: f_indexed_colors,
            mru_colors: f_mru_colors,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for IndexedColors {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_rgb_color = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"rgbColor" => {
                                f_rgb_color.push(RgbColor::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"rgbColor" => {
                                f_rgb_color.push(RgbColor::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            rgb_color: f_rgb_color,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for MostRecentColors {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_color = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"color" => {
                                f_color.push(Color::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"color" => {
                                f_color.push(Color::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            color: f_color,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for RgbColor {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_rgb = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"rgb" => {
                    f_rgb = decode_hex(&val);
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            rgb: f_rgb,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for TableStyles {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_default_table_style = None;
        let mut f_default_pivot_style = None;
        let mut f_table_style = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                b"defaultTableStyle" => {
                    f_default_table_style = Some(val.into_owned());
                }
                b"defaultPivotStyle" => {
                    f_default_pivot_style = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"tableStyle" => {
                                f_table_style.push(TableStyle::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"tableStyle" => {
                                f_table_style.push(TableStyle::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            default_table_style: f_default_table_style,
            default_pivot_style: f_default_pivot_style,
            table_style: f_table_style,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for TableStyle {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name: Option<String> = None;
        let mut f_pivot = None;
        let mut f_table = None;
        let mut f_count = None;
        let mut f_table_style_element = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"pivot" => {
                    f_pivot = Some(val == "true" || val == "1");
                }
                b"table" => {
                    f_table = Some(val == "true" || val == "1");
                }
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"tableStyleElement" => {
                                f_table_style_element
                                    .push(TableStyleElement::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"tableStyleElement" => {
                                f_table_style_element
                                    .push(TableStyleElement::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            pivot: f_pivot,
            table: f_table,
            count: f_count,
            table_style_element: f_table_style_element,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for TableStyleElement {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_type: Option<STTableStyleType> = None;
        let mut f_size = None;
        let mut f_dxf_id = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"type" => {
                    f_type = val.parse().ok();
                }
                b"size" => {
                    f_size = val.parse().ok();
                }
                b"dxfId" => {
                    f_dxf_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r#type: f_type.ok_or_else(|| ParseError::MissingAttribute("type".to_string()))?,
            size: f_size,
            dxf_id: f_dxf_id,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for BooleanProperty {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for FontSize {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<f64> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for IntProperty {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<i32> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for FontName {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<XmlString> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for VerticalAlignFontProperty {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<VerticalAlignRun> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for FontSchemeProperty {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<FontScheme> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for UnderlineProperty {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for Font {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "sml-styling")]
        let mut f_name = None;
        #[cfg(feature = "sml-styling")]
        let mut f_charset = None;
        #[cfg(feature = "sml-styling")]
        let mut f_family = None;
        #[cfg(feature = "sml-styling")]
        let mut f_b = None;
        #[cfg(feature = "sml-styling")]
        let mut f_i = None;
        #[cfg(feature = "sml-styling")]
        let mut f_strike = None;
        #[cfg(feature = "sml-styling")]
        let mut f_outline = None;
        #[cfg(feature = "sml-styling")]
        let mut f_shadow = None;
        #[cfg(feature = "sml-styling")]
        let mut f_condense = None;
        #[cfg(feature = "sml-styling")]
        let mut f_extend = None;
        #[cfg(feature = "sml-styling")]
        let mut f_color = None;
        #[cfg(feature = "sml-styling")]
        let mut f_sz = None;
        #[cfg(feature = "sml-styling")]
        let mut f_u = None;
        #[cfg(feature = "sml-styling")]
        let mut f_vert_align = None;
        #[cfg(feature = "sml-styling")]
        let mut f_scheme = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "sml-styling")]
                            b"name" => {
                                f_name = Some(Box::new(FontName::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"charset" => {
                                f_charset =
                                    Some(Box::new(IntProperty::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"family" => {
                                f_family = Some(Box::new(FontFamily::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"b" => {
                                f_b = Some(Box::new(BooleanProperty::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"i" => {
                                f_i = Some(Box::new(BooleanProperty::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"strike" => {
                                f_strike =
                                    Some(Box::new(BooleanProperty::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"outline" => {
                                f_outline =
                                    Some(Box::new(BooleanProperty::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"shadow" => {
                                f_shadow =
                                    Some(Box::new(BooleanProperty::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"condense" => {
                                f_condense =
                                    Some(Box::new(BooleanProperty::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"extend" => {
                                f_extend =
                                    Some(Box::new(BooleanProperty::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"color" => {
                                f_color = Some(Box::new(Color::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"sz" => {
                                f_sz = Some(Box::new(FontSize::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"u" => {
                                f_u =
                                    Some(Box::new(UnderlineProperty::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"vertAlign" => {
                                f_vert_align = Some(Box::new(VerticalAlignFontProperty::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"scheme" => {
                                f_scheme = Some(Box::new(FontSchemeProperty::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "sml-styling")]
                            b"name" => {
                                f_name = Some(Box::new(FontName::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"charset" => {
                                f_charset =
                                    Some(Box::new(IntProperty::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"family" => {
                                f_family = Some(Box::new(FontFamily::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"b" => {
                                f_b = Some(Box::new(BooleanProperty::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"i" => {
                                f_i = Some(Box::new(BooleanProperty::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"strike" => {
                                f_strike =
                                    Some(Box::new(BooleanProperty::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"outline" => {
                                f_outline =
                                    Some(Box::new(BooleanProperty::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"shadow" => {
                                f_shadow =
                                    Some(Box::new(BooleanProperty::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"condense" => {
                                f_condense =
                                    Some(Box::new(BooleanProperty::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"extend" => {
                                f_extend =
                                    Some(Box::new(BooleanProperty::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"color" => {
                                f_color = Some(Box::new(Color::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"sz" => {
                                f_sz = Some(Box::new(FontSize::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"u" => {
                                f_u =
                                    Some(Box::new(UnderlineProperty::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"vertAlign" => {
                                f_vert_align = Some(Box::new(VerticalAlignFontProperty::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-styling")]
                            b"scheme" => {
                                f_scheme =
                                    Some(Box::new(FontSchemeProperty::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            #[cfg(feature = "sml-styling")]
            name: f_name,
            #[cfg(feature = "sml-styling")]
            charset: f_charset,
            #[cfg(feature = "sml-styling")]
            family: f_family,
            #[cfg(feature = "sml-styling")]
            b: f_b,
            #[cfg(feature = "sml-styling")]
            i: f_i,
            #[cfg(feature = "sml-styling")]
            strike: f_strike,
            #[cfg(feature = "sml-styling")]
            outline: f_outline,
            #[cfg(feature = "sml-styling")]
            shadow: f_shadow,
            #[cfg(feature = "sml-styling")]
            condense: f_condense,
            #[cfg(feature = "sml-styling")]
            extend: f_extend,
            #[cfg(feature = "sml-styling")]
            color: f_color,
            #[cfg(feature = "sml-styling")]
            sz: f_sz,
            #[cfg(feature = "sml-styling")]
            u: f_u,
            #[cfg(feature = "sml-styling")]
            vert_align: f_vert_align,
            #[cfg(feature = "sml-styling")]
            scheme: f_scheme,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for FontFamily {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value: Option<STFontFamily> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for SmlAGAutoFormat {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_auto_format_id = None;
        let mut f_apply_number_formats = None;
        let mut f_apply_border_formats = None;
        let mut f_apply_font_formats = None;
        let mut f_apply_pattern_formats = None;
        let mut f_apply_alignment_formats = None;
        let mut f_apply_width_height_formats = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"autoFormatId" => {
                    f_auto_format_id = val.parse().ok();
                }
                b"applyNumberFormats" => {
                    f_apply_number_formats = Some(val == "true" || val == "1");
                }
                b"applyBorderFormats" => {
                    f_apply_border_formats = Some(val == "true" || val == "1");
                }
                b"applyFontFormats" => {
                    f_apply_font_formats = Some(val == "true" || val == "1");
                }
                b"applyPatternFormats" => {
                    f_apply_pattern_formats = Some(val == "true" || val == "1");
                }
                b"applyAlignmentFormats" => {
                    f_apply_alignment_formats = Some(val == "true" || val == "1");
                }
                b"applyWidthHeightFormats" => {
                    f_apply_width_height_formats = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            auto_format_id: f_auto_format_id,
            apply_number_formats: f_apply_number_formats,
            apply_border_formats: f_apply_border_formats,
            apply_font_formats: f_apply_font_formats,
            apply_pattern_formats: f_apply_pattern_formats,
            apply_alignment_formats: f_apply_alignment_formats,
            apply_width_height_formats: f_apply_width_height_formats,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for ExternalLink {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_external_book = None;
        let mut f_dde_link = None;
        let mut f_ole_link = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"externalBook" => {
                                f_external_book =
                                    Some(Box::new(ExternalBook::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"ddeLink" => {
                                f_dde_link = Some(Box::new(DdeLink::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"oleLink" => {
                                f_ole_link = Some(Box::new(OleLink::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"externalBook" => {
                                f_external_book =
                                    Some(Box::new(ExternalBook::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"ddeLink" => {
                                f_dde_link = Some(Box::new(DdeLink::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"oleLink" => {
                                f_ole_link = Some(Box::new(OleLink::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            external_book: f_external_book,
            dde_link: f_dde_link,
            ole_link: f_ole_link,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for ExternalBook {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STRelationshipId> = None;
        let mut f_sheet_names = None;
        let mut f_defined_names = None;
        let mut f_sheet_data_set = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"sheetNames" => {
                                f_sheet_names = Some(Box::new(CTExternalSheetNames::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"definedNames" => {
                                f_defined_names = Some(Box::new(CTExternalDefinedNames::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sheetDataSet" => {
                                f_sheet_data_set = Some(Box::new(ExternalSheetDataSet::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"sheetNames" => {
                                f_sheet_names = Some(Box::new(CTExternalSheetNames::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"definedNames" => {
                                f_defined_names = Some(Box::new(CTExternalDefinedNames::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sheetDataSet" => {
                                f_sheet_data_set = Some(Box::new(ExternalSheetDataSet::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            sheet_names: f_sheet_names,
            defined_names: f_defined_names,
            sheet_data_set: f_sheet_data_set,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTExternalSheetNames {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_sheet_name = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"sheetName" => {
                                f_sheet_name
                                    .push(CTExternalSheetName::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"sheetName" => {
                                f_sheet_name.push(CTExternalSheetName::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            sheet_name: f_sheet_name,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTExternalSheetName {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_value = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"val" => {
                    f_value = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            value: f_value,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTExternalDefinedNames {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_defined_name = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"definedName" => {
                                f_defined_name
                                    .push(CTExternalDefinedName::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"definedName" => {
                                f_defined_name
                                    .push(CTExternalDefinedName::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            defined_name: f_defined_name,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTExternalDefinedName {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name: Option<XmlString> = None;
        let mut f_refers_to = None;
        let mut f_sheet_id = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"refersTo" => {
                    f_refers_to = Some(val.into_owned());
                }
                b"sheetId" => {
                    f_sheet_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            refers_to: f_refers_to,
            sheet_id: f_sheet_id,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for ExternalSheetDataSet {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_sheet_data = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"sheetData" => {
                                f_sheet_data.push(ExternalSheetData::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"sheetData" => {
                                f_sheet_data.push(ExternalSheetData::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            sheet_data: f_sheet_data,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for ExternalSheetData {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_sheet_id: Option<u32> = None;
        let mut f_refresh_error = None;
        let mut f_row = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"sheetId" => {
                    f_sheet_id = val.parse().ok();
                }
                b"refreshError" => {
                    f_refresh_error = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"row" => {
                                f_row.push(ExternalRow::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"row" => {
                                f_row.push(ExternalRow::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            sheet_id: f_sheet_id
                .ok_or_else(|| ParseError::MissingAttribute("sheetId".to_string()))?,
            refresh_error: f_refresh_error,
            row: f_row,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for ExternalRow {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_reference: Option<u32> = None;
        let mut f_cell = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"r" => {
                    f_reference = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"cell" => {
                                f_cell.push(ExternalCell::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"cell" => {
                                f_cell.push(ExternalCell::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            reference: f_reference.ok_or_else(|| ParseError::MissingAttribute("r".to_string()))?,
            cell: f_cell,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for ExternalCell {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_reference = None;
        let mut f_cell_type = None;
        let mut f_vm = None;
        let mut f_value = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"r" => {
                    f_reference = Some(val.into_owned());
                }
                b"t" => {
                    f_cell_type = val.parse().ok();
                }
                b"vm" => {
                    f_vm = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"v" => {
                                f_value = Some(read_text_content(reader)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"v" => {
                                f_value = Some(String::new());
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            reference: f_reference,
            cell_type: f_cell_type,
            vm: f_vm,
            value: f_value,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for DdeLink {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_dde_service: Option<XmlString> = None;
        let mut f_dde_topic: Option<XmlString> = None;
        let mut f_dde_items = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"ddeService" => {
                    f_dde_service = Some(val.into_owned());
                }
                b"ddeTopic" => {
                    f_dde_topic = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"ddeItems" => {
                                f_dde_items =
                                    Some(Box::new(DdeItems::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"ddeItems" => {
                                f_dde_items = Some(Box::new(DdeItems::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            dde_service: f_dde_service
                .ok_or_else(|| ParseError::MissingAttribute("ddeService".to_string()))?,
            dde_topic: f_dde_topic
                .ok_or_else(|| ParseError::MissingAttribute("ddeTopic".to_string()))?,
            dde_items: f_dde_items,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for DdeItems {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_dde_item = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"ddeItem" => {
                                f_dde_item.push(DdeItem::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"ddeItem" => {
                                f_dde_item.push(DdeItem::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            dde_item: f_dde_item,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for DdeItem {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name = None;
        let mut f_ole = None;
        let mut f_advise = None;
        let mut f_prefer_pic = None;
        let mut f_values = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"ole" => {
                    f_ole = Some(val == "true" || val == "1");
                }
                b"advise" => {
                    f_advise = Some(val == "true" || val == "1");
                }
                b"preferPic" => {
                    f_prefer_pic = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"values" => {
                                f_values =
                                    Some(Box::new(CTDdeValues::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"values" => {
                                f_values = Some(Box::new(CTDdeValues::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name,
            ole: f_ole,
            advise: f_advise,
            prefer_pic: f_prefer_pic,
            values: f_values,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTDdeValues {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_rows = None;
        let mut f_cols = None;
        let mut f_value = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"rows" => {
                    f_rows = val.parse().ok();
                }
                b"cols" => {
                    f_cols = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"value" => {
                                f_value.push(CTDdeValue::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"value" => {
                                f_value.push(CTDdeValue::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            rows: f_rows,
            cols: f_cols,
            value: f_value,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTDdeValue {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_cell_type = None;
        let mut f_value: Option<XmlString> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"t" => {
                    f_cell_type = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"val" => {
                                f_value = Some(read_text_content(reader)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"val" => {
                                f_value = Some(String::new());
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            cell_type: f_cell_type,
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("val".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for OleLink {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STRelationshipId> = None;
        let mut f_prog_id: Option<XmlString> = None;
        let mut f_ole_items = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = Some(val.into_owned());
                }
                b"progId" => {
                    f_prog_id = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"oleItems" => {
                                f_ole_items =
                                    Some(Box::new(OleItems::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"oleItems" => {
                                f_ole_items = Some(Box::new(OleItems::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            prog_id: f_prog_id.ok_or_else(|| ParseError::MissingAttribute("progId".to_string()))?,
            ole_items: f_ole_items,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for OleItems {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_ole_item = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"oleItem" => {
                                f_ole_item.push(OleItem::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"oleItem" => {
                                f_ole_item.push(OleItem::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            ole_item: f_ole_item,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for OleItem {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name: Option<XmlString> = None;
        let mut f_icon = None;
        let mut f_advise = None;
        let mut f_prefer_pic = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"icon" => {
                    f_icon = Some(val == "true" || val == "1");
                }
                b"advise" => {
                    f_advise = Some(val == "true" || val == "1");
                }
                b"preferPic" => {
                    f_prefer_pic = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            icon: f_icon,
            advise: f_advise,
            prefer_pic: f_prefer_pic,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for Table {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        #[cfg(feature = "sml-tables")]
        let mut f_id: Option<u32> = None;
        #[cfg(feature = "sml-tables")]
        let mut f_name = None;
        #[cfg(feature = "sml-tables")]
        let mut f_display_name: Option<XmlString> = None;
        #[cfg(feature = "sml-tables")]
        let mut f_comment = None;
        #[cfg(feature = "sml-tables")]
        let mut f_reference: Option<Reference> = None;
        #[cfg(feature = "sml-tables")]
        let mut f_table_type = None;
        #[cfg(feature = "sml-tables")]
        let mut f_header_row_count = None;
        #[cfg(feature = "sml-tables")]
        let mut f_insert_row = None;
        #[cfg(feature = "sml-tables")]
        let mut f_insert_row_shift = None;
        #[cfg(feature = "sml-tables")]
        let mut f_totals_row_count = None;
        #[cfg(feature = "sml-tables")]
        let mut f_totals_row_shown = None;
        #[cfg(feature = "sml-tables")]
        let mut f_published = None;
        #[cfg(feature = "sml-tables")]
        let mut f_header_row_dxf_id = None;
        #[cfg(feature = "sml-tables")]
        let mut f_data_dxf_id = None;
        #[cfg(feature = "sml-tables")]
        let mut f_totals_row_dxf_id = None;
        #[cfg(feature = "sml-tables")]
        let mut f_header_row_border_dxf_id = None;
        #[cfg(feature = "sml-tables")]
        let mut f_table_border_dxf_id = None;
        #[cfg(feature = "sml-tables")]
        let mut f_totals_row_border_dxf_id = None;
        #[cfg(feature = "sml-tables")]
        let mut f_header_row_cell_style = None;
        #[cfg(feature = "sml-tables")]
        let mut f_data_cell_style = None;
        #[cfg(feature = "sml-tables")]
        let mut f_totals_row_cell_style = None;
        #[cfg(feature = "sml-tables")]
        let mut f_connection_id = None;
        #[cfg(feature = "sml-tables")]
        let mut f_auto_filter = None;
        #[cfg(feature = "sml-tables")]
        let mut f_sort_state = None;
        #[cfg(feature = "sml-tables")]
        let mut f_table_columns: Option<Box<TableColumns>> = None;
        #[cfg(feature = "sml-tables")]
        let mut f_table_style_info = None;
        #[cfg(feature = "sml-extensions")]
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                #[cfg(feature = "sml-tables")]
                b"id" => {
                    f_id = val.parse().ok();
                }
                #[cfg(feature = "sml-tables")]
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                #[cfg(feature = "sml-tables")]
                b"displayName" => {
                    f_display_name = Some(val.into_owned());
                }
                #[cfg(feature = "sml-tables")]
                b"comment" => {
                    f_comment = Some(val.into_owned());
                }
                #[cfg(feature = "sml-tables")]
                b"ref" => {
                    f_reference = Some(val.into_owned());
                }
                #[cfg(feature = "sml-tables")]
                b"tableType" => {
                    f_table_type = val.parse().ok();
                }
                #[cfg(feature = "sml-tables")]
                b"headerRowCount" => {
                    f_header_row_count = val.parse().ok();
                }
                #[cfg(feature = "sml-tables")]
                b"insertRow" => {
                    f_insert_row = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-tables")]
                b"insertRowShift" => {
                    f_insert_row_shift = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-tables")]
                b"totalsRowCount" => {
                    f_totals_row_count = val.parse().ok();
                }
                #[cfg(feature = "sml-tables")]
                b"totalsRowShown" => {
                    f_totals_row_shown = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-tables")]
                b"published" => {
                    f_published = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-tables")]
                b"headerRowDxfId" => {
                    f_header_row_dxf_id = val.parse().ok();
                }
                #[cfg(feature = "sml-tables")]
                b"dataDxfId" => {
                    f_data_dxf_id = val.parse().ok();
                }
                #[cfg(feature = "sml-tables")]
                b"totalsRowDxfId" => {
                    f_totals_row_dxf_id = val.parse().ok();
                }
                #[cfg(feature = "sml-tables")]
                b"headerRowBorderDxfId" => {
                    f_header_row_border_dxf_id = val.parse().ok();
                }
                #[cfg(feature = "sml-tables")]
                b"tableBorderDxfId" => {
                    f_table_border_dxf_id = val.parse().ok();
                }
                #[cfg(feature = "sml-tables")]
                b"totalsRowBorderDxfId" => {
                    f_totals_row_border_dxf_id = val.parse().ok();
                }
                #[cfg(feature = "sml-tables")]
                b"headerRowCellStyle" => {
                    f_header_row_cell_style = Some(val.into_owned());
                }
                #[cfg(feature = "sml-tables")]
                b"dataCellStyle" => {
                    f_data_cell_style = Some(val.into_owned());
                }
                #[cfg(feature = "sml-tables")]
                b"totalsRowCellStyle" => {
                    f_totals_row_cell_style = Some(val.into_owned());
                }
                #[cfg(feature = "sml-tables")]
                b"connectionId" => {
                    f_connection_id = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "sml-tables")]
                            b"autoFilter" => {
                                f_auto_filter =
                                    Some(Box::new(AutoFilter::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-tables")]
                            b"sortState" => {
                                f_sort_state =
                                    Some(Box::new(SortState::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-tables")]
                            b"tableColumns" => {
                                f_table_columns =
                                    Some(Box::new(TableColumns::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-tables")]
                            b"tableStyleInfo" => {
                                f_table_style_info =
                                    Some(Box::new(TableStyleInfo::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-extensions")]
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "sml-tables")]
                            b"autoFilter" => {
                                f_auto_filter =
                                    Some(Box::new(AutoFilter::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-tables")]
                            b"sortState" => {
                                f_sort_state =
                                    Some(Box::new(SortState::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-tables")]
                            b"tableColumns" => {
                                f_table_columns =
                                    Some(Box::new(TableColumns::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-tables")]
                            b"tableStyleInfo" => {
                                f_table_style_info =
                                    Some(Box::new(TableStyleInfo::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-extensions")]
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            #[cfg(feature = "sml-tables")]
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            #[cfg(feature = "sml-tables")]
            name: f_name,
            #[cfg(feature = "sml-tables")]
            display_name: f_display_name
                .ok_or_else(|| ParseError::MissingAttribute("displayName".to_string()))?,
            #[cfg(feature = "sml-tables")]
            comment: f_comment,
            #[cfg(feature = "sml-tables")]
            reference: f_reference
                .ok_or_else(|| ParseError::MissingAttribute("ref".to_string()))?,
            #[cfg(feature = "sml-tables")]
            table_type: f_table_type,
            #[cfg(feature = "sml-tables")]
            header_row_count: f_header_row_count,
            #[cfg(feature = "sml-tables")]
            insert_row: f_insert_row,
            #[cfg(feature = "sml-tables")]
            insert_row_shift: f_insert_row_shift,
            #[cfg(feature = "sml-tables")]
            totals_row_count: f_totals_row_count,
            #[cfg(feature = "sml-tables")]
            totals_row_shown: f_totals_row_shown,
            #[cfg(feature = "sml-tables")]
            published: f_published,
            #[cfg(feature = "sml-tables")]
            header_row_dxf_id: f_header_row_dxf_id,
            #[cfg(feature = "sml-tables")]
            data_dxf_id: f_data_dxf_id,
            #[cfg(feature = "sml-tables")]
            totals_row_dxf_id: f_totals_row_dxf_id,
            #[cfg(feature = "sml-tables")]
            header_row_border_dxf_id: f_header_row_border_dxf_id,
            #[cfg(feature = "sml-tables")]
            table_border_dxf_id: f_table_border_dxf_id,
            #[cfg(feature = "sml-tables")]
            totals_row_border_dxf_id: f_totals_row_border_dxf_id,
            #[cfg(feature = "sml-tables")]
            header_row_cell_style: f_header_row_cell_style,
            #[cfg(feature = "sml-tables")]
            data_cell_style: f_data_cell_style,
            #[cfg(feature = "sml-tables")]
            totals_row_cell_style: f_totals_row_cell_style,
            #[cfg(feature = "sml-tables")]
            connection_id: f_connection_id,
            #[cfg(feature = "sml-tables")]
            auto_filter: f_auto_filter,
            #[cfg(feature = "sml-tables")]
            sort_state: f_sort_state,
            #[cfg(feature = "sml-tables")]
            table_columns: f_table_columns
                .ok_or_else(|| ParseError::MissingAttribute("tableColumns".to_string()))?,
            #[cfg(feature = "sml-tables")]
            table_style_info: f_table_style_info,
            #[cfg(feature = "sml-extensions")]
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for TableStyleInfo {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name = None;
        let mut f_show_first_column = None;
        let mut f_show_last_column = None;
        let mut f_show_row_stripes = None;
        let mut f_show_column_stripes = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"showFirstColumn" => {
                    f_show_first_column = Some(val == "true" || val == "1");
                }
                b"showLastColumn" => {
                    f_show_last_column = Some(val == "true" || val == "1");
                }
                b"showRowStripes" => {
                    f_show_row_stripes = Some(val == "true" || val == "1");
                }
                b"showColumnStripes" => {
                    f_show_column_stripes = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name,
            show_first_column: f_show_first_column,
            show_last_column: f_show_last_column,
            show_row_stripes: f_show_row_stripes,
            show_column_stripes: f_show_column_stripes,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for TableColumns {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_table_column = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"tableColumn" => {
                                f_table_column.push(TableColumn::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"tableColumn" => {
                                f_table_column.push(TableColumn::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            table_column: f_table_column,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for TableColumn {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<u32> = None;
        let mut f_unique_name = None;
        let mut f_name: Option<XmlString> = None;
        let mut f_totals_row_function = None;
        let mut f_totals_row_label = None;
        let mut f_query_table_field_id = None;
        let mut f_header_row_dxf_id = None;
        let mut f_data_dxf_id = None;
        let mut f_totals_row_dxf_id = None;
        let mut f_header_row_cell_style = None;
        let mut f_data_cell_style = None;
        let mut f_totals_row_cell_style = None;
        let mut f_calculated_column_formula = None;
        let mut f_totals_row_formula = None;
        let mut f_xml_column_pr = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"uniqueName" => {
                    f_unique_name = Some(val.into_owned());
                }
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"totalsRowFunction" => {
                    f_totals_row_function = val.parse().ok();
                }
                b"totalsRowLabel" => {
                    f_totals_row_label = Some(val.into_owned());
                }
                b"queryTableFieldId" => {
                    f_query_table_field_id = val.parse().ok();
                }
                b"headerRowDxfId" => {
                    f_header_row_dxf_id = val.parse().ok();
                }
                b"dataDxfId" => {
                    f_data_dxf_id = val.parse().ok();
                }
                b"totalsRowDxfId" => {
                    f_totals_row_dxf_id = val.parse().ok();
                }
                b"headerRowCellStyle" => {
                    f_header_row_cell_style = Some(val.into_owned());
                }
                b"dataCellStyle" => {
                    f_data_cell_style = Some(val.into_owned());
                }
                b"totalsRowCellStyle" => {
                    f_totals_row_cell_style = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"calculatedColumnFormula" => {
                                f_calculated_column_formula =
                                    Some(Box::new(TableFormula::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"totalsRowFormula" => {
                                f_totals_row_formula =
                                    Some(Box::new(TableFormula::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"xmlColumnPr" => {
                                f_xml_column_pr = Some(Box::new(XmlColumnProperties::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"calculatedColumnFormula" => {
                                f_calculated_column_formula =
                                    Some(Box::new(TableFormula::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"totalsRowFormula" => {
                                f_totals_row_formula =
                                    Some(Box::new(TableFormula::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"xmlColumnPr" => {
                                f_xml_column_pr = Some(Box::new(XmlColumnProperties::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            unique_name: f_unique_name,
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            totals_row_function: f_totals_row_function,
            totals_row_label: f_totals_row_label,
            query_table_field_id: f_query_table_field_id,
            header_row_dxf_id: f_header_row_dxf_id,
            data_dxf_id: f_data_dxf_id,
            totals_row_dxf_id: f_totals_row_dxf_id,
            header_row_cell_style: f_header_row_cell_style,
            data_cell_style: f_data_cell_style,
            totals_row_cell_style: f_totals_row_cell_style,
            calculated_column_formula: f_calculated_column_formula,
            totals_row_formula: f_totals_row_formula,
            xml_column_pr: f_xml_column_pr,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for TableFormula {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_text = None;
        let mut f_array = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"array" => {
                    f_array = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::Text(e) => {
                        f_text = Some(e.decode().unwrap_or_default().into_owned());
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            text: f_text,
            array: f_array,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for XmlColumnProperties {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_map_id: Option<u32> = None;
        let mut f_xpath: Option<XmlString> = None;
        let mut f_denormalized = None;
        let mut f_xml_data_type: Option<STXmlDataType> = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"mapId" => {
                    f_map_id = val.parse().ok();
                }
                b"xpath" => {
                    f_xpath = Some(val.into_owned());
                }
                b"denormalized" => {
                    f_denormalized = Some(val == "true" || val == "1");
                }
                b"xmlDataType" => {
                    f_xml_data_type = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            map_id: f_map_id.ok_or_else(|| ParseError::MissingAttribute("mapId".to_string()))?,
            xpath: f_xpath.ok_or_else(|| ParseError::MissingAttribute("xpath".to_string()))?,
            denormalized: f_denormalized,
            xml_data_type: f_xml_data_type
                .ok_or_else(|| ParseError::MissingAttribute("xmlDataType".to_string()))?,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTVolTypes {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_vol_type = Vec::new();
        let mut f_extension_list = None;
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"volType" => {
                                f_vol_type.push(CTVolType::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"volType" => {
                                f_vol_type.push(CTVolType::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            vol_type: f_vol_type,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTVolType {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_type: Option<STVolDepType> = None;
        let mut f_main = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"type" => {
                    f_type = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"main" => {
                                f_main.push(CTVolMain::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"main" => {
                                f_main.push(CTVolMain::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            r#type: f_type.ok_or_else(|| ParseError::MissingAttribute("type".to_string()))?,
            main: f_main,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTVolMain {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_first: Option<XmlString> = None;
        let mut f_tp = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"first" => {
                    f_first = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"tp" => {
                                f_tp.push(CTVolTopic::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"tp" => {
                                f_tp.push(CTVolTopic::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            first: f_first.ok_or_else(|| ParseError::MissingAttribute("first".to_string()))?,
            tp: f_tp,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTVolTopic {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_cell_type = None;
        let mut f_value: Option<XmlString> = None;
        let mut f_stp = Vec::new();
        let mut f_tr = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"t" => {
                    f_cell_type = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"v" => {
                                f_value = Some(read_text_content(reader)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"stp" => {
                                f_stp.push(read_text_content(reader)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tr" => {
                                f_tr.push(CTVolTopicRef::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"v" => {
                                f_value = Some(String::new());
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"stp" => {
                                f_stp.push(String::new());
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"tr" => {
                                f_tr.push(CTVolTopicRef::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            cell_type: f_cell_type,
            value: f_value.ok_or_else(|| ParseError::MissingAttribute("v".to_string()))?,
            stp: f_stp,
            tr: f_tr,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTVolTopicRef {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_reference: Option<CellRef> = None;
        let mut f_style_index: Option<u32> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"r" => {
                    f_reference = Some(val.into_owned());
                }
                b"s" => {
                    f_style_index = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            reference: f_reference.ok_or_else(|| ParseError::MissingAttribute("r".to_string()))?,
            style_index: f_style_index
                .ok_or_else(|| ParseError::MissingAttribute("s".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for Workbook {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_conformance = None;
        let mut f_file_version = None;
        #[cfg(feature = "sml-protection")]
        let mut f_file_sharing = None;
        let mut f_workbook_pr = None;
        #[cfg(feature = "sml-protection")]
        let mut f_workbook_protection = None;
        let mut f_book_views = None;
        let mut f_sheets: Option<Box<Sheets>> = None;
        #[cfg(feature = "sml-formulas-advanced")]
        let mut f_function_groups = None;
        #[cfg(feature = "sml-external")]
        let mut f_external_references = None;
        let mut f_defined_names = None;
        #[cfg(feature = "sml-formulas")]
        let mut f_calc_pr = None;
        #[cfg(feature = "sml-external")]
        let mut f_ole_size = None;
        #[cfg(feature = "sml-structure")]
        let mut f_custom_workbook_views = None;
        #[cfg(feature = "sml-pivot")]
        let mut f_pivot_caches = None;
        #[cfg(feature = "sml-metadata")]
        let mut f_smart_tag_pr = None;
        #[cfg(feature = "sml-metadata")]
        let mut f_smart_tag_types = None;
        #[cfg(feature = "sml-external")]
        let mut f_web_publishing = None;
        let mut f_file_recovery_pr = Vec::new();
        #[cfg(feature = "sml-external")]
        let mut f_web_publish_objects = None;
        #[cfg(feature = "sml-extensions")]
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"conformance" => {
                    f_conformance = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"fileVersion" => {
                                f_file_version =
                                    Some(Box::new(FileVersion::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-protection")]
                            b"fileSharing" => {
                                f_file_sharing =
                                    Some(Box::new(FileSharing::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"workbookPr" => {
                                f_workbook_pr = Some(Box::new(WorkbookProperties::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-protection")]
                            b"workbookProtection" => {
                                f_workbook_protection = Some(Box::new(
                                    WorkbookProtection::from_xml(reader, &e, false)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bookViews" => {
                                f_book_views =
                                    Some(Box::new(BookViews::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sheets" => {
                                f_sheets = Some(Box::new(Sheets::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-formulas-advanced")]
                            b"functionGroups" => {
                                f_function_groups =
                                    Some(Box::new(CTFunctionGroups::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-external")]
                            b"externalReferences" => {
                                f_external_references = Some(Box::new(
                                    ExternalReferences::from_xml(reader, &e, false)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"definedNames" => {
                                f_defined_names =
                                    Some(Box::new(DefinedNames::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-formulas")]
                            b"calcPr" => {
                                f_calc_pr = Some(Box::new(CalculationProperties::from_xml(
                                    reader, &e, false,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-external")]
                            b"oleSize" => {
                                f_ole_size =
                                    Some(Box::new(CTOleSize::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-structure")]
                            b"customWorkbookViews" => {
                                f_custom_workbook_views = Some(Box::new(
                                    CustomWorkbookViews::from_xml(reader, &e, false)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-pivot")]
                            b"pivotCaches" => {
                                f_pivot_caches =
                                    Some(Box::new(PivotCaches::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-metadata")]
                            b"smartTagPr" => {
                                f_smart_tag_pr =
                                    Some(Box::new(CTSmartTagPr::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-metadata")]
                            b"smartTagTypes" => {
                                f_smart_tag_types =
                                    Some(Box::new(CTSmartTagTypes::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-external")]
                            b"webPublishing" => {
                                f_web_publishing =
                                    Some(Box::new(WebPublishing::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"fileRecoveryPr" => {
                                f_file_recovery_pr
                                    .push(FileRecoveryProperties::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-external")]
                            b"webPublishObjects" => {
                                f_web_publish_objects = Some(Box::new(
                                    CTWebPublishObjects::from_xml(reader, &e, false)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-extensions")]
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"fileVersion" => {
                                f_file_version =
                                    Some(Box::new(FileVersion::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-protection")]
                            b"fileSharing" => {
                                f_file_sharing =
                                    Some(Box::new(FileSharing::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"workbookPr" => {
                                f_workbook_pr =
                                    Some(Box::new(WorkbookProperties::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-protection")]
                            b"workbookProtection" => {
                                f_workbook_protection =
                                    Some(Box::new(WorkbookProtection::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"bookViews" => {
                                f_book_views =
                                    Some(Box::new(BookViews::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"sheets" => {
                                f_sheets = Some(Box::new(Sheets::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-formulas-advanced")]
                            b"functionGroups" => {
                                f_function_groups =
                                    Some(Box::new(CTFunctionGroups::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-external")]
                            b"externalReferences" => {
                                f_external_references =
                                    Some(Box::new(ExternalReferences::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"definedNames" => {
                                f_defined_names =
                                    Some(Box::new(DefinedNames::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-formulas")]
                            b"calcPr" => {
                                f_calc_pr = Some(Box::new(CalculationProperties::from_xml(
                                    reader, &e, true,
                                )?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-external")]
                            b"oleSize" => {
                                f_ole_size = Some(Box::new(CTOleSize::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-structure")]
                            b"customWorkbookViews" => {
                                f_custom_workbook_views = Some(Box::new(
                                    CustomWorkbookViews::from_xml(reader, &e, true)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-pivot")]
                            b"pivotCaches" => {
                                f_pivot_caches =
                                    Some(Box::new(PivotCaches::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-metadata")]
                            b"smartTagPr" => {
                                f_smart_tag_pr =
                                    Some(Box::new(CTSmartTagPr::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-metadata")]
                            b"smartTagTypes" => {
                                f_smart_tag_types =
                                    Some(Box::new(CTSmartTagTypes::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-external")]
                            b"webPublishing" => {
                                f_web_publishing =
                                    Some(Box::new(WebPublishing::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            b"fileRecoveryPr" => {
                                f_file_recovery_pr
                                    .push(FileRecoveryProperties::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-external")]
                            b"webPublishObjects" => {
                                f_web_publish_objects = Some(Box::new(
                                    CTWebPublishObjects::from_xml(reader, &e, true)?,
                                ));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "sml-extensions")]
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            conformance: f_conformance,
            file_version: f_file_version,
            #[cfg(feature = "sml-protection")]
            file_sharing: f_file_sharing,
            workbook_pr: f_workbook_pr,
            #[cfg(feature = "sml-protection")]
            workbook_protection: f_workbook_protection,
            book_views: f_book_views,
            sheets: f_sheets.ok_or_else(|| ParseError::MissingAttribute("sheets".to_string()))?,
            #[cfg(feature = "sml-formulas-advanced")]
            function_groups: f_function_groups,
            #[cfg(feature = "sml-external")]
            external_references: f_external_references,
            defined_names: f_defined_names,
            #[cfg(feature = "sml-formulas")]
            calc_pr: f_calc_pr,
            #[cfg(feature = "sml-external")]
            ole_size: f_ole_size,
            #[cfg(feature = "sml-structure")]
            custom_workbook_views: f_custom_workbook_views,
            #[cfg(feature = "sml-pivot")]
            pivot_caches: f_pivot_caches,
            #[cfg(feature = "sml-metadata")]
            smart_tag_pr: f_smart_tag_pr,
            #[cfg(feature = "sml-metadata")]
            smart_tag_types: f_smart_tag_types,
            #[cfg(feature = "sml-external")]
            web_publishing: f_web_publishing,
            file_recovery_pr: f_file_recovery_pr,
            #[cfg(feature = "sml-external")]
            web_publish_objects: f_web_publish_objects,
            #[cfg(feature = "sml-extensions")]
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for FileVersion {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_app_name = None;
        let mut f_last_edited = None;
        let mut f_lowest_edited = None;
        let mut f_rup_build = None;
        let mut f_code_name = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"appName" => {
                    f_app_name = Some(val.into_owned());
                }
                b"lastEdited" => {
                    f_last_edited = Some(val.into_owned());
                }
                b"lowestEdited" => {
                    f_lowest_edited = Some(val.into_owned());
                }
                b"rupBuild" => {
                    f_rup_build = Some(val.into_owned());
                }
                b"codeName" => {
                    f_code_name = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            app_name: f_app_name,
            last_edited: f_last_edited,
            lowest_edited: f_lowest_edited,
            rup_build: f_rup_build,
            code_name: f_code_name,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for BookViews {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_workbook_view = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"workbookView" => {
                                f_workbook_view.push(BookView::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"workbookView" => {
                                f_workbook_view.push(BookView::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            workbook_view: f_workbook_view,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for BookView {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_visibility = None;
        let mut f_minimized = None;
        let mut f_show_horizontal_scroll = None;
        let mut f_show_vertical_scroll = None;
        let mut f_show_sheet_tabs = None;
        let mut f_x_window = None;
        let mut f_y_window = None;
        let mut f_window_width = None;
        let mut f_window_height = None;
        let mut f_tab_ratio = None;
        let mut f_first_sheet = None;
        let mut f_active_tab = None;
        let mut f_auto_filter_date_grouping = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"visibility" => {
                    f_visibility = val.parse().ok();
                }
                b"minimized" => {
                    f_minimized = Some(val == "true" || val == "1");
                }
                b"showHorizontalScroll" => {
                    f_show_horizontal_scroll = Some(val == "true" || val == "1");
                }
                b"showVerticalScroll" => {
                    f_show_vertical_scroll = Some(val == "true" || val == "1");
                }
                b"showSheetTabs" => {
                    f_show_sheet_tabs = Some(val == "true" || val == "1");
                }
                b"xWindow" => {
                    f_x_window = val.parse().ok();
                }
                b"yWindow" => {
                    f_y_window = val.parse().ok();
                }
                b"windowWidth" => {
                    f_window_width = val.parse().ok();
                }
                b"windowHeight" => {
                    f_window_height = val.parse().ok();
                }
                b"tabRatio" => {
                    f_tab_ratio = val.parse().ok();
                }
                b"firstSheet" => {
                    f_first_sheet = val.parse().ok();
                }
                b"activeTab" => {
                    f_active_tab = val.parse().ok();
                }
                b"autoFilterDateGrouping" => {
                    f_auto_filter_date_grouping = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            visibility: f_visibility,
            minimized: f_minimized,
            show_horizontal_scroll: f_show_horizontal_scroll,
            show_vertical_scroll: f_show_vertical_scroll,
            show_sheet_tabs: f_show_sheet_tabs,
            x_window: f_x_window,
            y_window: f_y_window,
            window_width: f_window_width,
            window_height: f_window_height,
            tab_ratio: f_tab_ratio,
            first_sheet: f_first_sheet,
            active_tab: f_active_tab,
            auto_filter_date_grouping: f_auto_filter_date_grouping,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CustomWorkbookViews {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_custom_workbook_view = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"customWorkbookView" => {
                                f_custom_workbook_view
                                    .push(CustomWorkbookView::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"customWorkbookView" => {
                                f_custom_workbook_view
                                    .push(CustomWorkbookView::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            custom_workbook_view: f_custom_workbook_view,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CustomWorkbookView {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name: Option<XmlString> = None;
        let mut f_guid: Option<Guid> = None;
        let mut f_auto_update = None;
        let mut f_merge_interval = None;
        let mut f_changes_saved_win = None;
        let mut f_only_sync = None;
        let mut f_personal_view = None;
        let mut f_include_print_settings = None;
        let mut f_include_hidden_row_col = None;
        let mut f_maximized = None;
        let mut f_minimized = None;
        let mut f_show_horizontal_scroll = None;
        let mut f_show_vertical_scroll = None;
        let mut f_show_sheet_tabs = None;
        let mut f_x_window = None;
        let mut f_y_window = None;
        let mut f_window_width: Option<u32> = None;
        let mut f_window_height: Option<u32> = None;
        let mut f_tab_ratio = None;
        let mut f_active_sheet_id: Option<u32> = None;
        let mut f_show_formula_bar = None;
        let mut f_show_statusbar = None;
        let mut f_show_comments = None;
        let mut f_show_objects = None;
        let mut f_extension_list = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"guid" => {
                    f_guid = Some(val.into_owned());
                }
                b"autoUpdate" => {
                    f_auto_update = Some(val == "true" || val == "1");
                }
                b"mergeInterval" => {
                    f_merge_interval = val.parse().ok();
                }
                b"changesSavedWin" => {
                    f_changes_saved_win = Some(val == "true" || val == "1");
                }
                b"onlySync" => {
                    f_only_sync = Some(val == "true" || val == "1");
                }
                b"personalView" => {
                    f_personal_view = Some(val == "true" || val == "1");
                }
                b"includePrintSettings" => {
                    f_include_print_settings = Some(val == "true" || val == "1");
                }
                b"includeHiddenRowCol" => {
                    f_include_hidden_row_col = Some(val == "true" || val == "1");
                }
                b"maximized" => {
                    f_maximized = Some(val == "true" || val == "1");
                }
                b"minimized" => {
                    f_minimized = Some(val == "true" || val == "1");
                }
                b"showHorizontalScroll" => {
                    f_show_horizontal_scroll = Some(val == "true" || val == "1");
                }
                b"showVerticalScroll" => {
                    f_show_vertical_scroll = Some(val == "true" || val == "1");
                }
                b"showSheetTabs" => {
                    f_show_sheet_tabs = Some(val == "true" || val == "1");
                }
                b"xWindow" => {
                    f_x_window = val.parse().ok();
                }
                b"yWindow" => {
                    f_y_window = val.parse().ok();
                }
                b"windowWidth" => {
                    f_window_width = val.parse().ok();
                }
                b"windowHeight" => {
                    f_window_height = val.parse().ok();
                }
                b"tabRatio" => {
                    f_tab_ratio = val.parse().ok();
                }
                b"activeSheetId" => {
                    f_active_sheet_id = val.parse().ok();
                }
                b"showFormulaBar" => {
                    f_show_formula_bar = Some(val == "true" || val == "1");
                }
                b"showStatusbar" => {
                    f_show_statusbar = Some(val == "true" || val == "1");
                }
                b"showComments" => {
                    f_show_comments = val.parse().ok();
                }
                b"showObjects" => {
                    f_show_objects = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, false)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"extLst" => {
                                f_extension_list =
                                    Some(Box::new(ExtensionList::from_xml(reader, &e, true)?));
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            guid: f_guid.ok_or_else(|| ParseError::MissingAttribute("guid".to_string()))?,
            auto_update: f_auto_update,
            merge_interval: f_merge_interval,
            changes_saved_win: f_changes_saved_win,
            only_sync: f_only_sync,
            personal_view: f_personal_view,
            include_print_settings: f_include_print_settings,
            include_hidden_row_col: f_include_hidden_row_col,
            maximized: f_maximized,
            minimized: f_minimized,
            show_horizontal_scroll: f_show_horizontal_scroll,
            show_vertical_scroll: f_show_vertical_scroll,
            show_sheet_tabs: f_show_sheet_tabs,
            x_window: f_x_window,
            y_window: f_y_window,
            window_width: f_window_width
                .ok_or_else(|| ParseError::MissingAttribute("windowWidth".to_string()))?,
            window_height: f_window_height
                .ok_or_else(|| ParseError::MissingAttribute("windowHeight".to_string()))?,
            tab_ratio: f_tab_ratio,
            active_sheet_id: f_active_sheet_id
                .ok_or_else(|| ParseError::MissingAttribute("activeSheetId".to_string()))?,
            show_formula_bar: f_show_formula_bar,
            show_statusbar: f_show_statusbar,
            show_comments: f_show_comments,
            show_objects: f_show_objects,
            extension_list: f_extension_list,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Sheets {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_sheet = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"sheet" => {
                                f_sheet.push(Sheet::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"sheet" => {
                                f_sheet.push(Sheet::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            sheet: f_sheet,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for Sheet {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name: Option<XmlString> = None;
        let mut f_sheet_id: Option<u32> = None;
        #[cfg(feature = "sml-structure")]
        let mut f_state = None;
        let mut f_id: Option<STRelationshipId> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"sheetId" => {
                    f_sheet_id = val.parse().ok();
                }
                #[cfg(feature = "sml-structure")]
                b"state" => {
                    f_state = val.parse().ok();
                }
                b"id" => {
                    f_id = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            sheet_id: f_sheet_id
                .ok_or_else(|| ParseError::MissingAttribute("sheetId".to_string()))?,
            #[cfg(feature = "sml-structure")]
            state: f_state,
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for WorkbookProperties {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_date1904 = None;
        let mut f_show_objects = None;
        let mut f_show_border_unselected_tables = None;
        let mut f_filter_privacy = None;
        let mut f_prompted_solutions = None;
        let mut f_show_ink_annotation = None;
        let mut f_backup_file = None;
        let mut f_save_external_link_values = None;
        let mut f_update_links = None;
        let mut f_code_name = None;
        let mut f_hide_pivot_field_list = None;
        let mut f_show_pivot_chart_filter = None;
        let mut f_allow_refresh_query = None;
        let mut f_publish_items = None;
        let mut f_check_compatibility = None;
        let mut f_auto_compress_pictures = None;
        let mut f_refresh_all_connections = None;
        let mut f_default_theme_version = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"date1904" => {
                    f_date1904 = Some(val == "true" || val == "1");
                }
                b"showObjects" => {
                    f_show_objects = val.parse().ok();
                }
                b"showBorderUnselectedTables" => {
                    f_show_border_unselected_tables = Some(val == "true" || val == "1");
                }
                b"filterPrivacy" => {
                    f_filter_privacy = Some(val == "true" || val == "1");
                }
                b"promptedSolutions" => {
                    f_prompted_solutions = Some(val == "true" || val == "1");
                }
                b"showInkAnnotation" => {
                    f_show_ink_annotation = Some(val == "true" || val == "1");
                }
                b"backupFile" => {
                    f_backup_file = Some(val == "true" || val == "1");
                }
                b"saveExternalLinkValues" => {
                    f_save_external_link_values = Some(val == "true" || val == "1");
                }
                b"updateLinks" => {
                    f_update_links = val.parse().ok();
                }
                b"codeName" => {
                    f_code_name = Some(val.into_owned());
                }
                b"hidePivotFieldList" => {
                    f_hide_pivot_field_list = Some(val == "true" || val == "1");
                }
                b"showPivotChartFilter" => {
                    f_show_pivot_chart_filter = Some(val == "true" || val == "1");
                }
                b"allowRefreshQuery" => {
                    f_allow_refresh_query = Some(val == "true" || val == "1");
                }
                b"publishItems" => {
                    f_publish_items = Some(val == "true" || val == "1");
                }
                b"checkCompatibility" => {
                    f_check_compatibility = Some(val == "true" || val == "1");
                }
                b"autoCompressPictures" => {
                    f_auto_compress_pictures = Some(val == "true" || val == "1");
                }
                b"refreshAllConnections" => {
                    f_refresh_all_connections = Some(val == "true" || val == "1");
                }
                b"defaultThemeVersion" => {
                    f_default_theme_version = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            date1904: f_date1904,
            show_objects: f_show_objects,
            show_border_unselected_tables: f_show_border_unselected_tables,
            filter_privacy: f_filter_privacy,
            prompted_solutions: f_prompted_solutions,
            show_ink_annotation: f_show_ink_annotation,
            backup_file: f_backup_file,
            save_external_link_values: f_save_external_link_values,
            update_links: f_update_links,
            code_name: f_code_name,
            hide_pivot_field_list: f_hide_pivot_field_list,
            show_pivot_chart_filter: f_show_pivot_chart_filter,
            allow_refresh_query: f_allow_refresh_query,
            publish_items: f_publish_items,
            check_compatibility: f_check_compatibility,
            auto_compress_pictures: f_auto_compress_pictures,
            refresh_all_connections: f_refresh_all_connections,
            default_theme_version: f_default_theme_version,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTSmartTagPr {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_embed = None;
        let mut f_show = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"embed" => {
                    f_embed = Some(val == "true" || val == "1");
                }
                b"show" => {
                    f_show = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            embed: f_embed,
            show: f_show,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTSmartTagTypes {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_smart_tag_type = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"smartTagType" => {
                                f_smart_tag_type.push(CTSmartTagType::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"smartTagType" => {
                                f_smart_tag_type.push(CTSmartTagType::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            smart_tag_type: f_smart_tag_type,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTSmartTagType {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_namespace_uri = None;
        let mut f_name = None;
        let mut f_url = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"namespaceUri" => {
                    f_namespace_uri = Some(val.into_owned());
                }
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"url" => {
                    f_url = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            namespace_uri: f_namespace_uri,
            name: f_name,
            url: f_url,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for FileRecoveryProperties {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_auto_recover = None;
        let mut f_crash_save = None;
        let mut f_data_extract_load = None;
        let mut f_repair_load = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"autoRecover" => {
                    f_auto_recover = Some(val == "true" || val == "1");
                }
                b"crashSave" => {
                    f_crash_save = Some(val == "true" || val == "1");
                }
                b"dataExtractLoad" => {
                    f_data_extract_load = Some(val == "true" || val == "1");
                }
                b"repairLoad" => {
                    f_repair_load = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            auto_recover: f_auto_recover,
            crash_save: f_crash_save,
            data_extract_load: f_data_extract_load,
            repair_load: f_repair_load,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CalculationProperties {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_calc_id = None;
        let mut f_calc_mode = None;
        let mut f_full_calc_on_load = None;
        let mut f_ref_mode = None;
        let mut f_iterate = None;
        let mut f_iterate_count = None;
        let mut f_iterate_delta = None;
        let mut f_full_precision = None;
        let mut f_calc_completed = None;
        let mut f_calc_on_save = None;
        let mut f_concurrent_calc = None;
        let mut f_concurrent_manual_count = None;
        let mut f_force_full_calc = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"calcId" => {
                    f_calc_id = val.parse().ok();
                }
                b"calcMode" => {
                    f_calc_mode = val.parse().ok();
                }
                b"fullCalcOnLoad" => {
                    f_full_calc_on_load = Some(val == "true" || val == "1");
                }
                b"refMode" => {
                    f_ref_mode = val.parse().ok();
                }
                b"iterate" => {
                    f_iterate = Some(val == "true" || val == "1");
                }
                b"iterateCount" => {
                    f_iterate_count = val.parse().ok();
                }
                b"iterateDelta" => {
                    f_iterate_delta = val.parse().ok();
                }
                b"fullPrecision" => {
                    f_full_precision = Some(val == "true" || val == "1");
                }
                b"calcCompleted" => {
                    f_calc_completed = Some(val == "true" || val == "1");
                }
                b"calcOnSave" => {
                    f_calc_on_save = Some(val == "true" || val == "1");
                }
                b"concurrentCalc" => {
                    f_concurrent_calc = Some(val == "true" || val == "1");
                }
                b"concurrentManualCount" => {
                    f_concurrent_manual_count = val.parse().ok();
                }
                b"forceFullCalc" => {
                    f_force_full_calc = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            calc_id: f_calc_id,
            calc_mode: f_calc_mode,
            full_calc_on_load: f_full_calc_on_load,
            ref_mode: f_ref_mode,
            iterate: f_iterate,
            iterate_count: f_iterate_count,
            iterate_delta: f_iterate_delta,
            full_precision: f_full_precision,
            calc_completed: f_calc_completed,
            calc_on_save: f_calc_on_save,
            concurrent_calc: f_concurrent_calc,
            concurrent_manual_count: f_concurrent_manual_count,
            force_full_calc: f_force_full_calc,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for DefinedNames {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_defined_name = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"definedName" => {
                                f_defined_name.push(DefinedName::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"definedName" => {
                                f_defined_name.push(DefinedName::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            defined_name: f_defined_name,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for DefinedName {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_text = None;
        let mut f_name: Option<XmlString> = None;
        let mut f_comment = None;
        #[cfg(feature = "sml-formulas-advanced")]
        let mut f_custom_menu = None;
        let mut f_description = None;
        #[cfg(feature = "sml-formulas-advanced")]
        let mut f_help = None;
        #[cfg(feature = "sml-formulas-advanced")]
        let mut f_status_bar = None;
        let mut f_local_sheet_id = None;
        #[cfg(feature = "sml-structure")]
        let mut f_hidden = None;
        #[cfg(feature = "sml-formulas-advanced")]
        let mut f_function = None;
        #[cfg(feature = "sml-formulas-advanced")]
        let mut f_vb_procedure = None;
        #[cfg(feature = "sml-formulas-advanced")]
        let mut f_xlm = None;
        #[cfg(feature = "sml-formulas-advanced")]
        let mut f_function_group_id = None;
        #[cfg(feature = "sml-formulas-advanced")]
        let mut f_shortcut_key = None;
        #[cfg(feature = "sml-external")]
        let mut f_publish_to_server = None;
        #[cfg(feature = "sml-formulas-advanced")]
        let mut f_workbook_parameter = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                b"comment" => {
                    f_comment = Some(val.into_owned());
                }
                #[cfg(feature = "sml-formulas-advanced")]
                b"customMenu" => {
                    f_custom_menu = Some(val.into_owned());
                }
                b"description" => {
                    f_description = Some(val.into_owned());
                }
                #[cfg(feature = "sml-formulas-advanced")]
                b"help" => {
                    f_help = Some(val.into_owned());
                }
                #[cfg(feature = "sml-formulas-advanced")]
                b"statusBar" => {
                    f_status_bar = Some(val.into_owned());
                }
                b"localSheetId" => {
                    f_local_sheet_id = val.parse().ok();
                }
                #[cfg(feature = "sml-structure")]
                b"hidden" => {
                    f_hidden = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-formulas-advanced")]
                b"function" => {
                    f_function = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-formulas-advanced")]
                b"vbProcedure" => {
                    f_vb_procedure = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-formulas-advanced")]
                b"xlm" => {
                    f_xlm = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-formulas-advanced")]
                b"functionGroupId" => {
                    f_function_group_id = val.parse().ok();
                }
                #[cfg(feature = "sml-formulas-advanced")]
                b"shortcutKey" => {
                    f_shortcut_key = Some(val.into_owned());
                }
                #[cfg(feature = "sml-external")]
                b"publishToServer" => {
                    f_publish_to_server = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "sml-formulas-advanced")]
                b"workbookParameter" => {
                    f_workbook_parameter = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::Text(e) => {
                        f_text = Some(e.decode().unwrap_or_default().into_owned());
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            text: f_text,
            name: f_name.ok_or_else(|| ParseError::MissingAttribute("name".to_string()))?,
            comment: f_comment,
            #[cfg(feature = "sml-formulas-advanced")]
            custom_menu: f_custom_menu,
            description: f_description,
            #[cfg(feature = "sml-formulas-advanced")]
            help: f_help,
            #[cfg(feature = "sml-formulas-advanced")]
            status_bar: f_status_bar,
            local_sheet_id: f_local_sheet_id,
            #[cfg(feature = "sml-structure")]
            hidden: f_hidden,
            #[cfg(feature = "sml-formulas-advanced")]
            function: f_function,
            #[cfg(feature = "sml-formulas-advanced")]
            vb_procedure: f_vb_procedure,
            #[cfg(feature = "sml-formulas-advanced")]
            xlm: f_xlm,
            #[cfg(feature = "sml-formulas-advanced")]
            function_group_id: f_function_group_id,
            #[cfg(feature = "sml-formulas-advanced")]
            shortcut_key: f_shortcut_key,
            #[cfg(feature = "sml-external")]
            publish_to_server: f_publish_to_server,
            #[cfg(feature = "sml-formulas-advanced")]
            workbook_parameter: f_workbook_parameter,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for ExternalReferences {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_external_reference = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"externalReference" => {
                                f_external_reference
                                    .push(ExternalReference::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"externalReference" => {
                                f_external_reference
                                    .push(ExternalReference::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            external_reference: f_external_reference,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for ExternalReference {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STRelationshipId> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for SheetBackgroundPicture {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<STRelationshipId> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for PivotCaches {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_pivot_cache = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"pivotCache" => {
                                f_pivot_cache.push(CTPivotCache::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"pivotCache" => {
                                f_pivot_cache.push(CTPivotCache::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            pivot_cache: f_pivot_cache,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTPivotCache {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_cache_id: Option<u32> = None;
        let mut f_id: Option<STRelationshipId> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"cacheId" => {
                    f_cache_id = val.parse().ok();
                }
                b"id" => {
                    f_id = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            cache_id: f_cache_id
                .ok_or_else(|| ParseError::MissingAttribute("cacheId".to_string()))?,
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for FileSharing {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_read_only_recommended = None;
        let mut f_user_name = None;
        let mut f_reservation_password = None;
        let mut f_algorithm_name = None;
        let mut f_hash_value = None;
        let mut f_salt_value = None;
        let mut f_spin_count = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"readOnlyRecommended" => {
                    f_read_only_recommended = Some(val == "true" || val == "1");
                }
                b"userName" => {
                    f_user_name = Some(val.into_owned());
                }
                b"reservationPassword" => {
                    f_reservation_password = decode_hex(&val);
                }
                b"algorithmName" => {
                    f_algorithm_name = Some(val.into_owned());
                }
                b"hashValue" => {
                    f_hash_value = decode_hex(&val);
                }
                b"saltValue" => {
                    f_salt_value = decode_hex(&val);
                }
                b"spinCount" => {
                    f_spin_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            read_only_recommended: f_read_only_recommended,
            user_name: f_user_name,
            reservation_password: f_reservation_password,
            algorithm_name: f_algorithm_name,
            hash_value: f_hash_value,
            salt_value: f_salt_value,
            spin_count: f_spin_count,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTOleSize {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_reference: Option<Reference> = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"ref" => {
                    f_reference = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            reference: f_reference
                .ok_or_else(|| ParseError::MissingAttribute("ref".to_string()))?,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for WorkbookProtection {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_workbook_password = None;
        let mut f_workbook_password_character_set = None;
        let mut f_revisions_password = None;
        let mut f_revisions_password_character_set = None;
        let mut f_lock_structure = None;
        let mut f_lock_windows = None;
        let mut f_lock_revision = None;
        let mut f_revisions_algorithm_name = None;
        let mut f_revisions_hash_value = None;
        let mut f_revisions_salt_value = None;
        let mut f_revisions_spin_count = None;
        let mut f_workbook_algorithm_name = None;
        let mut f_workbook_hash_value = None;
        let mut f_workbook_salt_value = None;
        let mut f_workbook_spin_count = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"workbookPassword" => {
                    f_workbook_password = decode_hex(&val);
                }
                b"workbookPasswordCharacterSet" => {
                    f_workbook_password_character_set = Some(val.into_owned());
                }
                b"revisionsPassword" => {
                    f_revisions_password = decode_hex(&val);
                }
                b"revisionsPasswordCharacterSet" => {
                    f_revisions_password_character_set = Some(val.into_owned());
                }
                b"lockStructure" => {
                    f_lock_structure = Some(val == "true" || val == "1");
                }
                b"lockWindows" => {
                    f_lock_windows = Some(val == "true" || val == "1");
                }
                b"lockRevision" => {
                    f_lock_revision = Some(val == "true" || val == "1");
                }
                b"revisionsAlgorithmName" => {
                    f_revisions_algorithm_name = Some(val.into_owned());
                }
                b"revisionsHashValue" => {
                    f_revisions_hash_value = decode_hex(&val);
                }
                b"revisionsSaltValue" => {
                    f_revisions_salt_value = decode_hex(&val);
                }
                b"revisionsSpinCount" => {
                    f_revisions_spin_count = val.parse().ok();
                }
                b"workbookAlgorithmName" => {
                    f_workbook_algorithm_name = Some(val.into_owned());
                }
                b"workbookHashValue" => {
                    f_workbook_hash_value = decode_hex(&val);
                }
                b"workbookSaltValue" => {
                    f_workbook_salt_value = decode_hex(&val);
                }
                b"workbookSpinCount" => {
                    f_workbook_spin_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            workbook_password: f_workbook_password,
            workbook_password_character_set: f_workbook_password_character_set,
            revisions_password: f_revisions_password,
            revisions_password_character_set: f_revisions_password_character_set,
            lock_structure: f_lock_structure,
            lock_windows: f_lock_windows,
            lock_revision: f_lock_revision,
            revisions_algorithm_name: f_revisions_algorithm_name,
            revisions_hash_value: f_revisions_hash_value,
            revisions_salt_value: f_revisions_salt_value,
            revisions_spin_count: f_revisions_spin_count,
            workbook_algorithm_name: f_workbook_algorithm_name,
            workbook_hash_value: f_workbook_hash_value,
            workbook_salt_value: f_workbook_salt_value,
            workbook_spin_count: f_workbook_spin_count,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for WebPublishing {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_css = None;
        let mut f_thicket = None;
        let mut f_long_file_names = None;
        let mut f_vml = None;
        let mut f_allow_png = None;
        let mut f_target_screen_size = None;
        let mut f_dpi = None;
        let mut f_code_page = None;
        let mut f_character_set = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"css" => {
                    f_css = Some(val == "true" || val == "1");
                }
                b"thicket" => {
                    f_thicket = Some(val == "true" || val == "1");
                }
                b"longFileNames" => {
                    f_long_file_names = Some(val == "true" || val == "1");
                }
                b"vml" => {
                    f_vml = Some(val == "true" || val == "1");
                }
                b"allowPng" => {
                    f_allow_png = Some(val == "true" || val == "1");
                }
                b"targetScreenSize" => {
                    f_target_screen_size = val.parse().ok();
                }
                b"dpi" => {
                    f_dpi = val.parse().ok();
                }
                b"codePage" => {
                    f_code_page = val.parse().ok();
                }
                b"characterSet" => {
                    f_character_set = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            css: f_css,
            thicket: f_thicket,
            long_file_names: f_long_file_names,
            vml: f_vml,
            allow_png: f_allow_png,
            target_screen_size: f_target_screen_size,
            dpi: f_dpi,
            code_page: f_code_page,
            character_set: f_character_set,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTFunctionGroups {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_built_in_group_count = None;
        let mut f_function_group = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"builtInGroupCount" => {
                    f_built_in_group_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"functionGroup" => {
                                f_function_group
                                    .push(CTFunctionGroup::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"functionGroup" => {
                                f_function_group.push(CTFunctionGroup::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            built_in_group_count: f_built_in_group_count,
            function_group: f_function_group,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTFunctionGroup {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_name = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"name" => {
                    f_name = Some(val.into_owned());
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            name: f_name,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}

impl FromXml for CTWebPublishObjects {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_count = None;
        let mut f_web_publish_object = Vec::new();
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();
        #[cfg(feature = "extra-children")]
        let mut extra_children = Vec::new();
        #[cfg(feature = "extra-children")]
        let mut child_idx: usize = 0;

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"count" => {
                    f_count = val.parse().ok();
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        // Parse child elements
        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::Start(e) => {
                        match e.local_name().as_ref() {
                            b"webPublishObject" => {
                                f_web_publish_object
                                    .push(CTWebPublishObject::from_xml(reader, &e, false)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown element for roundtrip
                                let elem = RawXmlElement::from_reader(reader, &e)?;
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {
                                // Skip unknown element
                                skip_element(reader)?;
                            }
                        }
                    }
                    Event::Empty(e) => {
                        match e.local_name().as_ref() {
                            b"webPublishObject" => {
                                f_web_publish_object
                                    .push(CTWebPublishObject::from_xml(reader, &e, true)?);
                                #[cfg(feature = "extra-children")]
                                {
                                    child_idx += 1;
                                }
                            }
                            #[cfg(feature = "extra-children")]
                            _ => {
                                // Capture unknown empty element for roundtrip
                                let elem = RawXmlElement::from_empty(&e);
                                extra_children.push(PositionedNode::new(
                                    child_idx,
                                    RawXmlNode::Element(elem),
                                ));
                                child_idx += 1;
                            }
                            #[cfg(not(feature = "extra-children"))]
                            _ => {}
                        }
                    }
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            count: f_count,
            web_publish_object: f_web_publish_object,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
            #[cfg(feature = "extra-children")]
            extra_children,
        })
    }
}

impl FromXml for CTWebPublishObject {
    fn from_xml<R: BufRead>(
        reader: &mut Reader<R>,
        start_tag: &BytesStart,
        is_empty: bool,
    ) -> Result<Self, ParseError> {
        let mut f_id: Option<u32> = None;
        let mut f_div_id: Option<XmlString> = None;
        let mut f_source_object = None;
        let mut f_destination_file: Option<XmlString> = None;
        let mut f_title = None;
        let mut f_auto_republish = None;
        #[cfg(feature = "extra-attrs")]
        let mut extra_attrs = std::collections::HashMap::new();

        // Parse attributes
        for attr in start_tag.attributes().filter_map(|a| a.ok()) {
            let val = String::from_utf8_lossy(&attr.value);
            match attr.key.local_name().as_ref() {
                b"id" => {
                    f_id = val.parse().ok();
                }
                b"divId" => {
                    f_div_id = Some(val.into_owned());
                }
                b"sourceObject" => {
                    f_source_object = Some(val.into_owned());
                }
                b"destinationFile" => {
                    f_destination_file = Some(val.into_owned());
                }
                b"title" => {
                    f_title = Some(val.into_owned());
                }
                b"autoRepublish" => {
                    f_auto_republish = Some(val == "true" || val == "1");
                }
                #[cfg(feature = "extra-attrs")]
                unknown => {
                    let key = String::from_utf8_lossy(attr.key.as_ref()).into_owned();
                    extra_attrs.insert(key, val.into_owned());
                }
                #[cfg(not(feature = "extra-attrs"))]
                _ => {}
            }
        }

        if !is_empty {
            let mut buf = Vec::new();
            loop {
                match reader.read_event_into(&mut buf)? {
                    Event::End(_) => break,
                    Event::Eof => break,
                    _ => {}
                }
                buf.clear();
            }
        }

        Ok(Self {
            id: f_id.ok_or_else(|| ParseError::MissingAttribute("id".to_string()))?,
            div_id: f_div_id.ok_or_else(|| ParseError::MissingAttribute("divId".to_string()))?,
            source_object: f_source_object,
            destination_file: f_destination_file
                .ok_or_else(|| ParseError::MissingAttribute("destinationFile".to_string()))?,
            title: f_title,
            auto_republish: f_auto_republish,
            #[cfg(feature = "extra-attrs")]
            extra_attrs,
        })
    }
}
